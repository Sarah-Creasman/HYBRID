model SteamTurbine_L3_HPOFWHsimplified_sec_RealExpressionswitch_FWHExtractionLPT
  parameter NHES.Systems.BalanceOfPlant.RankineCycle.Data.BOP_Type 
    CS.data.FH_type = NHES.Systems.BalanceOfPlant.RankineCycle.Data.BOP_Type.
    OFWH "Type of Feed Heating";
  parameter Modelica.Units.SI.Pressure CS.data.HPT_p_in = 7340000 
    "High Pressure Turbine Inlet Pressure";
  parameter Modelica.Units.SI.Pressure CS.data.p_dump = 10000000 
    "Overpressure Set Pressure  ";
  parameter Modelica.Units.SI.Power CS.data.Power_nom = 5000000.0 
    "Electrical Power Nominal";
  parameter Modelica.Units.SI.Pressure CS.data.p_i1 = 990000 "Set Pressure Between High Pressure Turbine and Low Pressure Turbine 1";
  parameter Modelica.Units.SI.Pressure CS.data.p_i2 = 390000 "Set Pressure Between Low Pressure Turbine 1 and Low Pressure Turbine 2";
  parameter Modelica.Units.SI.Pressure CS.data.cond_p = 10000.0 "Condenser Pressure";
  parameter Modelica.Units.SI.Temperature CS.data.Tin = 562.15 "Inlet Steam Temperature";
  parameter Modelica.Units.SI.Temperature CS.data.Tfeed = 429.85 
    "Target Feed Water Temperature";
  parameter Modelica.Units.SI.Density CS.data.d_HPT_in = 37845 "HPT inlet density";
  parameter Modelica.Units.SI.Density CS.data.d_LPT1_in = 6064.24 
    "LPT1 inlet density";
  parameter Modelica.Units.SI.Density CS.data.d_LPT2_in = 2111.864 
    "LPT2 inlet density";
  parameter Modelica.Units.SI.Pressure CS.data.HPT_p_out = CS.data.p_i1;
  parameter Modelica.Units.SI.Pressure CS.data.LPT1_p_in = CS.data.p_i1;
  parameter Modelica.Units.SI.Pressure CS.data.LPT1_p_out = CS.data.p_i2;
  parameter Modelica.Units.SI.Pressure CS.data.LPT2_p_in = CS.data.p_i2;
  parameter Modelica.Units.SI.Pressure CS.data.LPT2_p_out = CS.data.cond_p;
  parameter Modelica.Units.SI.MassFlowRate CS.data.mdot_total = 1463.311565 
    "Nominal Total Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate CS.data.mdot_fh = 225.08489 
    "Nominal Controlled Feed Heating Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate CS.data.mdpt_HPFH = 0.002 
    "Set High pressure feedwater heating flow (used in models with both LP and HP feed heating";
  parameter Modelica.Units.SI.MassFlowRate CS.data.mdot_hpt = 1238.22666 
    "Nominal Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate CS.data.mdot_lpt1 = 1238.22666 
    "Nominal Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate CS.data.mdot_lpt2 = 995.6849 
    "Nominal Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate CS.data.m_ext = 1;
  parameter Real CS.data.eta_t = 0.93 "Isentropic Efficiency of the Turbines";
  parameter Real CS.data.eta_mech = 1 "Mechincal Effieiency of the Turbines";
  parameter Real CS.data.eta_p = 0.9 "Isentropic Efficiency of the Pumps";
  parameter Real CS.data.BypassFeedHeater_NTU = 20 "NTU of bypass feedwater heater";
  parameter Real CS.data.BypassFeedHeater_K_tube(unit = "1/m4") = 17000 
    "K value of tube in bypass feedwater heater";
  parameter Real CS.data.BypassFeedHeater_K_shell(unit = "1/m4") = 500 
    "K value of shell in bypass feedwater heater";
  parameter Modelica.Units.SI.Volume CS.data.BypassFeedHeater_V_tube = 5 
    "Tube side volume in bypass feedwater heater";
  parameter Modelica.Units.SI.Volume CS.data.BypassFeedHeater_V_shell = 5 
    "Shell side volume in bypass feedwater heater";
  parameter Modelica.Units.SI.Volume CS.data.V_condensor_liquid_start = 1.2 
    "Condensor volume";
  parameter Modelica.Units.SI.Pressure CS.data.BypassFeedHeater_tube_p_start = 
    5500000.0 "Initial Tube pressure of bypass feedwater heater";
  parameter Modelica.Units.SI.Pressure CS.data.BypassFeedHeater_shell_p_start = 
    1000000.0 "Initial Shell pressure of bypass feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy CS.data.BypassFeedHeater_h_start_tube_inlet
     = 1000000.0 "Initial Tube inlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy CS.data.BypassFeedHeater_h_start_tube_outlet
     = 1050000.0 "Initial Tube outlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy CS.data.BypassFeedHeater_h_start_shell_inlet
     = 3000000.0 "Initial Shell inlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy CS.data.BypassFeedHeater_h_start_shell_outlet
     = 2900000.0 "Initial Shell outlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.Temperature CS.data.BypassFeedHeater_tube_T_start_inlet
     = 318 "Initial Tube inlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Temperature CS.data.BypassFeedHeater_tube_T_start_outlet
     = 473 "Initial Tube outlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Temperature CS.data.BypassFeedHeater_shell_T_start_inlet
     = 643 "Initial Tube inlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Temperature CS.data.BypassFeedHeater_shell_T_start_outlet
     = 523 "Initial Tube outlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Pressure CS.data.BypassFeedHeater_dp_init_tube = 0
     "Initial Tube pressure drop of bypass feedwater heater";
  parameter Modelica.Units.SI.Pressure CS.data.BypassFeedHeater_dp_init_shell = 100000
     "Initial Shell pressure drop of bypass feedwater heater";
  parameter Modelica.Units.SI.MassFlowRate CS.data.BypassFeedHeater_m_start_tube
     = 72 "Initial tube mass flow rate in bypass feedwater heater";
  parameter Modelica.Units.SI.MassFlowRate CS.data.BypassFeedHeater_m_start_shell
     = 10 "Initial shell mass flow rate in main feedwater heater";
  parameter Modelica.Units.SI.Power CS.data.BypassFeedHeater_Q_init = 1000000.0 
    "Initial Heat Flow in main feedwater heater";
  constant Modelica.Blocks.Types.SimpleController CS.FeedPump_PID.controllerType
     = Modelica.Blocks.Types.SimpleController.PI "Type of controller";
  constant Boolean CS.FeedPump_PID.with_FF = false "enable feed-forward input signal";
  parameter Boolean CS.FeedPump_PID.derMeas = true "=true avoid derivative kick";
  parameter Real CS.FeedPump_PID.k = -0.0005 "Controller gain: +/- for direct/reverse acting";
  parameter Modelica.Units.SI.Time CS.FeedPump_PID.Ti(min = 1E-60) = 10 
    "Time constant of Integrator block";
  parameter Modelica.Units.SI.Time CS.FeedPump_PID.Td(min = 0.0) = 0.1 
    "Time constant of Derivative block";
  parameter Real CS.FeedPump_PID.yb = 0 "Output bias. May improve simulation";
  parameter Real CS.FeedPump_PID.k_s = 1 "Setpoint input scaling: k_s*u_s. May improve simulation";
  parameter Real CS.FeedPump_PID.k_m = 1 "Measurement input scaling: k_m*u_m. May improve simulation";
  parameter Real CS.FeedPump_PID.k_ff = 1 "Measurement input scaling: k_ff*u_ff. May improve simulation";
  parameter Real CS.FeedPump_PID.yMax(start = 1) = CS.data.mdot_total*2 
    "Upper limit of output";
  parameter Real CS.FeedPump_PID.yMin = CS.data.mdot_total*0.5 "Lower limit of output";
  parameter Real CS.FeedPump_PID.wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
  parameter Real CS.FeedPump_PID.wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
  parameter Real CS.FeedPump_PID.Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
  parameter Real CS.FeedPump_PID.Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
  parameter Modelica.Blocks.Types.Init CS.FeedPump_PID.initType = 
    Modelica.Blocks.Types.Init.NoInit "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
  parameter Real CS.FeedPump_PID.xi_start = 0 "Initial or guess value value for integrator output (= integrator state)";
  parameter Real CS.FeedPump_PID.xd_start = 0 "Initial or guess value for state of derivative block";
  parameter Real CS.FeedPump_PID.y_start = 0 "Initial value of output";
  parameter Boolean CS.FeedPump_PID.strict = false "= true, if strict limits with noEvent(..)";
  constant TRANSFORM.Types.Reset CS.FeedPump_PID.reset = TRANSFORM.Types.Reset.
    Disabled "Type of controller output reset";
  parameter Real CS.FeedPump_PID.y_reset = CS.FeedPump_PID.xi_start 
    "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == TRANSFORM.Types.Reset.Parameter";
  parameter Real CS.FeedPump_PID.addP.k1 = CS.FeedPump_PID.wp "Gain of input signal 1";
  parameter Real CS.FeedPump_PID.addP.k2 = -1 "Gain of input signal 2";
  parameter Real CS.FeedPump_PID.P.k(start = 1, unit = "1") = 1 "Gain value multiplied with input signal";
  parameter Real CS.FeedPump_PID.gainPID.k(start = 1, unit = "1") = 
    CS.FeedPump_PID.k "Gain value multiplied with input signal";
  parameter Real CS.FeedPump_PID.addPID.k1 = 1 "Gain of input signal 1";
  parameter Real CS.FeedPump_PID.addPID.k2 = 1 "Gain of input signal 2";
  parameter Real CS.FeedPump_PID.addPID.k3 = 1 "Gain of input signal 3";
  parameter Real CS.FeedPump_PID.limiter.uMax(start = 1) = CS.FeedPump_PID.yMax 
    "Upper limits of input signals";
  parameter Real CS.FeedPump_PID.limiter.uMin = CS.FeedPump_PID.yMin 
    "Lower limits of input signals";
  parameter Boolean CS.FeedPump_PID.limiter.strict = CS.FeedPump_PID.strict 
    "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy CS.FeedPump_PID.limiter.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Real CS.FeedPump_PID.Fzero.k(start = 1) = 0 "Constant output value";
  parameter Real CS.FeedPump_PID.addFF.k1 = 1 "Gain of input signal 1";
  parameter Real CS.FeedPump_PID.addFF.k2 = 1 "Gain of input signal 2";
  parameter Real CS.FeedPump_PID.addFF.k3 = 1 "Gain of input signal 3";
  parameter Real CS.FeedPump_PID.gain_u_s.k(start = 1, unit = "1") = 
    CS.FeedPump_PID.k_s "Gain value multiplied with input signal";
  parameter Real CS.FeedPump_PID.gain_u_m.k(start = 1, unit = "1") = 
    CS.FeedPump_PID.k_m "Gain value multiplied with input signal";
  parameter Real CS.FeedPump_PID.null_bias.k(start = 1) = CS.FeedPump_PID.yb 
    "Constant output value";
  constant Modelica.Units.SI.Time CS.FeedPump_PID.unitTime = 1;
  constant Boolean CS.FeedPump_PID.with_I = true;
  constant Boolean CS.FeedPump_PID.with_D = false;
  parameter Real CS.FeedPump_PID.I.k(unit = "1") = CS.FeedPump_PID.unitTime/
    CS.FeedPump_PID.Ti "Integrator gain";
  parameter Modelica.Blocks.Types.Init CS.FeedPump_PID.I.initType = (if 
    CS.FeedPump_PID.initType == Modelica.Blocks.Types.Init.SteadyState then 
    Modelica.Blocks.Types.Init.SteadyState else (if CS.FeedPump_PID.initType == 
    Modelica.Blocks.Types.Init.InitialState or CS.FeedPump_PID.initType == 
    Modelica.Blocks.Types.Init.InitialState then Modelica.Blocks.Types.Init.
    InitialState else Modelica.Blocks.Types.Init.NoInit)) "Type of initialization (1: no init, 2: steady state, 3,4: initial output)";
  parameter Real CS.FeedPump_PID.I.y_start = CS.FeedPump_PID.xi_start 
    "Initial or guess value of output (= state)";
  constant TRANSFORM.Types.Reset CS.FeedPump_PID.I.reset = TRANSFORM.Types.Reset.
    Disabled "Type of integrator reset";
  parameter Real CS.FeedPump_PID.I.y_reset = CS.FeedPump_PID.y_reset 
    "Value to which integrator is reset, used if reset = TRANSFORM.Types.Reset.Parameter";
  parameter Real CS.FeedPump_PID.addI.k1 = 1 "Gain of input signal 1";
  parameter Real CS.FeedPump_PID.addI.k2 = -1 "Gain of input signal 2";
  parameter Real CS.FeedPump_PID.addI.k3 = 1 "Gain of input signal 3";
  parameter Real CS.FeedPump_PID.addSat.k1 = 1 "Gain of input signal 1";
  parameter Real CS.FeedPump_PID.addSat.k2 = -1 "Gain of input signal 2";
  parameter Real CS.FeedPump_PID.gainTrack.k(start = 1, unit = "1") = 1/(
    CS.FeedPump_PID.k*CS.FeedPump_PID.Ni) "Gain value multiplied with input signal";
  parameter Real CS.FeedPump_PID.Dzero.k(start = 1) = 0 "Constant output value";
  constant Modelica.Blocks.Types.SimpleController CS.TCV_PID.controllerType = 
    Modelica.Blocks.Types.SimpleController.PI "Type of controller";
  constant Boolean CS.TCV_PID.with_FF = false "enable feed-forward input signal";
  parameter Boolean CS.TCV_PID.derMeas = true "=true avoid derivative kick";
  parameter Real CS.TCV_PID.k = -5E-10 "Controller gain: +/- for direct/reverse acting";
  parameter Modelica.Units.SI.Time CS.TCV_PID.Ti(min = 1E-60) = 360 
    "Time constant of Integrator block";
  parameter Modelica.Units.SI.Time CS.TCV_PID.Td(min = 0.0) = 0.1 
    "Time constant of Derivative block";
  parameter Real CS.TCV_PID.yb = 0 "Output bias. May improve simulation";
  parameter Real CS.TCV_PID.k_s = 1 "Setpoint input scaling: k_s*u_s. May improve simulation";
  parameter Real CS.TCV_PID.k_m = 1 "Measurement input scaling: k_m*u_m. May improve simulation";
  parameter Real CS.TCV_PID.k_ff = 1 "Measurement input scaling: k_ff*u_ff. May improve simulation";
  parameter Real CS.TCV_PID.yMax(start = 1) = 1 "Upper limit of output";
  parameter Real CS.TCV_PID.yMin = 1E-05 "Lower limit of output";
  parameter Real CS.TCV_PID.wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
  parameter Real CS.TCV_PID.wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
  parameter Real CS.TCV_PID.Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
  parameter Real CS.TCV_PID.Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
  parameter Modelica.Blocks.Types.Init CS.TCV_PID.initType = Modelica.Blocks.Types.Init.
    NoInit "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
  parameter Real CS.TCV_PID.xi_start = 0 "Initial or guess value value for integrator output (= integrator state)";
  parameter Real CS.TCV_PID.xd_start = 0 "Initial or guess value for state of derivative block";
  parameter Real CS.TCV_PID.y_start = 0 "Initial value of output";
  parameter Boolean CS.TCV_PID.strict = false "= true, if strict limits with noEvent(..)";
  constant TRANSFORM.Types.Reset CS.TCV_PID.reset = TRANSFORM.Types.Reset.
    Disabled "Type of controller output reset";
  parameter Real CS.TCV_PID.y_reset = CS.TCV_PID.xi_start "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == TRANSFORM.Types.Reset.Parameter";
  parameter Real CS.TCV_PID.addP.k1 = CS.TCV_PID.wp "Gain of input signal 1";
  parameter Real CS.TCV_PID.addP.k2 = -1 "Gain of input signal 2";
  parameter Real CS.TCV_PID.P.k(start = 1, unit = "1") = 1 "Gain value multiplied with input signal";
  parameter Real CS.TCV_PID.gainPID.k(start = 1, unit = "1") = CS.TCV_PID.k 
    "Gain value multiplied with input signal";
  parameter Real CS.TCV_PID.addPID.k1 = 1 "Gain of input signal 1";
  parameter Real CS.TCV_PID.addPID.k2 = 1 "Gain of input signal 2";
  parameter Real CS.TCV_PID.addPID.k3 = 1 "Gain of input signal 3";
  parameter Real CS.TCV_PID.limiter.uMax(start = 1) = CS.TCV_PID.yMax 
    "Upper limits of input signals";
  parameter Real CS.TCV_PID.limiter.uMin = CS.TCV_PID.yMin "Lower limits of input signals";
  parameter Boolean CS.TCV_PID.limiter.strict = CS.TCV_PID.strict 
    "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy CS.TCV_PID.limiter.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Real CS.TCV_PID.Fzero.k(start = 1) = 0 "Constant output value";
  parameter Real CS.TCV_PID.addFF.k1 = 1 "Gain of input signal 1";
  parameter Real CS.TCV_PID.addFF.k2 = 1 "Gain of input signal 2";
  parameter Real CS.TCV_PID.addFF.k3 = 1 "Gain of input signal 3";
  parameter Real CS.TCV_PID.gain_u_s.k(start = 1, unit = "1") = CS.TCV_PID.k_s 
    "Gain value multiplied with input signal";
  parameter Real CS.TCV_PID.gain_u_m.k(start = 1, unit = "1") = CS.TCV_PID.k_m 
    "Gain value multiplied with input signal";
  parameter Real CS.TCV_PID.null_bias.k(start = 1) = CS.TCV_PID.yb 
    "Constant output value";
  constant Modelica.Units.SI.Time CS.TCV_PID.unitTime = 1;
  constant Boolean CS.TCV_PID.with_I = true;
  constant Boolean CS.TCV_PID.with_D = false;
  parameter Real CS.TCV_PID.I.k(unit = "1") = CS.TCV_PID.unitTime/CS.TCV_PID.Ti 
    "Integrator gain";
  parameter Modelica.Blocks.Types.Init CS.TCV_PID.I.initType = (if 
    CS.TCV_PID.initType == Modelica.Blocks.Types.Init.SteadyState then 
    Modelica.Blocks.Types.Init.SteadyState else (if CS.TCV_PID.initType == 
    Modelica.Blocks.Types.Init.InitialState or CS.TCV_PID.initType == 
    Modelica.Blocks.Types.Init.InitialState then Modelica.Blocks.Types.Init.
    InitialState else Modelica.Blocks.Types.Init.NoInit)) "Type of initialization (1: no init, 2: steady state, 3,4: initial output)";
  parameter Real CS.TCV_PID.I.y_start = CS.TCV_PID.xi_start "Initial or guess value of output (= state)";
  constant TRANSFORM.Types.Reset CS.TCV_PID.I.reset = TRANSFORM.Types.Reset.
    Disabled "Type of integrator reset";
  parameter Real CS.TCV_PID.I.y_reset = CS.TCV_PID.y_reset "Value to which integrator is reset, used if reset = TRANSFORM.Types.Reset.Parameter";
  parameter Real CS.TCV_PID.addI.k1 = 1 "Gain of input signal 1";
  parameter Real CS.TCV_PID.addI.k2 = -1 "Gain of input signal 2";
  parameter Real CS.TCV_PID.addI.k3 = 1 "Gain of input signal 3";
  parameter Real CS.TCV_PID.addSat.k1 = 1 "Gain of input signal 1";
  parameter Real CS.TCV_PID.addSat.k2 = -1 "Gain of input signal 2";
  parameter Real CS.TCV_PID.gainTrack.k(start = 1, unit = "1") = 1/(CS.TCV_PID.k
    *CS.TCV_PID.Ni) "Gain value multiplied with input signal";
  parameter Real CS.TCV_PID.Dzero.k(start = 1) = 0 "Constant output value";
  constant Modelica.Blocks.Types.SimpleController CS.LPT1_BV_PID.controllerType
     = Modelica.Blocks.Types.SimpleController.PI "Type of controller";
  constant Boolean CS.LPT1_BV_PID.with_FF = false "enable feed-forward input signal";
  parameter Boolean CS.LPT1_BV_PID.derMeas = true "=true avoid derivative kick";
  parameter Real CS.LPT1_BV_PID.k = 0.001 "Controller gain: +/- for direct/reverse acting";
  parameter Modelica.Units.SI.Time CS.LPT1_BV_PID.Ti(min = 1E-60) = 300 
    "Time constant of Integrator block";
  parameter Modelica.Units.SI.Time CS.LPT1_BV_PID.Td(min = 0.0) = 0.1 
    "Time constant of Derivative block";
  parameter Real CS.LPT1_BV_PID.yb = 0 "Output bias. May improve simulation";
  parameter Real CS.LPT1_BV_PID.k_s = 1 "Setpoint input scaling: k_s*u_s. May improve simulation";
  parameter Real CS.LPT1_BV_PID.k_m = 1 "Measurement input scaling: k_m*u_m. May improve simulation";
  parameter Real CS.LPT1_BV_PID.k_ff = 1 "Measurement input scaling: k_ff*u_ff. May improve simulation";
  parameter Real CS.LPT1_BV_PID.yMax(start = 1) = 1 "Upper limit of output";
  parameter Real CS.LPT1_BV_PID.yMin = 0 "Lower limit of output";
  parameter Real CS.LPT1_BV_PID.wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
  parameter Real CS.LPT1_BV_PID.wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
  parameter Real CS.LPT1_BV_PID.Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
  parameter Real CS.LPT1_BV_PID.Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
  parameter Modelica.Blocks.Types.Init CS.LPT1_BV_PID.initType = 
    Modelica.Blocks.Types.Init.NoInit "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
  parameter Real CS.LPT1_BV_PID.xi_start = 0 "Initial or guess value value for integrator output (= integrator state)";
  parameter Real CS.LPT1_BV_PID.xd_start = 0 "Initial or guess value for state of derivative block";
  parameter Real CS.LPT1_BV_PID.y_start = 0 "Initial value of output";
  parameter Boolean CS.LPT1_BV_PID.strict = false "= true, if strict limits with noEvent(..)";
  constant TRANSFORM.Types.Reset CS.LPT1_BV_PID.reset = TRANSFORM.Types.Reset.
    Disabled "Type of controller output reset";
  parameter Real CS.LPT1_BV_PID.y_reset = CS.LPT1_BV_PID.xi_start 
    "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == TRANSFORM.Types.Reset.Parameter";
  parameter Real CS.LPT1_BV_PID.addP.k1 = CS.LPT1_BV_PID.wp "Gain of input signal 1";
  parameter Real CS.LPT1_BV_PID.addP.k2 = -1 "Gain of input signal 2";
  parameter Real CS.LPT1_BV_PID.P.k(start = 1, unit = "1") = 1 "Gain value multiplied with input signal";
  parameter Real CS.LPT1_BV_PID.gainPID.k(start = 1, unit = "1") = 
    CS.LPT1_BV_PID.k "Gain value multiplied with input signal";
  parameter Real CS.LPT1_BV_PID.addPID.k1 = 1 "Gain of input signal 1";
  parameter Real CS.LPT1_BV_PID.addPID.k2 = 1 "Gain of input signal 2";
  parameter Real CS.LPT1_BV_PID.addPID.k3 = 1 "Gain of input signal 3";
  parameter Real CS.LPT1_BV_PID.limiter.uMax(start = 1) = CS.LPT1_BV_PID.yMax 
    "Upper limits of input signals";
  parameter Real CS.LPT1_BV_PID.limiter.uMin = CS.LPT1_BV_PID.yMin 
    "Lower limits of input signals";
  parameter Boolean CS.LPT1_BV_PID.limiter.strict = CS.LPT1_BV_PID.strict 
    "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy CS.LPT1_BV_PID.limiter.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Real CS.LPT1_BV_PID.Fzero.k(start = 1) = 0 "Constant output value";
  parameter Real CS.LPT1_BV_PID.addFF.k1 = 1 "Gain of input signal 1";
  parameter Real CS.LPT1_BV_PID.addFF.k2 = 1 "Gain of input signal 2";
  parameter Real CS.LPT1_BV_PID.addFF.k3 = 1 "Gain of input signal 3";
  parameter Real CS.LPT1_BV_PID.gain_u_s.k(start = 1, unit = "1") = 
    CS.LPT1_BV_PID.k_s "Gain value multiplied with input signal";
  parameter Real CS.LPT1_BV_PID.gain_u_m.k(start = 1, unit = "1") = 
    CS.LPT1_BV_PID.k_m "Gain value multiplied with input signal";
  parameter Real CS.LPT1_BV_PID.null_bias.k(start = 1) = CS.LPT1_BV_PID.yb 
    "Constant output value";
  constant Modelica.Units.SI.Time CS.LPT1_BV_PID.unitTime = 1;
  constant Boolean CS.LPT1_BV_PID.with_I = true;
  constant Boolean CS.LPT1_BV_PID.with_D = false;
  parameter Real CS.LPT1_BV_PID.I.k(unit = "1") = CS.LPT1_BV_PID.unitTime/
    CS.LPT1_BV_PID.Ti "Integrator gain";
  parameter Modelica.Blocks.Types.Init CS.LPT1_BV_PID.I.initType = (if 
    CS.LPT1_BV_PID.initType == Modelica.Blocks.Types.Init.SteadyState then 
    Modelica.Blocks.Types.Init.SteadyState else (if CS.LPT1_BV_PID.initType == 
    Modelica.Blocks.Types.Init.InitialState or CS.LPT1_BV_PID.initType == 
    Modelica.Blocks.Types.Init.InitialState then Modelica.Blocks.Types.Init.
    InitialState else Modelica.Blocks.Types.Init.NoInit)) "Type of initialization (1: no init, 2: steady state, 3,4: initial output)";
  parameter Real CS.LPT1_BV_PID.I.y_start = CS.LPT1_BV_PID.xi_start 
    "Initial or guess value of output (= state)";
  constant TRANSFORM.Types.Reset CS.LPT1_BV_PID.I.reset = TRANSFORM.Types.Reset.
    Disabled "Type of integrator reset";
  parameter Real CS.LPT1_BV_PID.I.y_reset = CS.LPT1_BV_PID.y_reset 
    "Value to which integrator is reset, used if reset = TRANSFORM.Types.Reset.Parameter";
  parameter Real CS.LPT1_BV_PID.addI.k1 = 1 "Gain of input signal 1";
  parameter Real CS.LPT1_BV_PID.addI.k2 = -1 "Gain of input signal 2";
  parameter Real CS.LPT1_BV_PID.addI.k3 = 1 "Gain of input signal 3";
  parameter Real CS.LPT1_BV_PID.addSat.k1 = 1 "Gain of input signal 1";
  parameter Real CS.LPT1_BV_PID.addSat.k2 = -1 "Gain of input signal 2";
  parameter Real CS.LPT1_BV_PID.gainTrack.k(start = 1, unit = "1") = 1/(
    CS.LPT1_BV_PID.k*CS.LPT1_BV_PID.Ni) "Gain value multiplied with input signal";
  parameter Real CS.LPT1_BV_PID.Dzero.k(start = 1) = 0 "Constant output value";
  constant Modelica.Blocks.Types.SimpleController CS.LPT2_BV_PID.controllerType
     = Modelica.Blocks.Types.SimpleController.PI "Type of controller";
  constant Boolean CS.LPT2_BV_PID.with_FF = false "enable feed-forward input signal";
  parameter Boolean CS.LPT2_BV_PID.derMeas = true "=true avoid derivative kick";
  parameter Real CS.LPT2_BV_PID.k = 1E-07 "Controller gain: +/- for direct/reverse acting";
  parameter Modelica.Units.SI.Time CS.LPT2_BV_PID.Ti(min = 1E-60) = 20 
    "Time constant of Integrator block";
  parameter Modelica.Units.SI.Time CS.LPT2_BV_PID.Td(min = 0.0) = 0.1 
    "Time constant of Derivative block";
  parameter Real CS.LPT2_BV_PID.yb = 0 "Output bias. May improve simulation";
  parameter Real CS.LPT2_BV_PID.k_s = 1 "Setpoint input scaling: k_s*u_s. May improve simulation";
  parameter Real CS.LPT2_BV_PID.k_m = 1 "Measurement input scaling: k_m*u_m. May improve simulation";
  parameter Real CS.LPT2_BV_PID.k_ff = 1 "Measurement input scaling: k_ff*u_ff. May improve simulation";
  parameter Real CS.LPT2_BV_PID.yMax(start = 1) = 1 "Upper limit of output";
  parameter Real CS.LPT2_BV_PID.yMin = 0 "Lower limit of output";
  parameter Real CS.LPT2_BV_PID.wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
  parameter Real CS.LPT2_BV_PID.wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
  parameter Real CS.LPT2_BV_PID.Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
  parameter Real CS.LPT2_BV_PID.Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
  parameter Modelica.Blocks.Types.Init CS.LPT2_BV_PID.initType = 
    Modelica.Blocks.Types.Init.NoInit "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
  parameter Real CS.LPT2_BV_PID.xi_start = 0 "Initial or guess value value for integrator output (= integrator state)";
  parameter Real CS.LPT2_BV_PID.xd_start = 0 "Initial or guess value for state of derivative block";
  parameter Real CS.LPT2_BV_PID.y_start = 0 "Initial value of output";
  parameter Boolean CS.LPT2_BV_PID.strict = false "= true, if strict limits with noEvent(..)";
  constant TRANSFORM.Types.Reset CS.LPT2_BV_PID.reset = TRANSFORM.Types.Reset.
    Disabled "Type of controller output reset";
  parameter Real CS.LPT2_BV_PID.y_reset = CS.LPT2_BV_PID.xi_start 
    "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == TRANSFORM.Types.Reset.Parameter";
  parameter Real CS.LPT2_BV_PID.addP.k1 = CS.LPT2_BV_PID.wp "Gain of input signal 1";
  parameter Real CS.LPT2_BV_PID.addP.k2 = -1 "Gain of input signal 2";
  parameter Real CS.LPT2_BV_PID.P.k(start = 1, unit = "1") = 1 "Gain value multiplied with input signal";
  parameter Real CS.LPT2_BV_PID.gainPID.k(start = 1, unit = "1") = 
    CS.LPT2_BV_PID.k "Gain value multiplied with input signal";
  parameter Real CS.LPT2_BV_PID.addPID.k1 = 1 "Gain of input signal 1";
  parameter Real CS.LPT2_BV_PID.addPID.k2 = 1 "Gain of input signal 2";
  parameter Real CS.LPT2_BV_PID.addPID.k3 = 1 "Gain of input signal 3";
  parameter Real CS.LPT2_BV_PID.limiter.uMax(start = 1) = CS.LPT2_BV_PID.yMax 
    "Upper limits of input signals";
  parameter Real CS.LPT2_BV_PID.limiter.uMin = CS.LPT2_BV_PID.yMin 
    "Lower limits of input signals";
  parameter Boolean CS.LPT2_BV_PID.limiter.strict = CS.LPT2_BV_PID.strict 
    "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy CS.LPT2_BV_PID.limiter.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Real CS.LPT2_BV_PID.Fzero.k(start = 1) = 0 "Constant output value";
  parameter Real CS.LPT2_BV_PID.addFF.k1 = 1 "Gain of input signal 1";
  parameter Real CS.LPT2_BV_PID.addFF.k2 = 1 "Gain of input signal 2";
  parameter Real CS.LPT2_BV_PID.addFF.k3 = 1 "Gain of input signal 3";
  parameter Real CS.LPT2_BV_PID.gain_u_s.k(start = 1, unit = "1") = 
    CS.LPT2_BV_PID.k_s "Gain value multiplied with input signal";
  parameter Real CS.LPT2_BV_PID.gain_u_m.k(start = 1, unit = "1") = 
    CS.LPT2_BV_PID.k_m "Gain value multiplied with input signal";
  parameter Real CS.LPT2_BV_PID.null_bias.k(start = 1) = CS.LPT2_BV_PID.yb 
    "Constant output value";
  constant Modelica.Units.SI.Time CS.LPT2_BV_PID.unitTime = 1;
  constant Boolean CS.LPT2_BV_PID.with_I = true;
  constant Boolean CS.LPT2_BV_PID.with_D = false;
  parameter Real CS.LPT2_BV_PID.I.k(unit = "1") = CS.LPT2_BV_PID.unitTime/
    CS.LPT2_BV_PID.Ti "Integrator gain";
  parameter Modelica.Blocks.Types.Init CS.LPT2_BV_PID.I.initType = (if 
    CS.LPT2_BV_PID.initType == Modelica.Blocks.Types.Init.SteadyState then 
    Modelica.Blocks.Types.Init.SteadyState else (if CS.LPT2_BV_PID.initType == 
    Modelica.Blocks.Types.Init.InitialState or CS.LPT2_BV_PID.initType == 
    Modelica.Blocks.Types.Init.InitialState then Modelica.Blocks.Types.Init.
    InitialState else Modelica.Blocks.Types.Init.NoInit)) "Type of initialization (1: no init, 2: steady state, 3,4: initial output)";
  parameter Real CS.LPT2_BV_PID.I.y_start = CS.LPT2_BV_PID.xi_start 
    "Initial or guess value of output (= state)";
  constant TRANSFORM.Types.Reset CS.LPT2_BV_PID.I.reset = TRANSFORM.Types.Reset.
    Disabled "Type of integrator reset";
  parameter Real CS.LPT2_BV_PID.I.y_reset = CS.LPT2_BV_PID.y_reset 
    "Value to which integrator is reset, used if reset = TRANSFORM.Types.Reset.Parameter";
  parameter Real CS.LPT2_BV_PID.addI.k1 = 1 "Gain of input signal 1";
  parameter Real CS.LPT2_BV_PID.addI.k2 = -1 "Gain of input signal 2";
  parameter Real CS.LPT2_BV_PID.addI.k3 = 1 "Gain of input signal 3";
  parameter Real CS.LPT2_BV_PID.addSat.k1 = 1 "Gain of input signal 1";
  parameter Real CS.LPT2_BV_PID.addSat.k2 = -1 "Gain of input signal 2";
  parameter Real CS.LPT2_BV_PID.gainTrack.k(start = 1, unit = "1") = 1/(
    CS.LPT2_BV_PID.k*CS.LPT2_BV_PID.Ni) "Gain value multiplied with input signal";
  parameter Real CS.LPT2_BV_PID.Dzero.k(start = 1) = 0 "Constant output value";
  parameter Real CS.hysteresis.uLow(start = 0) = 70 "If y=true and u<uLow, switch to y=false";
  parameter Real CS.hysteresis.uHigh(start = 1) = 100 "If y=false and u>uHigh, switch to y=true";
  parameter Boolean CS.hysteresis.pre_y_start = false "Value of pre(y) at initial time";
  parameter Modelica.Units.SI.Time CS.booleanStep.startTime = 4000 
    "Time instant of step start";
  parameter Boolean CS.booleanStep.startValue = false "Output before startTime";
  parameter Modelica.Units.SI.Time CS.booleanStep1.startTime = 1200000 
    "Time instant of step start";
  parameter Boolean CS.booleanStep1.startValue = false "Output before startTime";
  parameter Modelica.Units.SI.Time CS.booleanStep2.startTime = 1200000.0 
    "Time instant of step start";
  parameter Boolean CS.booleanStep2.startValue = false "Output before startTime";
  parameter Real CS.ext_pos_start.height = 0 "Height of ramps";
  parameter Modelica.Units.SI.Time CS.ext_pos_start.duration(start = 2, min = 
    0.0) = 1000 "Duration of ramp (= 0.0 gives a Step)";
  parameter Real CS.ext_pos_start.offset = 0 "Offset of output signal y";
  parameter Modelica.Units.SI.Time CS.ext_pos_start.startTime = 2000 
    "Output y = offset for time < startTime";
  parameter NHES.Systems.BalanceOfPlant.RankineCycle.Data.BOP_Type data.FH_type
     = NHES.Systems.BalanceOfPlant.RankineCycle.Data.BOP_Type.OFWH 
    "Type of Feed Heating";
  parameter Modelica.Units.SI.Pressure data.HPT_p_in = 7340000 "High Pressure Turbine Inlet Pressure";
  parameter Modelica.Units.SI.Pressure data.p_dump = 20000000.0 "Overpressure Set Pressure  ";
  parameter Modelica.Units.SI.Power data.Power_nom = 3100000000.0 
    "Electrical Power Nominal";
  parameter Modelica.Units.SI.Pressure data.p_i1 = 990000.0 "Set Pressure Between High Pressure Turbine and Low Pressure Turbine 1";
  parameter Modelica.Units.SI.Pressure data.p_i2 = 990000.0 "Set Pressure Between Low Pressure Turbine 1 and Low Pressure Turbine 2";
  parameter Modelica.Units.SI.Pressure data.cond_p = 10000.0 "Condenser Pressure";
  parameter Modelica.Units.SI.Temperature data.Tin = 565.15 "Inlet Steam Temperature";
  parameter Modelica.Units.SI.Temperature data.Tfeed = 429.85 "Target Feed Water Temperature";
  parameter Modelica.Units.SI.Density data.d_HPT_in = 37845.1727 
    "HPT inlet density";
  parameter Modelica.Units.SI.Density data.d_LPT1_in = 37845.1727 
    "LPT1 inlet density";
  parameter Modelica.Units.SI.Density data.d_LPT2_in = 5096.357584 
    "LPT2 inlet density";
  parameter Modelica.Units.SI.Pressure data.HPT_p_out = data.p_i1;
  parameter Modelica.Units.SI.Pressure data.LPT1_p_in = data.p_i1;
  parameter Modelica.Units.SI.Pressure data.LPT1_p_out = data.p_i2;
  parameter Modelica.Units.SI.Pressure data.LPT2_p_in = data.p_i2;
  parameter Modelica.Units.SI.Pressure data.LPT2_p_out = data.cond_p;
  parameter Modelica.Units.SI.MassFlowRate data.mdot_total = 1463.311565 
    "Nominal Total Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate data.mdot_fh = 220.5503427 
    "Nominal Controlled Feed Heating Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate data.mdpt_HPFH = 0.002 
    "Set High pressure feedwater heating flow (used in models with both LP and HP feed heating";
  parameter Modelica.Units.SI.MassFlowRate data.mdot_hpt = 1242.761222 
    "Nominal Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate data.mdot_lpt1 = 1242.761222 
    "Nominal Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate data.mdot_lpt2 = 1049.8559 
    "Nominal Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate data.m_ext = 1;
  parameter Modelica.Units.SI.AbsolutePressure data.p_use = 100000.0;
  parameter Real data.eta_t = 0.9 "Isentropic Efficiency of the Turbines";
  parameter Real data.eta_mech = 1 "Mechincal Effieiency of the Turbines";
  parameter Real data.eta_p = 0.8 "Isentropic Efficiency of the Pumps";
  parameter Real data.BypassFeedHeater_NTU = 20 "NTU of bypass feedwater heater";
  parameter Real data.BypassFeedHeater_K_tube(unit = "1/m4") = 17000 
    "K value of tube in bypass feedwater heater";
  parameter Real data.BypassFeedHeater_K_shell(unit = "1/m4") = 500 
    "K value of shell in bypass feedwater heater";
  parameter Modelica.Units.SI.Volume data.BypassFeedHeater_V_tube = 5 
    "Tube side volume in bypass feedwater heater";
  parameter Modelica.Units.SI.Volume data.BypassFeedHeater_V_shell = 5 
    "Shell side volume in bypass feedwater heater";
  parameter Modelica.Units.SI.Volume data.V_condensor_liquid_start = 1.2 
    "Condensor volume";
  parameter Modelica.Units.SI.Pressure data.BypassFeedHeater_tube_p_start = 
    5500000.0 "Initial Tube pressure of bypass feedwater heater";
  parameter Modelica.Units.SI.Pressure data.BypassFeedHeater_shell_p_start = 
    1000000.0 "Initial Shell pressure of bypass feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy data.BypassFeedHeater_h_start_tube_inlet
     = 1000000.0 "Initial Tube inlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy data.BypassFeedHeater_h_start_tube_outlet
     = 1050000.0 "Initial Tube outlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy data.BypassFeedHeater_h_start_shell_inlet
     = 3000000.0 "Initial Shell inlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy data.BypassFeedHeater_h_start_shell_outlet
     = 2900000.0 "Initial Shell outlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.Temperature data.BypassFeedHeater_tube_T_start_inlet
     = 318 "Initial Tube inlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Temperature data.BypassFeedHeater_tube_T_start_outlet
     = 473 "Initial Tube outlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Temperature data.BypassFeedHeater_shell_T_start_inlet
     = 643 "Initial Tube inlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Temperature data.BypassFeedHeater_shell_T_start_outlet
     = 523 "Initial Tube outlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Pressure data.BypassFeedHeater_dp_init_tube = 0 
    "Initial Tube pressure drop of bypass feedwater heater";
  parameter Modelica.Units.SI.Pressure data.BypassFeedHeater_dp_init_shell = 100000
     "Initial Shell pressure drop of bypass feedwater heater";
  parameter Modelica.Units.SI.MassFlowRate data.BypassFeedHeater_m_start_tube = 72
     "Initial tube mass flow rate in bypass feedwater heater";
  parameter Modelica.Units.SI.MassFlowRate data.BypassFeedHeater_m_start_shell
     = 10 "Initial shell mass flow rate in main feedwater heater";
  parameter Modelica.Units.SI.Power data.BypassFeedHeater_Q_init = 1000000.0 
    "Initial Heat Flow in main feedwater heater";
  parameter Modelica.Units.SI.AbsolutePressure HPT.system.p_ambient = 101325 
    "Default ambient pressure";
  parameter Modelica.Units.SI.Temperature HPT.system.T_ambient = 293.15 
    "Default ambient temperature";
  parameter Modelica.Units.SI.Acceleration HPT.system.g = 9.80665 
    "Constant gravity acceleration";
  constant Boolean HPT.system.allowFlowReversal = true "= false to restrict to design flow direction (port_a -> port_b)";
  parameter Modelica.Fluid.Types.Dynamics HPT.system.energyDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics HPT.system.massDynamics = 
    HPT.system.energyDynamics "Default formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics HPT.system.substanceDynamics = 
    HPT.system.massDynamics "Default formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics HPT.system.traceDynamics = 
    HPT.system.massDynamics "Default formulation of trace substance balances";
  parameter Modelica.Fluid.Types.Dynamics HPT.system.momentumDynamics = 
    Modelica.Fluid.Types.Dynamics.SteadyState "Default formulation of momentum balances, if options available";
  parameter Modelica.Units.SI.MassFlowRate HPT.system.m_flow_start = 0 
    "Default start value for mass flow rates";
  parameter Modelica.Units.SI.AbsolutePressure HPT.system.p_start = 
    HPT.system.p_ambient "Default start value for pressures";
  parameter Modelica.Units.SI.Temperature HPT.system.T_start = HPT.system.T_ambient
     "Default start value for temperatures";
  parameter Boolean HPT.system.use_eps_Re = false "= true to determine turbulent region automatically using Reynolds number";
  parameter Modelica.Units.SI.MassFlowRate HPT.system.m_flow_nominal = (if 
    HPT.system.use_eps_Re then 1 else 100.0*HPT.system.m_flow_small) 
    "Default nominal mass flow rate";
  parameter Real HPT.system.eps_m_flow(min = 0.0) = 0.0001 "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal";
  parameter Modelica.Units.SI.AbsolutePressure HPT.system.dp_small = 1 
    "Default small pressure drop for regularization of laminar and zero flow";
  parameter Modelica.Units.SI.MassFlowRate HPT.system.m_flow_small(min = 0.0) = 
    0.01 "Default small mass flow rate for regularization of laminar and zero flow";
  constant Boolean HPT.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction";
  parameter Integer HPT.nUnits = 1 "Number of turbine units, e.g., high pressure and low pressure";
  parameter TRANSFORM.Types.Dynamics HPT.energyDynamics = TRANSFORM.Types.Dynamics.
    SteadyState "=true to use turbine dynamics";
  parameter Modelica.Units.SI.Time HPT.taus[HPT.nUnits] = fill(1, HPT.nUnits) 
    "Characteristic time constant of each unit";
  parameter TRANSFORM.Units.NonDim HPT.Q_fracs[HPT.nUnits] = fill(1/HPT.nUnits, 
    HPT.nUnits) "Fraction of power provided per unit";
  parameter Modelica.Units.SI.Power HPT.Q_units_start[HPT.nUnits] = fill(
    HPT.m_flow_start*(HPT.h_a_start-HPT.h_b_start)/HPT.nUnits, HPT.nUnits) 
    "Initial power output per unit";
  parameter Real HPT.eta_mech = data.eta_mech "Mechanical efficiency";
  parameter Modelica.Units.SI.Efficiency HPT.eta_wetSteam.eta_nominal = 
    data.eta_t "Nominal efficiency due to wetness";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure HPT.p_a_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = data.HPT_p_in 
    "Pressure at port a";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure HPT.p_b_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = data.HPT_p_out 
    "Pressure at port b";
  parameter Boolean HPT.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Media.Interfaces.Types.Temperature HPT.T_a_start(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) = data.Tin "Temperature at port a";
  parameter Modelica.Media.Interfaces.Types.Temperature HPT.T_b_start(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) = 452.55 "Temperature at port b";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy HPT.h_a_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique1
    (HPT.p_a_start, HPT.T_a_start, HPT.X_start, 0) "Specific enthalpy at port a";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy HPT.h_b_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.isentropicEnthalpy_Unique7
    (
    HPT.p_b_start, 
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(HPT.p_a_start, 
      HPT.h_a_start, HPT.X_start, 0, 0)) "Specific enthalpy at port b";
  parameter Modelica.Media.Interfaces.Types.MassFraction HPT.X_start[1] = {1.0} 
    "Mass fractions m_i/m";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty HPT.C_start[0](
    start = fill(1.0, size(HPT.C_start, 1))) = fill(0, 0) "Trace substances";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    HPT.m_flow_start = data.mdot_hpt "Mass flow rate";
  constant Modelica.Units.SI.Pressure HPT.p_crit = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
    .criticalPressure "Medium critical pressure";
  parameter Real HPT.partialArc_nominal = 1 "Nominal partial arc";
  parameter Modelica.Units.SI.MassFlowRate HPT.m_flow_nominal = data.mdot_hpt 
    "Nominal mass flowrate";
  parameter Boolean HPT.use_Stodola = true "=true to use Stodola's law, i.e., infinite stages per unit";
  parameter Modelica.Units.SI.Area HPT.Kt_constant = 0.01 "Constant coefficient of Stodola's law";
  parameter Boolean HPT.use_NominalInlet = true "=true then Kt is calculated from nominal inlet conditions";
  parameter Modelica.Units.SI.Pressure HPT.p_inlet_nominal = data.HPT_p_in 
    "Nominal inlet pressure";
  parameter Modelica.Units.SI.Pressure HPT.p_outlet_nominal = data.HPT_p_out 
    "Nominal outlet pressure";
  parameter Boolean HPT.use_T_nominal = false "=true then use temperature for Kt else density";
  parameter Modelica.Units.SI.Temperature HPT.T_nominal = data.Tin 
    "Nominal inlet temperature";
  parameter Modelica.Units.SI.Density HPT.d_nominal = data.d_HPT_in 
    "Nominal inlet density";
  parameter Modelica.Units.SI.Area HPT.Kt(fixed = false) "Flow area coefficient";
  parameter Modelica.Units.SI.AbsolutePressure LPT1.system.p_ambient = 101325 
    "Default ambient pressure";
  parameter Modelica.Units.SI.Temperature LPT1.system.T_ambient = 293.15 
    "Default ambient temperature";
  parameter Modelica.Units.SI.Acceleration LPT1.system.g = 9.80665 
    "Constant gravity acceleration";
  constant Boolean LPT1.system.allowFlowReversal = true "= false to restrict to design flow direction (port_a -> port_b)";
  parameter Modelica.Fluid.Types.Dynamics LPT1.system.energyDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics LPT1.system.massDynamics = 
    LPT1.system.energyDynamics "Default formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics LPT1.system.substanceDynamics = 
    LPT1.system.massDynamics "Default formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics LPT1.system.traceDynamics = 
    LPT1.system.massDynamics "Default formulation of trace substance balances";
  parameter Modelica.Fluid.Types.Dynamics LPT1.system.momentumDynamics = 
    Modelica.Fluid.Types.Dynamics.SteadyState "Default formulation of momentum balances, if options available";
  parameter Modelica.Units.SI.MassFlowRate LPT1.system.m_flow_start = 0 
    "Default start value for mass flow rates";
  parameter Modelica.Units.SI.AbsolutePressure LPT1.system.p_start = 
    LPT1.system.p_ambient "Default start value for pressures";
  parameter Modelica.Units.SI.Temperature LPT1.system.T_start = LPT1.system.T_ambient
     "Default start value for temperatures";
  parameter Boolean LPT1.system.use_eps_Re = false "= true to determine turbulent region automatically using Reynolds number";
  parameter Modelica.Units.SI.MassFlowRate LPT1.system.m_flow_nominal = (if 
    LPT1.system.use_eps_Re then 1 else 100.0*LPT1.system.m_flow_small) 
    "Default nominal mass flow rate";
  parameter Real LPT1.system.eps_m_flow(min = 0.0) = 0.0001 "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal";
  parameter Modelica.Units.SI.AbsolutePressure LPT1.system.dp_small = 1 
    "Default small pressure drop for regularization of laminar and zero flow";
  parameter Modelica.Units.SI.MassFlowRate LPT1.system.m_flow_small(min = 0.0)
     = 0.01 "Default small mass flow rate for regularization of laminar and zero flow";
  constant Boolean LPT1.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction";
  parameter Integer LPT1.nUnits = 1 "Number of turbine units, e.g., high pressure and low pressure";
  parameter TRANSFORM.Types.Dynamics LPT1.energyDynamics = TRANSFORM.Types.Dynamics.
    SteadyState "=true to use turbine dynamics";
  parameter Modelica.Units.SI.Time LPT1.taus[LPT1.nUnits] = fill(1, LPT1.nUnits)
     "Characteristic time constant of each unit";
  parameter TRANSFORM.Units.NonDim LPT1.Q_fracs[LPT1.nUnits] = fill(1/
    LPT1.nUnits, LPT1.nUnits) "Fraction of power provided per unit";
  parameter Modelica.Units.SI.Power LPT1.Q_units_start[LPT1.nUnits] = fill(
    LPT1.m_flow_start*(LPT1.h_a_start-LPT1.h_b_start)/LPT1.nUnits, LPT1.nUnits) 
    "Initial power output per unit";
  parameter Real LPT1.eta_mech = data.eta_mech "Mechanical efficiency";
  parameter Modelica.Units.SI.Efficiency LPT1.eta_wetSteam.eta_nominal = 
    data.eta_t "Nominal efficiency due to wetness";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure LPT1.p_a_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = data.LPT1_p_in 
    "Pressure at port a";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure LPT1.p_b_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = data.LPT1_p_out 
    "Pressure at port b";
  parameter Boolean LPT1.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Media.Interfaces.Types.Temperature LPT1.T_a_start(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) = 452.55 "Temperature at port a";
  parameter Modelica.Media.Interfaces.Types.Temperature LPT1.T_b_start(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) = 433.35 "Temperature at port b";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1.h_a_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique1
    (LPT1.p_a_start, LPT1.T_a_start, LPT1.X_start, 0) "Specific enthalpy at port a";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1.h_b_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.isentropicEnthalpy_Unique7
    (
    LPT1.p_b_start, 
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(LPT1.p_a_start, 
      LPT1.h_a_start, LPT1.X_start, 0, 0)) "Specific enthalpy at port b";
  parameter Modelica.Media.Interfaces.Types.MassFraction LPT1.X_start[1] = {1.0}
     "Mass fractions m_i/m";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty LPT1.C_start[0](
    start = fill(1.0, size(LPT1.C_start, 1))) = fill(0, 0) "Trace substances";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    LPT1.m_flow_start = data.mdot_lpt1 "Mass flow rate";
  constant Modelica.Units.SI.Pressure LPT1.p_crit = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
    .criticalPressure "Medium critical pressure";
  parameter Real LPT1.partialArc_nominal = 1 "Nominal partial arc";
  parameter Modelica.Units.SI.MassFlowRate LPT1.m_flow_nominal = data.mdot_lpt1 
    "Nominal mass flowrate";
  parameter Boolean LPT1.use_Stodola = true "=true to use Stodola's law, i.e., infinite stages per unit";
  parameter Modelica.Units.SI.Area LPT1.Kt_constant = 0.01 "Constant coefficient of Stodola's law";
  parameter Boolean LPT1.use_NominalInlet = true "=true then Kt is calculated from nominal inlet conditions";
  parameter Modelica.Units.SI.Pressure LPT1.p_inlet_nominal = data.LPT1_p_in 
    "Nominal inlet pressure";
  parameter Modelica.Units.SI.Pressure LPT1.p_outlet_nominal = data.LPT1_p_out 
    "Nominal outlet pressure";
  parameter Boolean LPT1.use_T_nominal = false "=true then use temperature for Kt else density";
  parameter Modelica.Units.SI.Temperature LPT1.T_nominal = LPT1.T_a_start 
    "Nominal inlet temperature";
  parameter Modelica.Units.SI.Density LPT1.d_nominal = data.d_LPT1_in 
    "Nominal inlet density";
  parameter Modelica.Units.SI.Area LPT1.Kt(fixed = false) "Flow area coefficient";
  parameter Modelica.Units.SI.AbsolutePressure LPT2.system.p_ambient = 101325 
    "Default ambient pressure";
  parameter Modelica.Units.SI.Temperature LPT2.system.T_ambient = 293.15 
    "Default ambient temperature";
  parameter Modelica.Units.SI.Acceleration LPT2.system.g = 9.80665 
    "Constant gravity acceleration";
  constant Boolean LPT2.system.allowFlowReversal = true "= false to restrict to design flow direction (port_a -> port_b)";
  parameter Modelica.Fluid.Types.Dynamics LPT2.system.energyDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics LPT2.system.massDynamics = 
    LPT2.system.energyDynamics "Default formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics LPT2.system.substanceDynamics = 
    LPT2.system.massDynamics "Default formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics LPT2.system.traceDynamics = 
    LPT2.system.massDynamics "Default formulation of trace substance balances";
  parameter Modelica.Fluid.Types.Dynamics LPT2.system.momentumDynamics = 
    Modelica.Fluid.Types.Dynamics.SteadyState "Default formulation of momentum balances, if options available";
  parameter Modelica.Units.SI.MassFlowRate LPT2.system.m_flow_start = 0 
    "Default start value for mass flow rates";
  parameter Modelica.Units.SI.AbsolutePressure LPT2.system.p_start = 
    LPT2.system.p_ambient "Default start value for pressures";
  parameter Modelica.Units.SI.Temperature LPT2.system.T_start = LPT2.system.T_ambient
     "Default start value for temperatures";
  parameter Boolean LPT2.system.use_eps_Re = false "= true to determine turbulent region automatically using Reynolds number";
  parameter Modelica.Units.SI.MassFlowRate LPT2.system.m_flow_nominal = (if 
    LPT2.system.use_eps_Re then 1 else 100.0*LPT2.system.m_flow_small) 
    "Default nominal mass flow rate";
  parameter Real LPT2.system.eps_m_flow(min = 0.0) = 0.0001 "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal";
  parameter Modelica.Units.SI.AbsolutePressure LPT2.system.dp_small = 1 
    "Default small pressure drop for regularization of laminar and zero flow";
  parameter Modelica.Units.SI.MassFlowRate LPT2.system.m_flow_small(min = 0.0)
     = 0.01 "Default small mass flow rate for regularization of laminar and zero flow";
  constant Boolean LPT2.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction";
  parameter Integer LPT2.nUnits = 1 "Number of turbine units, e.g., high pressure and low pressure";
  parameter TRANSFORM.Types.Dynamics LPT2.energyDynamics = TRANSFORM.Types.Dynamics.
    SteadyState "=true to use turbine dynamics";
  parameter Modelica.Units.SI.Time LPT2.taus[LPT2.nUnits] = fill(1, LPT2.nUnits)
     "Characteristic time constant of each unit";
  parameter TRANSFORM.Units.NonDim LPT2.Q_fracs[LPT2.nUnits] = fill(1/
    LPT2.nUnits, LPT2.nUnits) "Fraction of power provided per unit";
  parameter Modelica.Units.SI.Power LPT2.Q_units_start[LPT2.nUnits] = fill(
    LPT2.m_flow_start*(LPT2.h_a_start-LPT2.h_b_start)/LPT2.nUnits, LPT2.nUnits) 
    "Initial power output per unit";
  parameter Real LPT2.eta_mech = data.eta_mech "Mechanical efficiency";
  parameter Modelica.Units.SI.Efficiency LPT2.eta_wetSteam.eta_nominal = 
    data.eta_t "Nominal efficiency due to wetness";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure LPT2.p_a_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = data.LPT2_p_in 
    "Pressure at port a";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure LPT2.p_b_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = data.LPT2_p_out 
    "Pressure at port b";
  parameter Boolean LPT2.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Media.Interfaces.Types.Temperature LPT2.T_a_start(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) = 433.35 "Temperature at port a";
  parameter Modelica.Media.Interfaces.Types.Temperature LPT2.T_b_start(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) = 321.27 "Temperature at port b";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT2.h_a_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique1
    (LPT2.p_a_start, LPT2.T_a_start, LPT2.X_start, 0) "Specific enthalpy at port a";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT2.h_b_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.isentropicEnthalpy_Unique7
    (
    LPT2.p_b_start, 
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(LPT2.p_a_start, 
      LPT2.h_a_start, LPT2.X_start, 0, 0)) "Specific enthalpy at port b";
  parameter Modelica.Media.Interfaces.Types.MassFraction LPT2.X_start[1] = {1.0}
     "Mass fractions m_i/m";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty LPT2.C_start[0](
    start = fill(1.0, size(LPT2.C_start, 1))) = fill(0, 0) "Trace substances";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    LPT2.m_flow_start = data.mdot_lpt2 "Mass flow rate";
  constant Modelica.Units.SI.Pressure LPT2.p_crit = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
    .criticalPressure "Medium critical pressure";
  parameter Real LPT2.partialArc_nominal = 1 "Nominal partial arc";
  parameter Modelica.Units.SI.MassFlowRate LPT2.m_flow_nominal = data.mdot_lpt2 
    "Nominal mass flowrate";
  parameter Boolean LPT2.use_Stodola = true "=true to use Stodola's law, i.e., infinite stages per unit";
  parameter Modelica.Units.SI.Area LPT2.Kt_constant = 0.01 "Constant coefficient of Stodola's law";
  parameter Boolean LPT2.use_NominalInlet = true "=true then Kt is calculated from nominal inlet conditions";
  parameter Modelica.Units.SI.Pressure LPT2.p_inlet_nominal = data.LPT2_p_in 
    "Nominal inlet pressure";
  parameter Modelica.Units.SI.Pressure LPT2.p_outlet_nominal = data.LPT2_p_out 
    "Nominal outlet pressure";
  parameter Boolean LPT2.use_T_nominal = false "=true then use temperature for Kt else density";
  parameter Modelica.Units.SI.Temperature LPT2.T_nominal = 384.45 
    "Nominal inlet temperature";
  parameter Modelica.Units.SI.Density LPT2.d_nominal = data.d_LPT2_in 
    "Nominal inlet density";
  parameter Modelica.Units.SI.Area LPT2.Kt(fixed = false) "Flow area coefficient";
  constant Integer moistureSeperator.nPorts_a = 1 "Number of port_a connections";
  constant Integer moistureSeperator.nPorts_b = 1 "Number of port_b connections";
  parameter Modelica.Fluid.Types.Dynamics moistureSeperator.energyDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics moistureSeperator.massDynamics = 
    moistureSeperator.energyDynamics "Formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics moistureSeperator.substanceDynamics = 
    moistureSeperator.massDynamics "Formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics moistureSeperator.traceDynamics = 
    moistureSeperator.massDynamics "Formulation of trace substance balances";
  parameter Modelica.Units.SI.AbsolutePressure moistureSeperator.p_start = 
    data.LPT2_p_out-2 "Pressure";
  parameter Boolean moistureSeperator.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Units.SI.Temperature moistureSeperator.T_start = 443.15 
    "Temperature";
  parameter Modelica.Units.SI.SpecificEnthalpy moistureSeperator.h_start = 
    Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique1(
    moistureSeperator.p_start, moistureSeperator.T_start, moistureSeperator.X_start,
     0) "Specific enthalpy";
  parameter Modelica.Units.SI.MassFraction moistureSeperator.X_start[1] = {1.0} 
    "Mass fraction";
  parameter TRANSFORM.Units.ExtraProperty moistureSeperator.C_start[0] = fill(0,
     0) "Mass-Specific value";
  constant Boolean moistureSeperator.medium.preferredMediumStates = true 
    "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean moistureSeperator.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  parameter Boolean moistureSeperator.initialize_p = true "= true to set up initial equations for pressure";
  constant Boolean moistureSeperator.use_HeatPort = false "=true to toggle heat port";
  constant Boolean moistureSeperator.use_TraceMassPort = false "=true to toggle trace mass port";
  parameter Real moistureSeperator.MMs[0] = fill(1, 0) "Conversion from fluid mass-specific value to moles (e.g., molar mass [kg/mol] or Avogadro's number [atoms/mol])";
  parameter Boolean moistureSeperator.showName = true;
  parameter Boolean moistureSeperator.portMixed = false "=true to assume entering and exit streams mix before entering the volume";
  parameter Modelica.Fluid.Types.Dynamics LPT1_bypass.energyDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics LPT1_bypass.massDynamics = 
    LPT1_bypass.energyDynamics "Formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics LPT1_bypass.substanceDynamics = 
    LPT1_bypass.massDynamics "Formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics LPT1_bypass.traceDynamics = 
    LPT1_bypass.massDynamics "Formulation of trace substance balances";
  parameter Modelica.Units.SI.AbsolutePressure LPT1_bypass.p_start = 
    data.HPT_p_out "Pressure";
  parameter Boolean LPT1_bypass.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Units.SI.Temperature LPT1_bypass.T_start = 452.55 
    "Temperature";
  parameter Modelica.Units.SI.SpecificEnthalpy LPT1_bypass.h_start = 
    Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique1(
    LPT1_bypass.p_start, LPT1_bypass.T_start, LPT1_bypass.X_start, 0) 
    "Specific enthalpy";
  parameter Modelica.Units.SI.MassFraction LPT1_bypass.X_start[1] = {1.0} 
    "Mass fraction";
  parameter TRANSFORM.Units.ExtraProperty LPT1_bypass.C_start[0] = fill(0, 0) 
    "Mass-Specific value";
  constant Boolean LPT1_bypass.medium.preferredMediumStates = true 
    "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean LPT1_bypass.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  parameter Boolean LPT1_bypass.initialize_p = true "= true to set up initial equations for pressure";
  constant Boolean LPT1_bypass_valve.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean LPT1_bypass_valve.showDesignFlowDirection = true 
    "= false to hide the flow direction arrow";
  parameter Boolean LPT1_bypass_valve.showName = true "= false to hide component name";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure LPT1_bypass_valve.dp_start
    (start = 5000000.0, nominal = 1000000.0, min = -1E+60) = 1E-05 
    "Guess value of dp = port_a.p - port_b.p";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    LPT1_bypass_valve.m_flow_start = 0 "Guess value of m_flow = port_a.m_flow";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    LPT1_bypass_valve.m_flow_small = 0.01 "Small mass flow rate for regularization of zero flow";
  constant Boolean LPT1_bypass_valve.show_T = true "= true, if temperatures at port_a and port_b are computed";
  constant Boolean LPT1_bypass_valve.show_V_flow = true "= true, if volume flow rate at inflowing port is computed";
  parameter Modelica.Units.SI.AbsolutePressure LPT1_bypass_valve.dp_nominal = 100000
     "Nominal pressure drop at full opening";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    LPT1_bypass_valve.m_flow_nominal = 0 "Nominal mass flowrate at full opening";
  parameter Modelica.Fluid.Types.HydraulicConductance LPT1_bypass_valve.k = 
    LPT1_bypass_valve.m_flow_nominal/LPT1_bypass_valve.dp_nominal 
    "Hydraulic conductance at full opening";
  constant Boolean TBV.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean TBV.showDesignFlowDirection = true "= false to hide the flow direction arrow";
  parameter Boolean TBV.showName = true "= false to hide component name";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure TBV.dp_start(
    start = 5000000.0, nominal = 1000000.0, min = -1E+60) = 1E-05 
    "Guess value of dp = port_a.p - port_b.p";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    TBV.m_flow_start = 0 "Guess value of m_flow = port_a.m_flow";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    TBV.m_flow_small = 0.01 "Small mass flow rate for regularization of zero flow";
  constant Boolean TBV.show_T = true "= true, if temperatures at port_a and port_b are computed";
  constant Boolean TBV.show_V_flow = true "= true, if volume flow rate at inflowing port is computed";
  parameter Modelica.Units.SI.AbsolutePressure TBV.dp_nominal = 200000 
    "Nominal pressure drop at full opening";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    TBV.m_flow_nominal = 0 "Nominal mass flowrate at full opening";
  parameter Modelica.Fluid.Types.HydraulicConductance TBV.k = TBV.m_flow_nominal
    /TBV.dp_nominal "Hydraulic conductance at full opening";
  parameter Boolean condenser.showName = true;
  parameter Modelica.Units.SI.AbsolutePressure condenser.system.p_ambient = 101325
     "Default ambient pressure";
  parameter Modelica.Units.SI.Temperature condenser.system.T_ambient = 293.15 
    "Default ambient temperature";
  parameter Modelica.Units.SI.Acceleration condenser.system.g = 9.80665 
    "Constant gravity acceleration";
  parameter Boolean condenser.system.allowFlowReversal = true "= false to restrict to design flow direction (port_a -> port_b)";
  parameter Modelica.Fluid.Types.Dynamics condenser.system.energyDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics condenser.system.massDynamics = 
    condenser.system.energyDynamics "Default formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics condenser.system.substanceDynamics = 
    condenser.system.massDynamics "Default formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics condenser.system.traceDynamics = 
    condenser.system.massDynamics "Default formulation of trace substance balances";
  parameter Modelica.Fluid.Types.Dynamics condenser.system.momentumDynamics = 
    Modelica.Fluid.Types.Dynamics.SteadyState "Default formulation of momentum balances, if options available";
  parameter Modelica.Units.SI.MassFlowRate condenser.system.m_flow_start = 0 
    "Default start value for mass flow rates";
  parameter Modelica.Units.SI.AbsolutePressure condenser.system.p_start = 
    condenser.system.p_ambient "Default start value for pressures";
  parameter Modelica.Units.SI.Temperature condenser.system.T_start = 
    condenser.system.T_ambient "Default start value for temperatures";
  parameter Boolean condenser.system.use_eps_Re = false "= true to determine turbulent region automatically using Reynolds number";
  parameter Modelica.Units.SI.MassFlowRate condenser.system.m_flow_nominal = (
    if condenser.system.use_eps_Re then 1 else 100.0*condenser.system.m_flow_small)
     "Default nominal mass flow rate";
  parameter Real condenser.system.eps_m_flow(min = 0.0) = 0.0001 
    "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal";
  parameter Modelica.Units.SI.AbsolutePressure condenser.system.dp_small = 1 
    "Default small pressure drop for regularization of laminar and zero flow";
  parameter Modelica.Units.SI.MassFlowRate condenser.system.m_flow_small(min = 
    0.0) = 0.01 "Default small mass flow rate for regularization of laminar and zero flow";
  parameter Modelica.Units.SI.Pressure condenser.p = data.cond_p 
    "Condenser operating pressure";
  parameter Modelica.Units.SI.Volume condenser.V_total = 3500.0 "Total volume (liquid + vapor)";
  parameter Modelica.Fluid.Types.Dynamics condenser.massDynamics = 
    condenser.system.massDynamics "Formulation of mass balance";
  parameter Modelica.Units.SI.Volume condenser.V_liquid_start = 0.15*
    condenser.V_total "Start value of the liquid volume";
  parameter Boolean condenser.set_m_flow = false "=true to set port_b.m_flow = -port_a.m_flow";
  parameter Modelica.Units.SI.Efficiency generator.eta = 1.0 "Mechanical to electric power conversion efficiency";
  parameter Modelica.Units.SI.MomentOfInertia generator.J = 0 "Moment of inertia";
  parameter Integer generator.nPoles = 2 "Number of electrical poles";
  parameter Modelica.Units.SI.Frequency generator.f_start = 60 "Start value of the electrical frequency";
  parameter Modelica.Fluid.Types.Dynamics generator.momentumDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of momentum balances";
  parameter Real pump.nParallel = 1 "# of parallel components";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure pump.p_a_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = 101325 
    "Pressure at port a";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure pump.p_b_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = pump.p_a_start 
    "Pressure at port b";
  parameter Boolean pump.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Media.Interfaces.Types.Temperature pump.T_a_start(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) = 293.15 "Temperature at port a";
  parameter Modelica.Media.Interfaces.Types.Temperature pump.T_b_start(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) = pump.T_a_start 
    "Temperature at port b";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy pump.h_a_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique1
    (pump.p_a_start, pump.T_a_start, pump.X_start, 0) "Specific enthalpy at port a";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy pump.h_b_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.isentropicEnthalpy_Unique7
    (
    pump.p_b_start, 
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(pump.p_a_start, 
      pump.h_a_start, pump.X_start, 0, 0)) "Specific enthalpy at port b";
  parameter Modelica.Media.Interfaces.Types.MassFraction pump.X_start[1] = {1.0}
     "Mass fractions m_i/m";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty pump.C_start[0](
    start = fill(1.0, size(pump.C_start, 1))) = fill(0, 0) "Trace substances";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    pump.m_flow_start = 0 "Mass flow rate";
  constant Boolean pump.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  constant Boolean pump.use_input = false "Use connector input for outlet pressure";
  parameter Modelica.Units.SI.Pressure pump.p_nominal = data.p_i2 
    "Nominal outlet pressure (port_b.p)";
  parameter Real pump.eta = data.eta_p "Thermodynamic Efficiency of the pump";
  parameter Real pump1.nParallel = 1 "# of parallel components";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure pump1.p_a_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = 101325 
    "Pressure at port a";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure pump1.p_b_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = pump1.p_a_start 
    "Pressure at port b";
  parameter Boolean pump1.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Media.Interfaces.Types.Temperature pump1.T_a_start(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) = 293.15 "Temperature at port a";
  parameter Modelica.Media.Interfaces.Types.Temperature pump1.T_b_start(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) = pump1.T_a_start 
    "Temperature at port b";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy pump1.h_a_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique1
    (pump1.p_a_start, pump1.T_a_start, pump1.X_start, 0) "Specific enthalpy at port a";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy pump1.h_b_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.isentropicEnthalpy_Unique7
    (
    pump1.p_b_start, 
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(pump1.p_a_start, 
      pump1.h_a_start, pump1.X_start, 0, 0)) "Specific enthalpy at port b";
  parameter Modelica.Media.Interfaces.Types.MassFraction pump1.X_start[1] = {1.0}
     "Mass fractions m_i/m";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty pump1.C_start[0](
    start = fill(1.0, size(pump1.C_start, 1))) = fill(0, 0) "Trace substances";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    pump1.m_flow_start = 0 "Mass flow rate";
  constant Boolean pump1.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  constant Boolean pump1.use_input = false "Use connector input for outlet pressure";
  parameter Modelica.Units.SI.Pressure pump1.p_nominal = 2800000 
    "Nominal outlet pressure (port_b.p)";
  parameter Real pump1.eta = data.eta_p "Thermodynamic Efficiency of the pump";
  parameter Modelica.Fluid.Types.Dynamics OFWH_1.energyDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics OFWH_1.massDynamics = OFWH_1.energyDynamics
     "Formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics OFWH_1.substanceDynamics = 
    OFWH_1.massDynamics "Formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics OFWH_1.traceDynamics = 
    OFWH_1.massDynamics "Formulation of trace substance balances";
  parameter Modelica.Units.SI.AbsolutePressure OFWH_1.p_start = data.LPT2_p_in 
    "Pressure";
  parameter Boolean OFWH_1.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Units.SI.Temperature OFWH_1.T_start = 333.15 "Temperature";
  parameter Modelica.Units.SI.SpecificEnthalpy OFWH_1.h_start = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique1
    (OFWH_1.p_start, OFWH_1.T_start, OFWH_1.X_start, 0) "Specific enthalpy";
  parameter Modelica.Units.SI.MassFraction OFWH_1.X_start[1] = {1.0} 
    "Mass fraction";
  parameter TRANSFORM.Units.ExtraProperty OFWH_1.C_start[0] = fill(0, 0) 
    "Mass-Specific value";
  constant Boolean OFWH_1.medium.preferredMediumStates = true "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean OFWH_1.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  parameter Boolean OFWH_1.initialize_p = true "= true to set up initial equations for pressure";
  constant Boolean OFWH_1.use_HeatPort = false "=true to toggle heat port";
  constant Boolean OFWH_1.use_TraceMassPort = false "=true to toggle trace mass port";
  parameter Real OFWH_1.MMs[0] = fill(1, 0) "Conversion from fluid mass-specific value to moles (e.g., molar mass [kg/mol] or Avogadro's number [atoms/mol])";
  parameter Boolean OFWH_1.showName = true;
  constant Boolean HPT_bypass_valve.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean HPT_bypass_valve.showDesignFlowDirection = true 
    "= false to hide the flow direction arrow";
  parameter Boolean HPT_bypass_valve.showName = true "= false to hide component name";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure HPT_bypass_valve.dp_start
    (start = 5000000.0, nominal = 1000000.0, min = -1E+60) = 1E-05 
    "Guess value of dp = port_a.p - port_b.p";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    HPT_bypass_valve.m_flow_start = data.mdot_fh "Guess value of m_flow = port_a.m_flow";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    HPT_bypass_valve.m_flow_small = 0.01 "Small mass flow rate for regularization of zero flow";
  constant Boolean HPT_bypass_valve.show_T = true "= true, if temperatures at port_a and port_b are computed";
  constant Boolean HPT_bypass_valve.show_V_flow = true "= true, if volume flow rate at inflowing port is computed";
  parameter Modelica.Units.SI.AbsolutePressure HPT_bypass_valve.dp_nominal = 50000
     "Nominal pressure drop at full opening";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    HPT_bypass_valve.m_flow_nominal = data.mdot_fh*1.5 "Nominal mass flowrate at full opening";
  parameter Modelica.Fluid.Types.HydraulicConductance HPT_bypass_valve.k = 
    HPT_bypass_valve.m_flow_nominal/HPT_bypass_valve.dp_nominal "Hydraulic conductance at full opening";
  parameter Modelica.Fluid.Types.Dynamics OFWH_2.energyDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics OFWH_2.massDynamics = OFWH_2.energyDynamics
     "Formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics OFWH_2.substanceDynamics = 
    OFWH_2.massDynamics "Formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics OFWH_2.traceDynamics = 
    OFWH_2.massDynamics "Formulation of trace substance balances";
  parameter Modelica.Units.SI.AbsolutePressure OFWH_2.p_start = data.HPT_p_in-
    50000.0 "Pressure";
  parameter Boolean OFWH_2.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Units.SI.Temperature OFWH_2.T_start = data.Tfeed 
    "Temperature";
  parameter Modelica.Units.SI.SpecificEnthalpy OFWH_2.h_start = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique1
    (OFWH_2.p_start, OFWH_2.T_start, OFWH_2.X_start, 0) "Specific enthalpy";
  parameter Modelica.Units.SI.MassFraction OFWH_2.X_start[1] = {1.0} 
    "Mass fraction";
  parameter TRANSFORM.Units.ExtraProperty OFWH_2.C_start[0] = fill(0, 0) 
    "Mass-Specific value";
  constant Boolean OFWH_2.medium.preferredMediumStates = true "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean OFWH_2.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  parameter Boolean OFWH_2.initialize_p = true "= true to set up initial equations for pressure";
  constant Boolean OFWH_2.use_HeatPort = false "=true to toggle heat port";
  constant Boolean OFWH_2.use_TraceMassPort = false "=true to toggle trace mass port";
  parameter Real OFWH_2.MMs[0] = fill(1, 0) "Conversion from fluid mass-specific value to moles (e.g., molar mass [kg/mol] or Avogadro's number [atoms/mol])";
  parameter Boolean OFWH_2.showName = true;
  parameter Real FWCP.nParallel = 1 "# of parallel components";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure FWCP.p_a_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = 101325 
    "Pressure at port a";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure FWCP.p_b_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = FWCP.p_a_start 
    "Pressure at port b";
  parameter Boolean FWCP.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Media.Interfaces.Types.Temperature FWCP.T_a_start(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) = 293.15 "Temperature at port a";
  parameter Modelica.Media.Interfaces.Types.Temperature FWCP.T_b_start(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) = FWCP.T_a_start 
    "Temperature at port b";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy FWCP.h_a_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique1
    (FWCP.p_a_start, FWCP.T_a_start, FWCP.X_start, 0) "Specific enthalpy at port a";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy FWCP.h_b_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.isentropicEnthalpy_Unique7
    (
    FWCP.p_b_start, 
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(FWCP.p_a_start, 
      FWCP.h_a_start, FWCP.X_start, 0, 0)) "Specific enthalpy at port b";
  parameter Modelica.Media.Interfaces.Types.MassFraction FWCP.X_start[1] = {1.0}
     "Mass fractions m_i/m";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty FWCP.C_start[0](
    start = fill(1.0, size(FWCP.C_start, 1))) = fill(0, 0) "Trace substances";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    FWCP.m_flow_start = 0 "Mass flow rate";
  constant Boolean FWCP.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  constant Boolean FWCP.use_input = false "Use connector input for the mass flow";
  parameter Modelica.Units.SI.MassFlowRate FWCP.m_flow_nominal = data.mdot_hpt 
    "Nominal mass flowrate";
  parameter Real FWCP.eta = data.eta_p "Thermodynamic Efficiency of the pump";
  constant Boolean TCV.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean TCV.showDesignFlowDirection = true "= false to hide the flow direction arrow";
  parameter Boolean TCV.showName = true "= false to hide component name";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure TCV.dp_start(
    start = 5000000.0, nominal = 1000000.0, min = -1E+60) = 1E-05 
    "Guess value of dp = port_a.p - port_b.p";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    TCV.m_flow_start = data.mdot_total "Guess value of m_flow = port_a.m_flow";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    TCV.m_flow_small = 0.01 "Small mass flow rate for regularization of zero flow";
  constant Boolean TCV.show_T = true "= true, if temperatures at port_a and port_b are computed";
  constant Boolean TCV.show_V_flow = true "= true, if volume flow rate at inflowing port is computed";
  parameter Modelica.Units.SI.AbsolutePressure TCV.dp_nominal = 1 
    "Nominal pressure drop at full opening";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    TCV.m_flow_nominal = data.mdot_total "Nominal mass flowrate at full opening";
  parameter Modelica.Fluid.Types.HydraulicConductance TCV.k = TCV.m_flow_nominal
    /TCV.dp_nominal "Hydraulic conductance at full opening";
  constant Boolean Feed_T.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean Feed_T.showName = true "= false to hide component name";
  parameter Integer Feed_T.precision(min = 0.0) = 0 "Number of decimals displayed";
  constant Boolean Steam_T.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean Steam_T.showName = true "= false to hide component name";
  parameter Integer Steam_T.precision(min = 0.0) = 0 "Number of decimals displayed";
  constant Boolean sensor_p.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean sensor_p.showName = true "= false to hide component name";
  parameter Integer sensor_p.precision(min = 0.0) = 0 "Number of decimals displayed";
  parameter Integer sensorW.precision(min = 0.0) = 0 "Number of decimals displayed";
  constant Boolean delay2.sensor_p.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean delay2.sensor_p.showName = true "= false to hide component name";
  parameter Integer delay2.sensor_p.precision(min = 0.0) = 0 "Number of decimals displayed";
  constant Boolean delay2.sensor_m_flow.allowFlowReversal = true 
    "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean delay2.sensor_m_flow.showName = true "= false to hide component name";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    delay2.sensor_m_flow.m_flow_small(min = 0.0) = 0.0001 "Regularization for zero flow:|m_flow| < m_flow_small";
  parameter Modelica.Units.SI.AbsolutePressure delay2.sensor_m_flow.p_start = 101325
     "Pressure";
  parameter Boolean delay2.sensor_m_flow.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Units.SI.Temperature delay2.sensor_m_flow.T_start = 293.15 
    "Temperature";
  parameter Modelica.Units.SI.SpecificEnthalpy delay2.sensor_m_flow.h_start = 
    Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique1(
    delay2.sensor_m_flow.p_start, delay2.sensor_m_flow.T_start, delay2.sensor_m_flow.X_start,
     0) "Specific enthalpy";
  parameter Modelica.Units.SI.MassFraction delay2.sensor_m_flow.X_start[1] = {
    1.0} "Mass fraction";
  parameter Integer delay2.sensor_m_flow.precision(min = 0.0) = 0 
    "Number of decimals displayed";
  constant Boolean delay2.sensor_h.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean delay2.sensor_h.showName = true "= false to hide component name";
  parameter Integer delay2.sensor_h.precision(min = 0.0) = 0 "Number of decimals displayed";
  parameter Boolean delay2.boundary.showName = true;
  constant Integer delay2.boundary.nPorts = 1 "Number of ports";
  constant Boolean delay2.boundary.medium.preferredMediumStates = false 
    "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean delay2.boundary.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  constant Modelica.Fluid.Types.PortFlowDirection delay2.boundary.flowDirection
     = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction";
  constant Boolean delay2.boundary.use_p_in = true "Get the pressure from the input connector";
  constant Boolean delay2.boundary.use_h_in = false "Get the specific enthalpy from the input connector";
  constant Boolean delay2.boundary.use_X_in = false "Get the composition from the input connector";
  constant Boolean delay2.boundary.use_C_in = false "Get the trace substances from the input connector";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure delay2.boundary.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = 101325 
    "Fixed value of pressure";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2.boundary.h(
    start = 100000.0, nominal = 500000.0) = 84013.0581525969 "Fixed value of specific enthalpy";
  parameter Modelica.Media.Interfaces.Types.MassFraction delay2.boundary.X[1] = 
    {1.0} "Fixed value of composition";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty delay2.boundary.C[0](
    start = fill(1.0, size(delay2.boundary.C, 1))) = fill(0, 0) "Fixed values of trace substances";
  parameter Boolean delay2.boundary1.showName = true;
  constant Integer delay2.boundary1.nPorts = 1 "Number of ports";
  constant Boolean delay2.boundary1.medium.preferredMediumStates = false 
    "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean delay2.boundary1.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  constant Modelica.Fluid.Types.PortFlowDirection delay2.boundary1.flowDirection
     = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction";
  constant Boolean delay2.boundary1.use_m_flow_in = true "Get the mass flow rate from the input connector";
  constant Boolean delay2.boundary1.use_h_in = true "Get the specific enthalpy from the input connector";
  constant Boolean delay2.boundary1.use_X_in = false "Get the composition from the input connector";
  constant Boolean delay2.boundary1.use_C_in = false "Get the trace substances from the input connector";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    delay2.boundary1.m_flow = 0 "Fixed mass flow rate going out of the fluid port";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2.boundary1.h(
    start = 100000.0, nominal = 500000.0) = 84013.0581525969 "Fixed value of specific enthalpy";
  parameter Modelica.Media.Interfaces.Types.MassFraction delay2.boundary1.X[1]
     = {1.0} "Fixed value of composition";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty delay2.boundary1.C[0](
    start = fill(1.0, size(delay2.boundary1.C, 1))) = fill(0, 0) 
    "Fixed values of trace substances";
  parameter Real delay2.limiter1.uMax(start = 1) = 1E+60 "Upper limits of input signals";
  parameter Real delay2.limiter1.uMin =  -delay2.limiter1.uMax "Lower limits of input signals";
  parameter Boolean delay2.limiter1.strict = false "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy delay2.limiter1.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Real delay2.limiter2.uMax(start = 1) = 1E+60 "Upper limits of input signals";
  parameter Real delay2.limiter2.uMin =  -delay2.limiter2.uMax "Lower limits of input signals";
  parameter Boolean delay2.limiter2.strict = false "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy delay2.limiter2.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Real delay2.limiter.uMax(start = 1) = 1E+60 "Upper limits of input signals";
  parameter Real delay2.limiter.uMin =  -delay2.limiter.uMax "Lower limits of input signals";
  parameter Boolean delay2.limiter.strict = false "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy delay2.limiter.homotopyType = 
    Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  constant Boolean delay2_2.sensor_p.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean delay2_2.sensor_p.showName = true "= false to hide component name";
  parameter Integer delay2_2.sensor_p.precision(min = 0.0) = 0 "Number of decimals displayed";
  constant Boolean delay2_2.sensor_m_flow.allowFlowReversal = true 
    "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean delay2_2.sensor_m_flow.showName = true "= false to hide component name";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    delay2_2.sensor_m_flow.m_flow_small(min = 0.0) = 0.0001 "Regularization for zero flow:|m_flow| < m_flow_small";
  parameter Modelica.Units.SI.AbsolutePressure delay2_2.sensor_m_flow.p_start = 101325
     "Pressure";
  parameter Boolean delay2_2.sensor_m_flow.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Units.SI.Temperature delay2_2.sensor_m_flow.T_start = 
    293.15 "Temperature";
  parameter Modelica.Units.SI.SpecificEnthalpy delay2_2.sensor_m_flow.h_start = 
    Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique1(
    delay2_2.sensor_m_flow.p_start, delay2_2.sensor_m_flow.T_start, 
    delay2_2.sensor_m_flow.X_start, 0) "Specific enthalpy";
  parameter Modelica.Units.SI.MassFraction delay2_2.sensor_m_flow.X_start[1] = {
    1.0} "Mass fraction";
  parameter Integer delay2_2.sensor_m_flow.precision(min = 0.0) = 0 
    "Number of decimals displayed";
  constant Boolean delay2_2.sensor_h.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean delay2_2.sensor_h.showName = true "= false to hide component name";
  parameter Integer delay2_2.sensor_h.precision(min = 0.0) = 0 "Number of decimals displayed";
  parameter Boolean delay2_2.boundary.showName = true;
  constant Integer delay2_2.boundary.nPorts = 1 "Number of ports";
  constant Boolean delay2_2.boundary.medium.preferredMediumStates = false 
    "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean delay2_2.boundary.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  constant Modelica.Fluid.Types.PortFlowDirection delay2_2.boundary.flowDirection
     = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction";
  constant Boolean delay2_2.boundary.use_p_in = true "Get the pressure from the input connector";
  constant Boolean delay2_2.boundary.use_h_in = false "Get the specific enthalpy from the input connector";
  constant Boolean delay2_2.boundary.use_X_in = false "Get the composition from the input connector";
  constant Boolean delay2_2.boundary.use_C_in = false "Get the trace substances from the input connector";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure delay2_2.boundary.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) = 101325 
    "Fixed value of pressure";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2_2.boundary.h
    (start = 100000.0, nominal = 500000.0) = 84013.0581525969 "Fixed value of specific enthalpy";
  parameter Modelica.Media.Interfaces.Types.MassFraction delay2_2.boundary.X[1]
     = {1.0} "Fixed value of composition";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty delay2_2.boundary.C[0]
    (start = fill(1.0, size(delay2_2.boundary.C, 1))) = fill(0, 0) 
    "Fixed values of trace substances";
  parameter Boolean delay2_2.boundary1.showName = true;
  constant Integer delay2_2.boundary1.nPorts = 1 "Number of ports";
  constant Boolean delay2_2.boundary1.medium.preferredMediumStates = false 
    "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean delay2_2.boundary1.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  constant Modelica.Fluid.Types.PortFlowDirection delay2_2.boundary1.flowDirection
     = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction";
  constant Boolean delay2_2.boundary1.use_m_flow_in = true "Get the mass flow rate from the input connector";
  constant Boolean delay2_2.boundary1.use_h_in = true "Get the specific enthalpy from the input connector";
  constant Boolean delay2_2.boundary1.use_X_in = false "Get the composition from the input connector";
  constant Boolean delay2_2.boundary1.use_C_in = false "Get the trace substances from the input connector";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    delay2_2.boundary1.m_flow = 0 "Fixed mass flow rate going out of the fluid port";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2_2.boundary1.h
    (start = 100000.0, nominal = 500000.0) = 84013.0581525969 "Fixed value of specific enthalpy";
  parameter Modelica.Media.Interfaces.Types.MassFraction delay2_2.boundary1.X[1]
     = {1.0} "Fixed value of composition";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty delay2_2.boundary1.C[0]
    (start = fill(1.0, size(delay2_2.boundary1.C, 1))) = fill(0, 0) 
    "Fixed values of trace substances";
  parameter Real delay2_2.limiter1.uMax(start = 1) = 1E+60 "Upper limits of input signals";
  parameter Real delay2_2.limiter1.uMin =  -delay2_2.limiter1.uMax 
    "Lower limits of input signals";
  parameter Boolean delay2_2.limiter1.strict = false "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy delay2_2.limiter1.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Real delay2_2.limiter2.uMax(start = 1) = 1E+60 "Upper limits of input signals";
  parameter Real delay2_2.limiter2.uMin =  -delay2_2.limiter2.uMax 
    "Lower limits of input signals";
  parameter Boolean delay2_2.limiter2.strict = false "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy delay2_2.limiter2.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Real delay2_2.limiter.uMax(start = 1) = 1E+60 "Upper limits of input signals";
  parameter Real delay2_2.limiter.uMin =  -delay2_2.limiter.uMax 
    "Lower limits of input signals";
  parameter Boolean delay2_2.limiter.strict = false "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy delay2_2.limiter.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  constant Boolean sensor_m_flow.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean sensor_m_flow.showName = true "= false to hide component name";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    sensor_m_flow.m_flow_small(min = 0.0) = 0.0001 "Regularization for zero flow:|m_flow| < m_flow_small";
  parameter Modelica.Units.SI.AbsolutePressure sensor_m_flow.p_start = 101325 
    "Pressure";
  parameter Boolean sensor_m_flow.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Units.SI.Temperature sensor_m_flow.T_start = 293.15 
    "Temperature";
  parameter Modelica.Units.SI.SpecificEnthalpy sensor_m_flow.h_start = 
    Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique1(
    sensor_m_flow.p_start, sensor_m_flow.T_start, sensor_m_flow.X_start, 0) 
    "Specific enthalpy";
  parameter Modelica.Units.SI.MassFraction sensor_m_flow.X_start[1] = {1.0} 
    "Mass fraction";
  parameter Integer sensor_m_flow.precision(min = 0.0) = 0 "Number of decimals displayed";
  constant Boolean sensor_p1.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean sensor_p1.showName = true "= false to hide component name";
  parameter Integer sensor_p1.precision(min = 0.0) = 0 "Number of decimals displayed";
  parameter Modelica.Units.SI.Time booleanStep1.startTime = 10000000.0 
    "Time instant of step start";
  parameter Boolean booleanStep1.startValue = true "Output before startTime";
  constant String _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].iupacName
     "Complete IUPAC name (or common name, if non-existent)";
  constant String _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].casRegistryNumber
     "Chemical abstracts sequencing number (if it exists)";
  constant String _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].chemicalFormula
     "Chemical formula, (brutto, nomenclature according to Hill";
  constant String _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].structureFormula
     "Chemical structure formula";
  constant Modelica.Media.Interfaces.Types.MolarMass _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].molarMass
     "Molar mass";
  constant Modelica.Media.Interfaces.Types.Temperature _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].criticalTemperature
     = 288.15 "Critical temperature";
  constant Modelica.Media.Interfaces.Types.AbsolutePressure _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].criticalPressure
     = 100000.0 "Critical pressure";
  constant Modelica.Media.Interfaces.Types.MolarVolume _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].criticalMolarVolume
     "Critical molar Volume";
  constant Real _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].acentricFactor
     "Pitzer acentric factor";
  constant Modelica.Media.Interfaces.Types.Temperature _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].triplePointTemperature
     = 288.15 "Triple point temperature";
  constant Modelica.Media.Interfaces.Types.AbsolutePressure _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].triplePointPressure
     = 100000.0 "Triple point pressure";
  constant Modelica.Media.Interfaces.Types.Temperature _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].meltingPoint
     = 288.15 "Melting point at 101325 Pa";
  constant Modelica.Media.Interfaces.Types.Temperature _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].normalBoilingPoint
     = 288.15 "Normal boiling point (at 101325 Pa)";
  constant Modelica.Media.Interfaces.Types.DipoleMoment _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].dipoleMoment
     "Dipole moment of molecule in Debye (1 debye = 3.33564e10-30 C.m)";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasIdealGasHeatCapacity
     "True if ideal gas heat capacity is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasCriticalData
     "True if critical data are known";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasDipoleMoment
     "True if a dipole moment known";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasFundamentalEquation
     "True if a fundamental equation";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasLiquidHeatCapacity
     "True if liquid heat capacity is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasSolidHeatCapacity
     "True if solid heat capacity is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasAccurateViscosityData
     "True if accurate data for a viscosity function is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasAccurateConductivityData
     "True if accurate data for thermal conductivity is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasVapourPressureCurve
     "True if vapour pressure data, e.g., Antoine coefficients are known";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasAcentricFactor
     "True if Pitzer acentric factor is known";
  constant Modelica.Media.Interfaces.Types.SpecificEnthalpy _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].HCRIT0
     "Critical specific enthalpy of the fundamental equation";
  constant Modelica.Media.Interfaces.Types.SpecificEntropy _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].SCRIT0
     "Critical specific entropy of the fundamental equation";
  constant Modelica.Media.Interfaces.Types.SpecificEnthalpy _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].deltah
     "Difference between specific enthalpy model (h_m) and f.eq. (h_f) (h_m - h_f)";
  constant Modelica.Media.Interfaces.Types.SpecificEntropy _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].deltas
     "Difference between specific enthalpy model (s_m) and f.eq. (s_f) (s_m - s_f)";
  constant String _GlobalScope.Modelica.Media.Water.waterConstants[1].iupacName
     = "oxidane" "Complete IUPAC name (or common name, if non-existent)";
  constant String _GlobalScope.Modelica.Media.Water.waterConstants[1].casRegistryNumber
     = "7732-18-5" "Chemical abstracts sequencing number (if it exists)";
  constant String _GlobalScope.Modelica.Media.Water.waterConstants[1].chemicalFormula
     = "H2O" "Chemical formula, (brutto, nomenclature according to Hill";
  constant String _GlobalScope.Modelica.Media.Water.waterConstants[1].structureFormula
     = "H2O" "Chemical structure formula";
  constant Modelica.Media.Interfaces.Types.MolarMass _GlobalScope.Modelica.Media.Water.waterConstants[1].molarMass
     = 0.018015268 "Molar mass";
  constant Modelica.Media.Interfaces.Types.Temperature _GlobalScope.Modelica.Media.Water.waterConstants[1].criticalTemperature
     = 647.096 "Critical temperature";
  constant Modelica.Media.Interfaces.Types.AbsolutePressure _GlobalScope.Modelica.Media.Water.waterConstants[1].criticalPressure
     = 22064000.0 "Critical pressure";
  constant Modelica.Media.Interfaces.Types.MolarVolume _GlobalScope.Modelica.Media.Water.waterConstants[1].criticalMolarVolume
     = 5.5948037267080745E-05 "Critical molar Volume";
  constant Real _GlobalScope.Modelica.Media.Water.waterConstants[1].acentricFactor
     = 0.344 "Pitzer acentric factor";
  constant Modelica.Media.Interfaces.Types.Temperature _GlobalScope.Modelica.Media.Water.waterConstants[1].triplePointTemperature
     = 273.16 "Triple point temperature";
  constant Modelica.Media.Interfaces.Types.AbsolutePressure _GlobalScope.Modelica.Media.Water.waterConstants[1].triplePointPressure
     = 611.657 "Triple point pressure";
  constant Modelica.Media.Interfaces.Types.Temperature _GlobalScope.Modelica.Media.Water.waterConstants[1].meltingPoint
     = 273.15 "Melting point at 101325 Pa";
  constant Modelica.Media.Interfaces.Types.Temperature _GlobalScope.Modelica.Media.Water.waterConstants[1].normalBoilingPoint
     = 373.124 "Normal boiling point (at 101325 Pa)";
  constant Modelica.Media.Interfaces.Types.DipoleMoment _GlobalScope.Modelica.Media.Water.waterConstants[1].dipoleMoment
     = 1.8 "Dipole moment of molecule in Debye (1 debye = 3.33564e10-30 C.m)";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasIdealGasHeatCapacity
     = false "True if ideal gas heat capacity is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasCriticalData
     = true "True if critical data are known";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasDipoleMoment
     = false "True if a dipole moment known";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasFundamentalEquation
     = false "True if a fundamental equation";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasLiquidHeatCapacity
     = false "True if liquid heat capacity is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasSolidHeatCapacity
     = false "True if solid heat capacity is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasAccurateViscosityData
     = false "True if accurate data for a viscosity function is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasAccurateConductivityData
     = false "True if accurate data for thermal conductivity is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasVapourPressureCurve
     = false "True if vapour pressure data, e.g., Antoine coefficients are known";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasAcentricFactor
     = false "True if Pitzer acentric factor is known";
  constant Modelica.Media.Interfaces.Types.SpecificEnthalpy _GlobalScope.Modelica.Media.Water.waterConstants[1].HCRIT0
     = 0.0 "Critical specific enthalpy of the fundamental equation";
  constant Modelica.Media.Interfaces.Types.SpecificEntropy _GlobalScope.Modelica.Media.Water.waterConstants[1].SCRIT0
     = 0.0 "Critical specific entropy of the fundamental equation";
  constant Modelica.Media.Interfaces.Types.SpecificEnthalpy _GlobalScope.Modelica.Media.Water.waterConstants[1].deltah
     = 0.0 "Difference between specific enthalpy model (h_m) and f.eq. (h_f) (h_m - h_f)";
  constant Modelica.Media.Interfaces.Types.SpecificEntropy _GlobalScope.Modelica.Media.Water.waterConstants[1].deltas
     = 0.0 "Difference between specific enthalpy model (s_m) and f.eq. (s_f) (s_m - s_f)";

  Real CS.actuatorBus.opening_TCV "TCV fraction open";
  Real CS.actuatorBus.opening_TDV "TDV fraction open";
  Real CS.actuatorBus.opening_BV "BV fraction open";
  Real CS.actuatorBus.opening_BV_TCV "BV for TCV fraction open";
  Modelica.Blocks.Interfaces.RealOutput CS.actuatorBus.Feed_Pump_Speed 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput CS.actuatorBus.LPT2_BV "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput CS.actuatorBus.LPT1_BV "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput CS.actuatorBus.TBV "Connector of Real output signal";
  Modelica.Units.SI.Power CS.sensorBus.Q_balance "Heat loss (negative)/gain (positive) not accounted for in connections (e.g., energy vented to atmosphere)";
  Modelica.Units.SI.Power CS.sensorBus.W_balance "Electricity loss (negative)/gain (positive) not accounted for in connections (e.g., heating/cooling, pumps, etc.)";
  Modelica.Units.SI.Power CS.sensorBus.W_total "Total electrical power generated";
  Modelica.Units.SI.Power CS.sensorBus.W_totalSetpoint "Total electrical power setpoint";
  Modelica.Units.SI.Pressure CS.sensorBus.p_inlet_steamTurbine "Inlet pressure to steam turbine";
  Modelica.Blocks.Interfaces.RealInput CS.sensorBus.Steam_Pressure 
    "Connector of measurement input signal";
  Modelica.Blocks.Interfaces.RealInput CS.sensorBus.Steam_Temperature 
    "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.RealInput CS.sensorBus.Feedwater_Temp 
    "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.RealInput CS.sensorBus.Extract_flow 
    "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.T_in_set.y = CS.data.Tin 
    "Value of Real output";
  Modelica.Blocks.Interfaces.RealOutput CS.T_feed_set.y = CS.data.Tfeed 
    "Value of Real output";
  Modelica.Blocks.Interfaces.RealOutput CS.P_in_set.y = CS.data.HPT_p_in 
    "Value of Real output";
  Modelica.Blocks.Interfaces.RealOutput CS.Steam_Extraction.y = 0.0 
    "Value of Real output";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.u_s "Connector of setpoint input signal";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.u_m "Connector of measurement input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.FeedPump_PID.y "Connector of actuator output signal";
  Real CS.FeedPump_PID.controlError = CS.FeedPump_PID.u_s-CS.FeedPump_PID.u_m 
    "Control error (set point - measurement)";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.addP.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.addP.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput CS.FeedPump_PID.addP.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.P.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.FeedPump_PID.P.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.gainPID.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.FeedPump_PID.gainPID.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.addPID.u1 
    "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.addPID.u2 
    "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.addPID.u3 
    "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput CS.FeedPump_PID.addPID.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.limiter.u(start = 
    CS.FeedPump_PID.y_start) "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.FeedPump_PID.limiter.y 
    "Connector of Real output signal";
  Real CS.FeedPump_PID.limiter.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealOutput CS.FeedPump_PID.Fzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.addFF.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.addFF.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.addFF.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput CS.FeedPump_PID.addFF.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.gain_u_s.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.FeedPump_PID.gain_u_s.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.gain_u_m.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.FeedPump_PID.gain_u_m.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.FeedPump_PID.null_bias.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.y_reset_internal 
    "Internal connector for controller output reset";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.I.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.FeedPump_PID.I.y(start = 
    CS.FeedPump_PID.I.y_start) "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.I.y_reset_internal 
    "Internal connector for integrator reset";
  Modelica.Blocks.Interfaces.BooleanInput CS.FeedPump_PID.I.trigger_internal 
    "Needed to use conditional connector trigger";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.addI.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.addI.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.addI.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput CS.FeedPump_PID.addI.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.addSat.u1 
    "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.addSat.u2 
    "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput CS.FeedPump_PID.addSat.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.FeedPump_PID.gainTrack.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.FeedPump_PID.gainTrack.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.FeedPump_PID.Dzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.u_s "Connector of setpoint input signal";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.u_m "Connector of measurement input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.TCV_PID.y "Connector of actuator output signal";
  Real CS.TCV_PID.controlError = CS.TCV_PID.u_s-CS.TCV_PID.u_m "Control error (set point - measurement)";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.addP.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.addP.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput CS.TCV_PID.addP.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.P.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.TCV_PID.P.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.gainPID.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.TCV_PID.gainPID.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.addPID.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.addPID.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.addPID.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput CS.TCV_PID.addPID.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.limiter.u(start = 
    CS.TCV_PID.y_start) "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.TCV_PID.limiter.y "Connector of Real output signal";
  Real CS.TCV_PID.limiter.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealOutput CS.TCV_PID.Fzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.addFF.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.addFF.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.addFF.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput CS.TCV_PID.addFF.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.gain_u_s.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.TCV_PID.gain_u_s.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.gain_u_m.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.TCV_PID.gain_u_m.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.TCV_PID.null_bias.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.y_reset_internal 
    "Internal connector for controller output reset";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.I.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.TCV_PID.I.y(start = CS.TCV_PID.I.y_start)
     "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.I.y_reset_internal 
    "Internal connector for integrator reset";
  Modelica.Blocks.Interfaces.BooleanInput CS.TCV_PID.I.trigger_internal 
    "Needed to use conditional connector trigger";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.addI.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.addI.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.addI.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput CS.TCV_PID.addI.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.addSat.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.addSat.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput CS.TCV_PID.addSat.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.TCV_PID.gainTrack.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.TCV_PID.gainTrack.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.TCV_PID.Dzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.u_s "Connector of setpoint input signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.u_m "Connector of measurement input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT1_BV_PID.y "Connector of actuator output signal";
  Real CS.LPT1_BV_PID.controlError = CS.LPT1_BV_PID.u_s-CS.LPT1_BV_PID.u_m 
    "Control error (set point - measurement)";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.addP.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.addP.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT1_BV_PID.addP.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.P.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT1_BV_PID.P.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.gainPID.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT1_BV_PID.gainPID.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.addPID.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.addPID.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.addPID.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT1_BV_PID.addPID.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.limiter.u(start = 
    CS.LPT1_BV_PID.y_start) "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT1_BV_PID.limiter.y 
    "Connector of Real output signal";
  Real CS.LPT1_BV_PID.limiter.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT1_BV_PID.Fzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.addFF.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.addFF.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.addFF.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT1_BV_PID.addFF.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.gain_u_s.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT1_BV_PID.gain_u_s.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.gain_u_m.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT1_BV_PID.gain_u_m.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT1_BV_PID.null_bias.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.y_reset_internal 
    "Internal connector for controller output reset";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.I.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT1_BV_PID.I.y(start = 
    CS.LPT1_BV_PID.I.y_start) "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.I.y_reset_internal 
    "Internal connector for integrator reset";
  Modelica.Blocks.Interfaces.BooleanInput CS.LPT1_BV_PID.I.trigger_internal 
    "Needed to use conditional connector trigger";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.addI.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.addI.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.addI.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT1_BV_PID.addI.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.addSat.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.addSat.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT1_BV_PID.addSat.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT1_BV_PID.gainTrack.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT1_BV_PID.gainTrack.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT1_BV_PID.Dzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.u_s "Connector of setpoint input signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.u_m "Connector of measurement input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT2_BV_PID.y "Connector of actuator output signal";
  Real CS.LPT2_BV_PID.controlError = CS.LPT2_BV_PID.u_s-CS.LPT2_BV_PID.u_m 
    "Control error (set point - measurement)";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.addP.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.addP.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT2_BV_PID.addP.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.P.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT2_BV_PID.P.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.gainPID.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT2_BV_PID.gainPID.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.addPID.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.addPID.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.addPID.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT2_BV_PID.addPID.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.limiter.u(start = 
    CS.LPT2_BV_PID.y_start) "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT2_BV_PID.limiter.y 
    "Connector of Real output signal";
  Real CS.LPT2_BV_PID.limiter.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT2_BV_PID.Fzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.addFF.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.addFF.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.addFF.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT2_BV_PID.addFF.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.gain_u_s.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT2_BV_PID.gain_u_s.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.gain_u_m.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT2_BV_PID.gain_u_m.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT2_BV_PID.null_bias.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.y_reset_internal 
    "Internal connector for controller output reset";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.I.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT2_BV_PID.I.y(start = 
    CS.LPT2_BV_PID.I.y_start) "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.I.y_reset_internal 
    "Internal connector for integrator reset";
  Modelica.Blocks.Interfaces.BooleanInput CS.LPT2_BV_PID.I.trigger_internal 
    "Needed to use conditional connector trigger";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.addI.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.addI.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.addI.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT2_BV_PID.addI.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.addSat.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.addSat.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT2_BV_PID.addSat.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.LPT2_BV_PID.gainTrack.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT2_BV_PID.gainTrack.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealOutput CS.LPT2_BV_PID.Dzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.hysteresis.u;
  Modelica.Blocks.Interfaces.BooleanOutput CS.hysteresis.y;
  Modelica.Blocks.Interfaces.RealInput CS.switch1.u1 "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.BooleanInput CS.switch1.u2 "Connector of Boolean input signal";
  Modelica.Blocks.Interfaces.RealInput CS.switch1.u3 "Connector of second Real input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.switch1.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput CS.P_dump_open0.y = 0 "Value of Real output";
  Modelica.Blocks.Interfaces.RealOutput CS.P_dump_open1.y = 0 "Value of Real output";
  Modelica.Blocks.Interfaces.RealOutput CS.T_in_set1.y = CS.data.mdot_total 
    "Value of Real output";
  Modelica.Blocks.Interfaces.RealInput CS.switch2.u1 "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.BooleanInput CS.switch2.u2 "Connector of Boolean input signal";
  Modelica.Blocks.Interfaces.RealInput CS.switch2.u3 "Connector of second Real input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.switch2.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.BooleanOutput CS.booleanStep.y "Connector of Boolean output signal";
  Modelica.Blocks.Interfaces.RealInput CS.switch3.u1 "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.BooleanInput CS.switch3.u2 "Connector of Boolean input signal";
  Modelica.Blocks.Interfaces.RealInput CS.switch3.u3 "Connector of second Real input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.switch3.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput CS.switch4.u1 "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.BooleanInput CS.switch4.u2 "Connector of Boolean input signal";
  Modelica.Blocks.Interfaces.RealInput CS.switch4.u3 "Connector of second Real input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.switch4.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.BooleanOutput CS.booleanStep1.y "Connector of Boolean output signal";
  Modelica.Blocks.Interfaces.RealInput CS.switch5.u1 "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.BooleanInput CS.switch5.u2 "Connector of Boolean input signal";
  Modelica.Blocks.Interfaces.RealInput CS.switch5.u3 "Connector of second Real input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.switch5.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput CS.T_in_set2.y = 0.03 "Value of Real output";
  Modelica.Blocks.Interfaces.RealInput CS.switch6.u1 "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.BooleanInput CS.switch6.u2 "Connector of Boolean input signal";
  Modelica.Blocks.Interfaces.RealInput CS.switch6.u3 "Connector of second Real input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.switch6.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.BooleanOutput CS.booleanStep2.y "Connector of Boolean output signal";
  Modelica.Blocks.Interfaces.RealInput CS.switch7.u1 "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.BooleanInput CS.switch7.u2 "Connector of Boolean input signal";
  Modelica.Blocks.Interfaces.RealInput CS.switch7.u3 "Connector of second Real input signal";
  Modelica.Blocks.Interfaces.RealOutput CS.switch7.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput CS.ext_pos_start.y "Connector of Real output signal";
  Real ED.actuatorBus.opening_TCV "TCV fraction open";
  Real ED.actuatorBus.opening_TDV "TDV fraction open";
  Real ED.actuatorBus.opening_BV "BV fraction open";
  Real ED.actuatorBus.opening_BV_TCV "BV for TCV fraction open";
  Modelica.Blocks.Interfaces.RealOutput ED.actuatorBus.Feed_Pump_Speed 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput ED.actuatorBus.LPT1_BV(min = 0.0, max = 
    1.0) "=1: completely open, =0: completely closed";
  Modelica.Blocks.Interfaces.RealInput ED.actuatorBus.LPT2_BV "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.RealInput ED.actuatorBus.TBV(min = 0.0, max = 1.0) 
    "=1: completely open, =0: completely closed";
  Modelica.Units.SI.Power ED.sensorBus.Q_balance "Heat loss (negative)/gain (positive) not accounted for in connections (e.g., energy vented to atmosphere)";
  Modelica.Units.SI.Power ED.sensorBus.W_balance "Electricity loss (negative)/gain (positive) not accounted for in connections (e.g., heating/cooling, pumps, etc.)";
  Modelica.Units.SI.Power ED.sensorBus.W_total "Total electrical power generated";
  Modelica.Units.SI.Power ED.sensorBus.W_totalSetpoint "Total electrical power setpoint";
  Modelica.Units.SI.Pressure ED.sensorBus.p_inlet_steamTurbine "Inlet pressure to steam turbine";
  Modelica.Blocks.Interfaces.RealOutput ED.sensorBus.Extract_flow(unit = "kg/s")
     "Mass flow rate from port_a to port_b";
  Modelica.Blocks.Interfaces.RealOutput ED.sensorBus.Feedwater_Temp(unit = "K", 
    displayUnit = "degC", min = 0.0) "Temperature in port medium";
  Modelica.Blocks.Interfaces.RealOutput ED.sensorBus.Steam_Pressure(unit = "Pa",
     displayUnit = "bar", min = 0.0) "Pressure at port";
  Modelica.Blocks.Interfaces.RealOutput ED.sensorBus.Steam_Temperature(unit = 
    "K", displayUnit = "degC", min = 0.0) "Temperature in port medium";
  Real actuatorBus.opening_TCV "TCV fraction open";
  Real actuatorBus.opening_TDV "TDV fraction open";
  Real actuatorBus.opening_BV "BV fraction open";
  Real actuatorBus.opening_BV_TCV "BV for TCV fraction open";
  Modelica.Blocks.Interfaces.RealInput actuatorBus.TBV(min = 0.0, max = 1.0) 
    "=1: completely open, =0: completely closed";
  Modelica.Blocks.Interfaces.RealInput actuatorBus.LPT1_BV(min = 0.0, max = 1.0)
     "=1: completely open, =0: completely closed";
  Modelica.Blocks.Interfaces.RealInput actuatorBus.LPT2_BV "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.RealOutput actuatorBus.Feed_Pump_Speed 
    "Connector of Real output signal";
  Modelica.Units.SI.Power sensorBus.Q_balance "Heat loss (negative)/gain (positive) not accounted for in connections (e.g., energy vented to atmosphere)";
  Modelica.Units.SI.Power sensorBus.W_balance "Electricity loss (negative)/gain (positive) not accounted for in connections (e.g., heating/cooling, pumps, etc.)";
  Modelica.Units.SI.Power sensorBus.W_total "Total electrical power generated";
  Modelica.Units.SI.Power sensorBus.W_totalSetpoint "Total electrical power setpoint";
  Modelica.Units.SI.Pressure sensorBus.p_inlet_steamTurbine "Inlet pressure to steam turbine";
  Modelica.Blocks.Interfaces.RealOutput sensorBus.Steam_Temperature(unit = "K", 
    displayUnit = "degC", min = 0.0) "Temperature in port medium";
  Modelica.Blocks.Interfaces.RealOutput sensorBus.Feedwater_Temp(unit = "K", 
    displayUnit = "degC", min = 0.0) "Temperature in port medium";
  Modelica.Blocks.Interfaces.RealOutput sensorBus.Steam_Pressure(unit = "Pa", 
    displayUnit = "bar", min = 0.0) "Pressure at port";
  Modelica.Blocks.Interfaces.RealOutput sensorBus.Extract_flow(unit = "kg/s") 
    "Mass flow rate from port_a to port_b";
  Modelica.Blocks.Interfaces.RealOutput Q_balance.y = 0.0 "Value of Real output";
  Modelica.Blocks.Interfaces.RealOutput W_balance.y = 0.0 "Value of Real output";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate port_a_steam.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure port_a_steam.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy port_a_steam.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction port_a_steam.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty port_a_steam.C_outflow[0](
    start = fill(1.0, size(port_a_steam.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate port_b_feed.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure port_b_feed.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy port_b_feed.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction port_b_feed.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty port_b_feed.C_outflow[0](
    start = fill(1.0, size(port_b_feed.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate HPT.portHP.m_flow(min = 
    -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure HPT.portHP.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy HPT.portHP.h_outflow(start = 
    HPT.h_a_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction HPT.portHP.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty HPT.portHP.C_outflow[0](start = 
    fill(1.0, size(HPT.portHP.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate HPT.portLP.m_flow(max = 
    1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure HPT.portLP.p(start = 
    HPT.p_b_start, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy HPT.portLP.h_outflow(start = 
    100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction HPT.portLP.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty HPT.portLP.C_outflow[0](start = 
    fill(1.0, size(HPT.portLP.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Angle HPT.shaft_a.phi "Absolute rotation angle of flange";
  Modelica.Units.SI.Torque HPT.shaft_a.tau "Cut torque in the flange";
  Modelica.Units.SI.Angle HPT.shaft_b.phi "Absolute rotation angle of flange";
  Modelica.Units.SI.Torque HPT.shaft_b.tau "Cut torque in the flange";
  TRANSFORM.Units.NonDim HPT.eta_wetSteam.x_abs_in = HPT.x_abs_in 
    "Inlet quality";
  TRANSFORM.Units.NonDim HPT.eta_wetSteam.x_abs_out = HPT.x_abs_out 
    "Outlet quality";
  Modelica.Units.SI.Efficiency HPT.eta_wetSteam.eta "Turbine efficiency due to wetness";
  Modelica.Media.Interfaces.Types.FixedPhase HPT.state_a.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy HPT.state_a.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density HPT.state_a.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature HPT.state_a.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure HPT.state_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase HPT.state_b.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy HPT.state_b.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density HPT.state_b.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature HPT.state_b.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure HPT.state_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Real HPT.p_ratio "p_out/p_in pressure ratio";
  Modelica.Units.SI.Angle HPT.phi "Shaft rotation angle";
  Modelica.Units.SI.Torque HPT.tau "Net torque acting on the turbine";
  Modelica.Units.SI.AngularVelocity HPT.omega "Shaft angular velocity";
  Modelica.Units.SI.MassFlowRate HPT.m_flow(start = HPT.m_flow_start) 
    "Mass flow rate";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy HPT.h_in(start = 
    HPT.h_a_start, nominal = 500000.0) "Inlet enthalpy";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy HPT.h_out(start = 
    HPT.h_b_start, nominal = 500000.0) "Outlet enthalpy";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy HPT.h_is(start = 
    HPT.h_b_start, nominal = 500000.0) "Isentropic outlet enthalpy";
  Modelica.Media.Interfaces.Types.AbsolutePressure HPT.p_in(start = 
    HPT.p_a_start, nominal = 1000000.0, min = 611.657) "Inlet pressure";
  Modelica.Media.Interfaces.Types.AbsolutePressure HPT.p_out(start = 
    HPT.p_b_start, nominal = 1000000.0, min = 611.657) "Outlet pressure";
  Modelica.Units.SI.Power HPT.Q_mech "Total mechanical power";
  Modelica.Units.SI.Power HPT.Q_units[HPT.nUnits](start = HPT.Q_units_start) 
    "Mechanical power per unit";
  Modelica.Units.SI.Power HPT.Qbs[HPT.nUnits] "Power balance";
  Modelica.Units.SI.Efficiency HPT.eta_is "Isentropic efficiency";
  Modelica.Media.Interfaces.Types.AbsolutePressure HPT.sat_in.psat(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature HPT.sat_in.Tsat(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure HPT.sat_out.psat(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature HPT.sat_out.Tsat(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Modelica.Media.Interfaces.Types.FixedPhase HPT.bubble_in.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy HPT.bubble_in.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density HPT.bubble_in.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature HPT.bubble_in.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure HPT.bubble_in.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase HPT.dew_in.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy HPT.dew_in.h(start = 100000.0,
     nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density HPT.dew_in.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature HPT.dew_in.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure HPT.dew_in.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase HPT.bubble_out.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy HPT.bubble_out.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density HPT.bubble_out.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature HPT.bubble_out.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure HPT.bubble_out.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase HPT.dew_out.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy HPT.dew_out.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density HPT.dew_out.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature HPT.dew_out.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure HPT.dew_out.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.SI.SpecificEnthalpy HPT.h_fsat_in = HPT.bubble_in.h 
    "Saturated liquid specific enthalpy at inlet";
  Modelica.Units.SI.SpecificEnthalpy HPT.h_gsat_in = HPT.dew_in.h 
    "Saturated vapor specific enthalpy  at inlet";
  Modelica.Units.SI.SpecificEnthalpy HPT.h_fsat_out = HPT.bubble_out.h 
    "Saturated liquid specific enthalpy at outlet";
  Modelica.Units.SI.SpecificEnthalpy HPT.h_gsat_out = HPT.dew_out.h 
    "Saturated vapor specific enthalpy  at outlet";
  TRANSFORM.Units.NonDim HPT.x_th_in "Inlet thermodynamic quality";
  TRANSFORM.Units.NonDim HPT.x_abs_in "Inlet absolute mass quality";
  TRANSFORM.Units.NonDim HPT.x_th_out "Outlet thermodynamic quality";
  TRANSFORM.Units.NonDim HPT.x_abs_out "Outlet absolute mass quality";
  Modelica.Blocks.Interfaces.RealInput HPT.partialArc;
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate LPT1.portHP.m_flow(min = 
    -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1.portHP.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1.portHP.h_outflow(
    start = LPT1.h_a_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction LPT1.portHP.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty LPT1.portHP.C_outflow[0](
    start = fill(1.0, size(LPT1.portHP.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate LPT1.portLP.m_flow(max = 
    1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1.portLP.p(start = 
    LPT1.p_b_start, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1.portLP.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction LPT1.portLP.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty LPT1.portLP.C_outflow[0](
    start = fill(1.0, size(LPT1.portLP.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Angle LPT1.shaft_a.phi "Absolute rotation angle of flange";
  Modelica.Units.SI.Torque LPT1.shaft_a.tau "Cut torque in the flange";
  Modelica.Units.SI.Angle LPT1.shaft_b.phi "Absolute rotation angle of flange";
  Modelica.Units.SI.Torque LPT1.shaft_b.tau "Cut torque in the flange";
  TRANSFORM.Units.NonDim LPT1.eta_wetSteam.x_abs_in = LPT1.x_abs_in 
    "Inlet quality";
  TRANSFORM.Units.NonDim LPT1.eta_wetSteam.x_abs_out = LPT1.x_abs_out 
    "Outlet quality";
  Modelica.Units.SI.Efficiency LPT1.eta_wetSteam.eta "Turbine efficiency due to wetness";
  Modelica.Media.Interfaces.Types.FixedPhase LPT1.state_a.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1.state_a.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density LPT1.state_a.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature LPT1.state_a.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1.state_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase LPT1.state_b.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1.state_b.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density LPT1.state_b.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature LPT1.state_b.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1.state_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Real LPT1.p_ratio "p_out/p_in pressure ratio";
  Modelica.Units.SI.Angle LPT1.phi "Shaft rotation angle";
  Modelica.Units.SI.Torque LPT1.tau "Net torque acting on the turbine";
  Modelica.Units.SI.AngularVelocity LPT1.omega "Shaft angular velocity";
  Modelica.Units.SI.MassFlowRate LPT1.m_flow(start = LPT1.m_flow_start) 
    "Mass flow rate";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1.h_in(start = 
    LPT1.h_a_start, nominal = 500000.0) "Inlet enthalpy";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1.h_out(start = 
    LPT1.h_b_start, nominal = 500000.0) "Outlet enthalpy";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1.h_is(start = 
    LPT1.h_b_start, nominal = 500000.0) "Isentropic outlet enthalpy";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1.p_in(start = 
    LPT1.p_a_start, nominal = 1000000.0, min = 611.657) "Inlet pressure";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1.p_out(start = 
    LPT1.p_b_start, nominal = 1000000.0, min = 611.657) "Outlet pressure";
  Modelica.Units.SI.Power LPT1.Q_mech "Total mechanical power";
  Modelica.Units.SI.Power LPT1.Q_units[LPT1.nUnits](start = LPT1.Q_units_start) 
    "Mechanical power per unit";
  Modelica.Units.SI.Power LPT1.Qbs[LPT1.nUnits] "Power balance";
  Modelica.Units.SI.Efficiency LPT1.eta_is "Isentropic efficiency";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1.sat_in.psat(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature LPT1.sat_in.Tsat(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1.sat_out.psat(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature LPT1.sat_out.Tsat(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Modelica.Media.Interfaces.Types.FixedPhase LPT1.bubble_in.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1.bubble_in.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density LPT1.bubble_in.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature LPT1.bubble_in.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1.bubble_in.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase LPT1.dew_in.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1.dew_in.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density LPT1.dew_in.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature LPT1.dew_in.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1.dew_in.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase LPT1.bubble_out.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1.bubble_out.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density LPT1.bubble_out.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature LPT1.bubble_out.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1.bubble_out.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase LPT1.dew_out.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1.dew_out.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density LPT1.dew_out.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature LPT1.dew_out.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1.dew_out.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.SI.SpecificEnthalpy LPT1.h_fsat_in = LPT1.bubble_in.h 
    "Saturated liquid specific enthalpy at inlet";
  Modelica.Units.SI.SpecificEnthalpy LPT1.h_gsat_in = LPT1.dew_in.h 
    "Saturated vapor specific enthalpy  at inlet";
  Modelica.Units.SI.SpecificEnthalpy LPT1.h_fsat_out = LPT1.bubble_out.h 
    "Saturated liquid specific enthalpy at outlet";
  Modelica.Units.SI.SpecificEnthalpy LPT1.h_gsat_out = LPT1.dew_out.h 
    "Saturated vapor specific enthalpy  at outlet";
  TRANSFORM.Units.NonDim LPT1.x_th_in "Inlet thermodynamic quality";
  TRANSFORM.Units.NonDim LPT1.x_abs_in "Inlet absolute mass quality";
  TRANSFORM.Units.NonDim LPT1.x_th_out "Outlet thermodynamic quality";
  TRANSFORM.Units.NonDim LPT1.x_abs_out "Outlet absolute mass quality";
  Modelica.Blocks.Interfaces.RealInput LPT1.partialArc;
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate LPT2.portHP.m_flow(min = 
    -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT2.portHP.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT2.portHP.h_outflow(
    start = LPT2.h_a_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction LPT2.portHP.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty LPT2.portHP.C_outflow[0](
    start = fill(1.0, size(LPT2.portHP.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate LPT2.portLP.m_flow(max = 
    1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT2.portLP.p(start = 
    LPT2.p_b_start, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT2.portLP.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction LPT2.portLP.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty LPT2.portLP.C_outflow[0](
    start = fill(1.0, size(LPT2.portLP.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Angle LPT2.shaft_a.phi "Absolute rotation angle of flange";
  Modelica.Units.SI.Torque LPT2.shaft_a.tau "Cut torque in the flange";
  Modelica.Units.SI.Angle LPT2.shaft_b.phi "Absolute rotation angle of flange";
  Modelica.Units.SI.Torque LPT2.shaft_b.tau "Cut torque in the flange";
  TRANSFORM.Units.NonDim LPT2.eta_wetSteam.x_abs_in = LPT2.x_abs_in 
    "Inlet quality";
  TRANSFORM.Units.NonDim LPT2.eta_wetSteam.x_abs_out = LPT2.x_abs_out 
    "Outlet quality";
  Modelica.Units.SI.Efficiency LPT2.eta_wetSteam.eta "Turbine efficiency due to wetness";
  Modelica.Media.Interfaces.Types.FixedPhase LPT2.state_a.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT2.state_a.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density LPT2.state_a.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature LPT2.state_a.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT2.state_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase LPT2.state_b.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT2.state_b.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density LPT2.state_b.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature LPT2.state_b.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT2.state_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Real LPT2.p_ratio "p_out/p_in pressure ratio";
  Modelica.Units.SI.Angle LPT2.phi "Shaft rotation angle";
  Modelica.Units.SI.Torque LPT2.tau "Net torque acting on the turbine";
  Modelica.Units.SI.AngularVelocity LPT2.omega "Shaft angular velocity";
  Modelica.Units.SI.MassFlowRate LPT2.m_flow(start = LPT2.m_flow_start) 
    "Mass flow rate";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT2.h_in(start = 
    LPT2.h_a_start, nominal = 500000.0) "Inlet enthalpy";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT2.h_out(start = 
    LPT2.h_b_start, nominal = 500000.0) "Outlet enthalpy";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT2.h_is(start = 
    LPT2.h_b_start, nominal = 500000.0) "Isentropic outlet enthalpy";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT2.p_in(start = 
    LPT2.p_a_start, nominal = 1000000.0, min = 611.657) "Inlet pressure";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT2.p_out(start = 
    LPT2.p_b_start, nominal = 1000000.0, min = 611.657) "Outlet pressure";
  Modelica.Units.SI.Power LPT2.Q_mech "Total mechanical power";
  Modelica.Units.SI.Power LPT2.Q_units[LPT2.nUnits](start = LPT2.Q_units_start) 
    "Mechanical power per unit";
  Modelica.Units.SI.Power LPT2.Qbs[LPT2.nUnits] "Power balance";
  Modelica.Units.SI.Efficiency LPT2.eta_is "Isentropic efficiency";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT2.sat_in.psat(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature LPT2.sat_in.Tsat(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT2.sat_out.psat(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature LPT2.sat_out.Tsat(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Modelica.Media.Interfaces.Types.FixedPhase LPT2.bubble_in.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT2.bubble_in.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density LPT2.bubble_in.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature LPT2.bubble_in.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT2.bubble_in.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase LPT2.dew_in.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT2.dew_in.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density LPT2.dew_in.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature LPT2.dew_in.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT2.dew_in.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase LPT2.bubble_out.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT2.bubble_out.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density LPT2.bubble_out.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature LPT2.bubble_out.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT2.bubble_out.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase LPT2.dew_out.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT2.dew_out.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density LPT2.dew_out.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature LPT2.dew_out.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT2.dew_out.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.SI.SpecificEnthalpy LPT2.h_fsat_in = LPT2.bubble_in.h 
    "Saturated liquid specific enthalpy at inlet";
  Modelica.Units.SI.SpecificEnthalpy LPT2.h_gsat_in = LPT2.dew_in.h 
    "Saturated vapor specific enthalpy  at inlet";
  Modelica.Units.SI.SpecificEnthalpy LPT2.h_fsat_out = LPT2.bubble_out.h 
    "Saturated liquid specific enthalpy at outlet";
  Modelica.Units.SI.SpecificEnthalpy LPT2.h_gsat_out = LPT2.dew_out.h 
    "Saturated vapor specific enthalpy  at outlet";
  TRANSFORM.Units.NonDim LPT2.x_th_in "Inlet thermodynamic quality";
  TRANSFORM.Units.NonDim LPT2.x_abs_in "Inlet absolute mass quality";
  TRANSFORM.Units.NonDim LPT2.x_th_out "Outlet thermodynamic quality";
  TRANSFORM.Units.NonDim LPT2.x_abs_out "Outlet absolute mass quality";
  Modelica.Blocks.Interfaces.RealInput LPT2.partialArc;
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate moistureSeperator.port_Liquid.m_flow
     "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure moistureSeperator.port_Liquid.p
    (start = moistureSeperator.p_start, nominal = 1000000.0, min = 611.657) 
    "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy moistureSeperator.port_Liquid.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction moistureSeperator.port_Liquid.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty moistureSeperator.port_Liquid.C_outflow
    [0](start = fill(1.0, size(moistureSeperator.port_Liquid.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate moistureSeperator.port_a[1].m_flow
     "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure moistureSeperator.port_a[1].p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy moistureSeperator.port_a[1].h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction moistureSeperator.port_a[1].Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty moistureSeperator.port_a[1].C_outflow
    [0](start = fill(1.0, size(moistureSeperator.port_a[1].C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate moistureSeperator.port_b[1].m_flow
     "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure moistureSeperator.port_b[1].p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy moistureSeperator.port_b[1].h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction moistureSeperator.port_b[1].Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty moistureSeperator.port_b[1].C_outflow
    [0](start = fill(1.0, size(moistureSeperator.port_b[1].C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Volume moistureSeperator.V(min = 0.0) = moistureSeperator.geometry.V
     "Volume";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    moistureSeperator.medium.p(start = moistureSeperator.p_start, nominal = 
    100000.0, unit = "Pa", displayUnit = "bar", min = 0.0, stateSelect = 
    StateSelect.prefer) "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    moistureSeperator.medium.Xi[0](start = moistureSeperator.X_start[1:0], 
    unit = "1", min = 0.0, max = 1.0) "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    moistureSeperator.medium.h(start = (if  not moistureSeperator.use_T_start
     then moistureSeperator.h_start else Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique1
    (moistureSeperator.p_start, moistureSeperator.T_start, moistureSeperator.X_start
    [1:0], 0)), unit = "J/kg", stateSelect = StateSelect.prefer) 
    "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density moistureSeperator.medium.d(start = (
    if moistureSeperator.use_T_start then Modelica.Media.Water.WaterIF97_ph.density_pTX_Unique22
    (moistureSeperator.p_start, moistureSeperator.T_start, moistureSeperator.X_start
    [1:0]) else Modelica.Media.Water.WaterIF97_ph.density_phX_Unique23(
    moistureSeperator.p_start, moistureSeperator.h_start, moistureSeperator.X_start
    [1:0], 0)), nominal = 500.0) "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature moistureSeperator.medium.T(
    start = (if moistureSeperator.use_T_start then moistureSeperator.T_start
     else Modelica.Media.Water.WaterIF97_ph.temperature_phX_Unique24(
    moistureSeperator.p_start, moistureSeperator.h_start, moistureSeperator.X_start
    [1:0], 0)), nominal = 500.0, min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction moistureSeperator.medium.X[1](
    start = moistureSeperator.X_start) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy moistureSeperator.medium.u
     "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity moistureSeperator.medium.R_s
     "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass moistureSeperator.medium.MM 
    "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase moistureSeperator.medium.state.phase
     "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy moistureSeperator.medium.state.h
    (start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density moistureSeperator.medium.state.d(
    start = 150, nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature moistureSeperator.medium.state.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure moistureSeperator.medium.state.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC moistureSeperator.medium.T_degC = 
    Modelica.Units.Conversions.to_degC(moistureSeperator.medium.T) 
    "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar moistureSeperator.medium.p_bar = 
    Modelica.Units.Conversions.to_bar(moistureSeperator.medium.p) 
    "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure moistureSeperator.medium.sat.psat
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature moistureSeperator.medium.sat.Tsat(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer moistureSeperator.medium.phase(start = 1, fixed = false, min = 0.0, 
    max = 2.0) "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Units.SI.Mass moistureSeperator.m "Mass";
  Modelica.Units.SI.InternalEnergy moistureSeperator.U "Internal energy";
  Modelica.Units.SI.Mass moistureSeperator.mXi[0] "Species mass";
  TRANSFORM.Units.ExtraPropertyExtrinsic moistureSeperator.mC[0] 
    "Trace substance extrinsic value";
  TRANSFORM.Units.ExtraPropertyExtrinsic moistureSeperator.mC_scaled[0] 
    "Scaled trace substance for improved numerical stability";
  TRANSFORM.Units.ExtraProperty moistureSeperator.C[0](start = moistureSeperator.C_start,
     stateSelect = StateSelect.prefer) "Trace substance mass-specific value";
  Modelica.Units.SI.MassFlowRate moistureSeperator.mb = sum(moistureSeperator.port_a
    .m_flow)+sum(moistureSeperator.port_b.m_flow)+moistureSeperator.port_Liquid.m_flow
     "Mass flow rate source/sinks within volumes";
  Modelica.Units.SI.HeatFlowRate moistureSeperator.Ub = sum(moistureSeperator.H_flows_a)
    +sum(moistureSeperator.H_flows_b)+moistureSeperator.port_Liquid.m_flow*
    actualStream(moistureSeperator.port_Liquid.h_outflow)+moistureSeperator.Q_flow_internal
    +moistureSeperator.Q_gen "Energy source/sinks within volumes (e.g., ohmic heating, external convection)";
  Modelica.Units.SI.MassFlowRate moistureSeperator.mXib[0] = array(sum(
    moistureSeperator.mXi_flows_a[:, i])+sum(moistureSeperator.mXi_flows_b[:, i])
    +moistureSeperator.port_Liquid.m_flow*actualStream(moistureSeperator.port_Liquid.Xi_outflow
    [i]) for i in 1:0) "Species mass flow rates source/sinks within volumes";
  TRANSFORM.Units.ExtraPropertyFlowRate moistureSeperator.mCb[0] = array(sum(
    moistureSeperator.mC_flows_a[:, i])+sum(moistureSeperator.mC_flows_b[:, i])+
    moistureSeperator.port_Liquid.m_flow*actualStream(moistureSeperator.port_Liquid.C_outflow
    [i])+moistureSeperator.mC_flow_internal[i]+moistureSeperator.mC_gen[i] for i
     in 1:0) "Trace flow rate source/sinks within volumes (e.g., chemical reactions, external convection)";
  Modelica.Units.SI.Volume moistureSeperator.geometry.V = 5 "Volume";
  Modelica.Units.SI.Angle moistureSeperator.geometry.angle(min = 
    -1.5807963267948966, max = 1.5807963267948966) = 0.0 "Vertical angle from the horizontal (-pi/2 <= x <= pi/2)";
  Modelica.Units.SI.Length moistureSeperator.geometry.dheight = 0*sin(
    moistureSeperator.geometry.angle) "Height(port_b) - Height(port_a)";
  Modelica.Units.SI.Length moistureSeperator.geometry.height_a = 0 
    "Elevation at port_a: Reference value only. No impact on calculations.";
  Modelica.Units.SI.Length moistureSeperator.geometry.height_b = 
    moistureSeperator.geometry.height_a+moistureSeperator.geometry.dheight 
    "Elevation at port_b: Reference value only. No impact on calculations.";
  Modelica.Units.SI.Acceleration moistureSeperator.g_n = 9.80665 
    "Gravitational acceleration";
  Modelica.Units.SI.HeatFlowRate moistureSeperator.H_flows_a[moistureSeperator.nPorts_a]
     "Enthalpy flow rates at port_a";
  Modelica.Units.SI.MassFlowRate moistureSeperator.mXi_flows_a[moistureSeperator.nPorts_a,
     0] "Species mass flow rates at port_a";
  TRANSFORM.Units.ExtraPropertyFlowRate moistureSeperator.mC_flows_a[
    moistureSeperator.nPorts_a, 0] "Trace substance flow rates at port_a";
  Modelica.Units.SI.HeatFlowRate moistureSeperator.H_flows_b[moistureSeperator.nPorts_b]
     "Enthalpy flow rates at port_b";
  Modelica.Units.SI.MassFlowRate moistureSeperator.mXi_flows_b[moistureSeperator.nPorts_b,
     0] "Species mass flow rates at port_b";
  TRANSFORM.Units.ExtraPropertyFlowRate moistureSeperator.mC_flows_b[
    moistureSeperator.nPorts_b, 0] "Trace substance flow rates at port_b";
  Modelica.Units.SI.HeatFlowRate moistureSeperator.Q_gen = 0 "Internal heat generation";
  TRANSFORM.Units.ExtraPropertyFlowRate moistureSeperator.mC_gen[0] = fill(0, 0)
     "Internal trace mass generation";
  Modelica.Units.SI.HeatFlowRate moistureSeperator.Q_flow_internal;
  TRANSFORM.Units.ExtraPropertyFlowRate moistureSeperator.mC_flow_internal[0];
  Modelica.Units.SI.Efficiency moistureSeperator.eta_sep(max = 1.0) = 0.99 
    "Separation efficiency";
  Modelica.Units.SI.MassFlowRate moistureSeperator.m_flow_liquid;
  Modelica.Units.SI.MassFlowRate moistureSeperator.m_flow_a_inflow;
  Modelica.Units.SI.MassFlowRate moistureSeperator.m_flow_b_inflow;
  Modelica.Units.SI.MassFraction moistureSeperator.x_abs;
  Modelica.Units.SI.Pressure moistureSeperator.p_crit = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
    .criticalPressure;
  Modelica.Units.SI.SpecificEnthalpy moistureSeperator.h_lsat;
  Modelica.Units.SI.SpecificEnthalpy moistureSeperator.h_vsat;
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate port_b_bypass.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure port_b_bypass.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy port_b_bypass.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction port_b_bypass.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty port_b_bypass.C_outflow[0](
    start = fill(1.0, size(port_b_bypass.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Volume LPT1_bypass.V(min = 0.0) = 5 "Volume";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    LPT1_bypass.medium.p(start = LPT1_bypass.p_start, nominal = 100000.0, 
    unit = "Pa", displayUnit = "bar", min = 0.0, stateSelect = StateSelect.prefer)
     "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    LPT1_bypass.medium.Xi[0](start = LPT1_bypass.X_start[1:0], unit = "1", 
    min = 0.0, max = 1.0) "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    LPT1_bypass.medium.h(start = (if  not LPT1_bypass.use_T_start then 
    LPT1_bypass.h_start else Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique1
    (LPT1_bypass.p_start, LPT1_bypass.T_start, LPT1_bypass.X_start[1:0], 0)), 
    unit = "J/kg", stateSelect = StateSelect.prefer) "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density LPT1_bypass.medium.d(start = (if 
    LPT1_bypass.use_T_start then Modelica.Media.Water.WaterIF97_ph.density_pTX_Unique22
    (LPT1_bypass.p_start, LPT1_bypass.T_start, LPT1_bypass.X_start[1:0]) else 
    Modelica.Media.Water.WaterIF97_ph.density_phX_Unique23(LPT1_bypass.p_start, 
    LPT1_bypass.h_start, LPT1_bypass.X_start[1:0], 0)), nominal = 500.0) 
    "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature LPT1_bypass.medium.T(start = (if 
    LPT1_bypass.use_T_start then LPT1_bypass.T_start else Modelica.Media.Water.WaterIF97_ph.temperature_phX_Unique24
    (LPT1_bypass.p_start, LPT1_bypass.h_start, LPT1_bypass.X_start[1:0], 0)), 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction LPT1_bypass.medium.X[1](start = 
    LPT1_bypass.X_start) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy LPT1_bypass.medium.u 
    "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity LPT1_bypass.medium.R_s 
    "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass LPT1_bypass.medium.MM 
    "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase LPT1_bypass.medium.state.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1_bypass.medium.state.h(
    start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density LPT1_bypass.medium.state.d(start = 150,
     nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature LPT1_bypass.medium.state.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1_bypass.medium.state.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC LPT1_bypass.medium.T_degC = 
    Modelica.Units.Conversions.to_degC(LPT1_bypass.medium.T) "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar LPT1_bypass.medium.p_bar = Modelica.Units.Conversions.to_bar
    (LPT1_bypass.medium.p) "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1_bypass.medium.sat.psat(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature LPT1_bypass.medium.sat.Tsat(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer LPT1_bypass.medium.phase(start = 1, fixed = false, min = 0.0, max = 
    2.0) "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Units.SI.Mass LPT1_bypass.m "Mass";
  Modelica.Units.SI.InternalEnergy LPT1_bypass.U "Internal energy";
  Modelica.Units.SI.Mass LPT1_bypass.mXi[0] "Species mass";
  TRANSFORM.Units.ExtraPropertyExtrinsic LPT1_bypass.mC[0] "Trace substance extrinsic value";
  TRANSFORM.Units.ExtraPropertyExtrinsic LPT1_bypass.mC_scaled[0] 
    "Scaled trace substance for improved numerical stability";
  TRANSFORM.Units.ExtraProperty LPT1_bypass.C[0](start = LPT1_bypass.C_start, 
    stateSelect = StateSelect.prefer) "Trace substance mass-specific value";
  Modelica.Units.SI.MassFlowRate LPT1_bypass.mb = LPT1_bypass.port_1.m_flow+
    LPT1_bypass.port_2.m_flow+LPT1_bypass.port_3.m_flow "Mass flow rate source/sinks within volumes";
  Modelica.Units.SI.HeatFlowRate LPT1_bypass.Ub = LPT1_bypass.port_1.m_flow*
    actualStream(LPT1_bypass.port_1.h_outflow)+LPT1_bypass.port_2.m_flow*
    actualStream(LPT1_bypass.port_2.h_outflow)+LPT1_bypass.port_3.m_flow*
    actualStream(LPT1_bypass.port_3.h_outflow) "Energy source/sinks within volumes (e.g., ohmic heating, external convection)";
  Modelica.Units.SI.MassFlowRate LPT1_bypass.mXib[0] = LPT1_bypass.port_1.m_flow
    *actualStream(LPT1_bypass.port_1.Xi_outflow)+LPT1_bypass.port_2.m_flow*
    actualStream(LPT1_bypass.port_2.Xi_outflow)+LPT1_bypass.port_3.m_flow*
    actualStream(LPT1_bypass.port_3.Xi_outflow) "Species mass flow rates source/sinks within volumes";
  TRANSFORM.Units.ExtraPropertyFlowRate LPT1_bypass.mCb[0] = LPT1_bypass.port_1.m_flow
    *actualStream(LPT1_bypass.port_1.C_outflow)+LPT1_bypass.port_2.m_flow*
    actualStream(LPT1_bypass.port_2.C_outflow)+LPT1_bypass.port_3.m_flow*
    actualStream(LPT1_bypass.port_3.C_outflow) "Trace flow rate source/sinks within volumes (e.g., chemical reactions, external convection)";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate LPT1_bypass.port_1.m_flow
     "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1_bypass.port_1.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1_bypass.port_1.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction LPT1_bypass.port_1.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty LPT1_bypass.port_1.C_outflow[0](
    start = fill(1.0, size(LPT1_bypass.port_1.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate LPT1_bypass.port_2.m_flow
     "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1_bypass.port_2.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1_bypass.port_2.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction LPT1_bypass.port_2.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty LPT1_bypass.port_2.C_outflow[0](
    start = fill(1.0, size(LPT1_bypass.port_2.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate LPT1_bypass.port_3.m_flow
     "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1_bypass.port_3.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1_bypass.port_3.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction LPT1_bypass.port_3.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty LPT1_bypass.port_3.C_outflow[0](
    start = fill(1.0, size(LPT1_bypass.port_3.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate LPT1_bypass_valve.port_a.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1_bypass_valve.port_a.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1_bypass_valve.port_a.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction LPT1_bypass_valve.port_a.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty LPT1_bypass_valve.port_a.C_outflow
    [0](start = fill(1.0, size(LPT1_bypass_valve.port_a.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate LPT1_bypass_valve.port_b.m_flow
    (max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1_bypass_valve.port_b.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1_bypass_valve.port_b.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction LPT1_bypass_valve.port_b.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty LPT1_bypass_valve.port_b.C_outflow
    [0](start = fill(1.0, size(LPT1_bypass_valve.port_b.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate LPT1_bypass_valve.m_flow(
    start = LPT1_bypass_valve.m_flow_start, min = -1E+60) "Mass flow rate in design flow direction";
  Modelica.Units.SI.Pressure LPT1_bypass_valve.dp(start = LPT1_bypass_valve.dp_start)
     "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
  Modelica.Units.SI.VolumeFlowRate LPT1_bypass_valve.V_flow = LPT1_bypass_valve.m_flow
    /Modelica.Fluid.Utilities.regStep(LPT1_bypass_valve.m_flow, Modelica.Media.Water.WaterIF97_ph.density_Unique20
    (
    LPT1_bypass_valve.state_a), Modelica.Media.Water.WaterIF97_ph.density_Unique20
    (
    LPT1_bypass_valve.state_b), LPT1_bypass_valve.m_flow_small) "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";
  Modelica.Media.Interfaces.Types.Temperature LPT1_bypass_valve.port_a_T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = 
    Modelica.Fluid.Utilities.regStep(LPT1_bypass_valve.port_a.m_flow, 
    Modelica.Media.Water.WaterIF97_ph.temperature_Unique25(
    LPT1_bypass_valve.state_a), Modelica.Media.Water.WaterIF97_ph.temperature_Unique25
    (
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(LPT1_bypass_valve.port_a.p,
       LPT1_bypass_valve.port_a.h_outflow, LPT1_bypass_valve.port_a.Xi_outflow, 0,
       0)), LPT1_bypass_valve.m_flow_small) "Temperature close to port_a, if show_T = true";
  Modelica.Media.Interfaces.Types.Temperature LPT1_bypass_valve.port_b_T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = 
    Modelica.Fluid.Utilities.regStep(LPT1_bypass_valve.port_b.m_flow, 
    Modelica.Media.Water.WaterIF97_ph.temperature_Unique25(
    LPT1_bypass_valve.state_b), Modelica.Media.Water.WaterIF97_ph.temperature_Unique25
    (
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(LPT1_bypass_valve.port_b.p,
       LPT1_bypass_valve.port_b.h_outflow, LPT1_bypass_valve.port_b.Xi_outflow, 0,
       0)), LPT1_bypass_valve.m_flow_small) "Temperature close to port_b, if show_T = true";
  Modelica.Media.Interfaces.Types.FixedPhase LPT1_bypass_valve.state_a.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1_bypass_valve.state_a.h(
    start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density LPT1_bypass_valve.state_a.d(start = 150,
     nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature LPT1_bypass_valve.state_a.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1_bypass_valve.state_a.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase LPT1_bypass_valve.state_b.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy LPT1_bypass_valve.state_b.h(
    start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density LPT1_bypass_valve.state_b.d(start = 150,
     nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature LPT1_bypass_valve.state_b.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure LPT1_bypass_valve.state_b.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Blocks.Interfaces.RealInput LPT1_bypass_valve.opening(min = 0.0, 
    max = 1.0) "=1: completely open, =0: completely closed";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate prt_b_steamdump.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure prt_b_steamdump.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy prt_b_steamdump.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction prt_b_steamdump.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty prt_b_steamdump.C_outflow[0](
    start = fill(1.0, size(prt_b_steamdump.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate TBV.port_a.m_flow(min = 
    -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure TBV.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy TBV.port_a.h_outflow(start = 
    100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction TBV.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty TBV.port_a.C_outflow[0](start = 
    fill(1.0, size(TBV.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate TBV.port_b.m_flow(max = 
    1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure TBV.port_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy TBV.port_b.h_outflow(start = 
    100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction TBV.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty TBV.port_b.C_outflow[0](start = 
    fill(1.0, size(TBV.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate TBV.m_flow(start = 
    TBV.m_flow_start, min = -1E+60) "Mass flow rate in design flow direction";
  Modelica.Units.SI.Pressure TBV.dp(start = TBV.dp_start) "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
  Modelica.Units.SI.VolumeFlowRate TBV.V_flow = TBV.m_flow/Modelica.Fluid.Utilities.regStep
    (TBV.m_flow, Modelica.Media.Water.WaterIF97_ph.density_Unique20(
    TBV.state_a), Modelica.Media.Water.WaterIF97_ph.density_Unique20(
    TBV.state_b), TBV.m_flow_small) "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";
  Modelica.Media.Interfaces.Types.Temperature TBV.port_a_T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) = Modelica.Fluid.Utilities.regStep
    (TBV.port_a.m_flow, Modelica.Media.Water.WaterIF97_ph.temperature_Unique25(
    TBV.state_a), Modelica.Media.Water.WaterIF97_ph.temperature_Unique25(
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(TBV.port_a.p, 
      TBV.port_a.h_outflow, TBV.port_a.Xi_outflow, 0, 0)), TBV.m_flow_small) 
    "Temperature close to port_a, if show_T = true";
  Modelica.Media.Interfaces.Types.Temperature TBV.port_b_T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) = Modelica.Fluid.Utilities.regStep
    (TBV.port_b.m_flow, Modelica.Media.Water.WaterIF97_ph.temperature_Unique25(
    TBV.state_b), Modelica.Media.Water.WaterIF97_ph.temperature_Unique25(
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(TBV.port_b.p, 
      TBV.port_b.h_outflow, TBV.port_b.Xi_outflow, 0, 0)), TBV.m_flow_small) 
    "Temperature close to port_b, if show_T = true";
  Modelica.Media.Interfaces.Types.FixedPhase TBV.state_a.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy TBV.state_a.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density TBV.state_a.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature TBV.state_a.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure TBV.state_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase TBV.state_b.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy TBV.state_b.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density TBV.state_b.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature TBV.state_b.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure TBV.state_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Blocks.Interfaces.RealInput TBV.opening(min = 0.0, max = 1.0) 
    "=1: completely open, =0: completely closed";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate condenser.port_a.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure condenser.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy condenser.port_a.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction condenser.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty condenser.port_a.C_outflow[0](
    start = fill(1.0, size(condenser.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate condenser.port_b.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure condenser.port_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy condenser.port_b.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction condenser.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty condenser.port_b.C_outflow[0](
    start = fill(1.0, size(condenser.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.AbsolutePressure condenser.sat.psat(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature condenser.sat.Tsat(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy condenser.h_fsat(start = 
    100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique15
    (
    condenser.sat) "Specific enthalpy of saturated liquid";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy condenser.h_gsat(start = 
    100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique18
    (
    condenser.sat) "Specific enthalpy of saturated vapor";
  Modelica.Units.SI.Density condenser.rho_fsat = Modelica.Media.Water.WaterIF97_ph.bubbleDensity_Unique16
    (
    condenser.sat) "Density of saturated liquid";
  Modelica.Units.SI.Density condenser.rho_gsat = Modelica.Media.Water.WaterIF97_ph.dewDensity_Unique19
    (
    condenser.sat) "Density of saturated steam";
  Modelica.Units.SI.Mass condenser.m_total "Total mass, steam+liquid";
  Modelica.Units.SI.Mass condenser.m_liquid "Liquid mass";
  Modelica.Units.SI.Mass condenser.m_vapor "Steam mass";
  Modelica.Units.SI.Volume condenser.V_liquid(start = condenser.V_liquid_start) 
    "Liquid volume";
  Modelica.Units.SI.Volume condenser.V_vapor "Steam volume";
  Modelica.Units.SI.Energy condenser.E "Internal energy";
  Modelica.Units.SI.Power condenser.Q_total "Total thermal energy removed";
  Modelica.Units.SI.Power generator.Q_mech "Mechanical power";
  Modelica.Units.SI.Power generator.Q_elec "Electrical Power";
  Modelica.Units.SI.Power generator.Q_loss "Inertial power Loss";
  Modelica.Units.SI.Torque generator.tau "Torque at shaft";
  Modelica.Units.SI.AngularVelocity generator.omega_m(start = 6.283185307179586*
    generator.f_start/generator.nPoles) "Angular velocity of the shaft";
  Modelica.Units.SI.AngularVelocity generator.omega_e "Angular velocity of the e.m.f. rotating frame";
  Modelica.Units.NonSI.AngularVelocity_rpm generator.shaft_rpm = 
    Modelica.Units.Conversions.to_rpm(generator.omega_m) "Shaft rotational speed";
  Modelica.Units.SI.Frequency generator.f "Electrical frequency";
  Modelica.Units.SI.Power generator.port.W "Active power";
  Modelica.Units.SI.Frequency generator.port.f "Frequency";
  Modelica.Units.SI.Angle generator.shaft.phi "Absolute rotation angle of flange";
  Modelica.Units.SI.Torque generator.shaft.tau "Cut torque in the flange";
  Modelica.Units.SI.Power port_a_elec.W "Active power";
  Modelica.Units.SI.Frequency port_a_elec.f "Frequency";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate pump.port_a.m_flow(min = 
    -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure pump.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy pump.port_a.h_outflow(
    start = pump.h_a_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction pump.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty pump.port_a.C_outflow[0](
    start = fill(1.0, size(pump.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate pump.port_b.m_flow(max = 
    1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure pump.port_b.p(start = 
    pump.p_b_start, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy pump.port_b.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction pump.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty pump.port_b.C_outflow[0](
    start = fill(1.0, size(pump.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Efficiency pump.eta_is "Isentropic or aerodynamic efficiency";
  Modelica.Media.Interfaces.Types.FixedPhase pump.state_a.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy pump.state_a.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density pump.state_a.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature pump.state_a.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure pump.state_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase pump.state_b.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy pump.state_b.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density pump.state_b.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature pump.state_b.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure pump.state_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.SI.PressureDifference pump.dp(start = pump.p_b_start-
    pump.p_a_start) "Pressure change";
  Modelica.Units.SI.MassFlowRate pump.m_flow(start = pump.m_flow_start) 
    "Mass flow rate";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy pump.dh_ideal(start = 
    100000.0, nominal = 500000.0) "Ideal enthalpy change";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy pump.dh(start = 100000.0, 
    nominal = 500000.0) "Actual enthalpy change";
  Modelica.Units.SI.Power pump.W "Pumping power required";
  Modelica.Units.SI.Power pump.W_ideal = pump.dh_ideal*pump.m_flow 
    "Ideal pumping power required";
  Modelica.Units.SI.Power pump.Ub "Energy balance";
  Modelica.Units.SI.Pressure pump.p "Outlet pressure (port_b.p)";
  Modelica.Units.SI.Pressure pump.p_internal;
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate pump1.port_a.m_flow(
    min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure pump1.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy pump1.port_a.h_outflow(
    start = pump1.h_a_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction pump1.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty pump1.port_a.C_outflow[0](
    start = fill(1.0, size(pump1.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate pump1.port_b.m_flow(
    max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure pump1.port_b.p(start = 
    pump1.p_b_start, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy pump1.port_b.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction pump1.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty pump1.port_b.C_outflow[0](
    start = fill(1.0, size(pump1.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Efficiency pump1.eta_is "Isentropic or aerodynamic efficiency";
  Modelica.Media.Interfaces.Types.FixedPhase pump1.state_a.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy pump1.state_a.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density pump1.state_a.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature pump1.state_a.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure pump1.state_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase pump1.state_b.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy pump1.state_b.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density pump1.state_b.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature pump1.state_b.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure pump1.state_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.SI.PressureDifference pump1.dp(start = pump1.p_b_start-
    pump1.p_a_start) "Pressure change";
  Modelica.Units.SI.MassFlowRate pump1.m_flow(start = pump1.m_flow_start) 
    "Mass flow rate";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy pump1.dh_ideal(start = 
    100000.0, nominal = 500000.0) "Ideal enthalpy change";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy pump1.dh(start = 100000.0, 
    nominal = 500000.0) "Actual enthalpy change";
  Modelica.Units.SI.Power pump1.W "Pumping power required";
  Modelica.Units.SI.Power pump1.W_ideal = pump1.dh_ideal*pump1.m_flow 
    "Ideal pumping power required";
  Modelica.Units.SI.Power pump1.Ub "Energy balance";
  Modelica.Units.SI.Pressure pump1.p "Outlet pressure (port_b.p)";
  Modelica.Units.SI.Pressure pump1.p_internal;
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate OFWH_1.port_a.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure OFWH_1.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy OFWH_1.port_a.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction OFWH_1.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty OFWH_1.port_a.C_outflow[0](
    start = fill(1.0, size(OFWH_1.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate OFWH_1.port_b.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure OFWH_1.port_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy OFWH_1.port_b.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction OFWH_1.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty OFWH_1.port_b.C_outflow[0](
    start = fill(1.0, size(OFWH_1.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Volume OFWH_1.V(min = 0.0) = OFWH_1.geometry.V "Volume";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    OFWH_1.medium.p(start = OFWH_1.p_start, nominal = 100000.0, unit = "Pa", 
    displayUnit = "bar", min = 0.0, stateSelect = StateSelect.prefer) 
    "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    OFWH_1.medium.Xi[0](start = OFWH_1.X_start[1:0], unit = "1", min = 0.0, 
    max = 1.0) "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    OFWH_1.medium.h(start = (if  not OFWH_1.use_T_start then OFWH_1.h_start
     else Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique1(
    OFWH_1.p_start, OFWH_1.T_start, OFWH_1.X_start[1:0], 0)), unit = "J/kg", 
    stateSelect = StateSelect.prefer) "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density OFWH_1.medium.d(start = (if 
    OFWH_1.use_T_start then Modelica.Media.Water.WaterIF97_ph.density_pTX_Unique22
    (OFWH_1.p_start, OFWH_1.T_start, OFWH_1.X_start[1:0]) else Modelica.Media.Water.WaterIF97_ph.density_phX_Unique23
    (OFWH_1.p_start, OFWH_1.h_start, OFWH_1.X_start[1:0], 0)), nominal = 500.0) 
    "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature OFWH_1.medium.T(start = (if 
    OFWH_1.use_T_start then OFWH_1.T_start else Modelica.Media.Water.WaterIF97_ph.temperature_phX_Unique24
    (OFWH_1.p_start, OFWH_1.h_start, OFWH_1.X_start[1:0], 0)), nominal = 500.0, 
    min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction OFWH_1.medium.X[1](start = 
    OFWH_1.X_start) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy OFWH_1.medium.u 
    "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity OFWH_1.medium.R_s 
    "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass OFWH_1.medium.MM "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase OFWH_1.medium.state.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy OFWH_1.medium.state.h(
    start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density OFWH_1.medium.state.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature OFWH_1.medium.state.T(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure OFWH_1.medium.state.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC OFWH_1.medium.T_degC = Modelica.Units.Conversions.to_degC
    (OFWH_1.medium.T) "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar OFWH_1.medium.p_bar = Modelica.Units.Conversions.to_bar
    (OFWH_1.medium.p) "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure OFWH_1.medium.sat.psat(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature OFWH_1.medium.sat.Tsat(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer OFWH_1.medium.phase(start = 1, fixed = false, min = 0.0, max = 2.0) 
    "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Units.SI.Mass OFWH_1.m "Mass";
  Modelica.Units.SI.InternalEnergy OFWH_1.U "Internal energy";
  Modelica.Units.SI.Mass OFWH_1.mXi[0] "Species mass";
  TRANSFORM.Units.ExtraPropertyExtrinsic OFWH_1.mC[0] "Trace substance extrinsic value";
  TRANSFORM.Units.ExtraPropertyExtrinsic OFWH_1.mC_scaled[0] "Scaled trace substance for improved numerical stability";
  TRANSFORM.Units.ExtraProperty OFWH_1.C[0](start = OFWH_1.C_start, 
    stateSelect = StateSelect.prefer) "Trace substance mass-specific value";
  Modelica.Units.SI.MassFlowRate OFWH_1.mb = OFWH_1.port_a.m_flow+
    OFWH_1.port_b.m_flow "Mass flow rate source/sinks within volumes";
  Modelica.Units.SI.HeatFlowRate OFWH_1.Ub = OFWH_1.port_a.m_flow*actualStream(
    OFWH_1.port_a.h_outflow)+OFWH_1.port_b.m_flow*actualStream(OFWH_1.port_b.h_outflow)
    +OFWH_1.Q_flow_internal+OFWH_1.Q_gen "Energy source/sinks within volumes (e.g., ohmic heating, external convection)";
  Modelica.Units.SI.MassFlowRate OFWH_1.mXib[0] = OFWH_1.port_a.m_flow*
    actualStream(OFWH_1.port_a.Xi_outflow)+OFWH_1.port_b.m_flow*actualStream(
    OFWH_1.port_b.Xi_outflow) "Species mass flow rates source/sinks within volumes";
  TRANSFORM.Units.ExtraPropertyFlowRate OFWH_1.mCb[0] = OFWH_1.port_a.m_flow*
    actualStream(OFWH_1.port_a.C_outflow)+OFWH_1.port_b.m_flow*actualStream(
    OFWH_1.port_b.C_outflow)+OFWH_1.mC_flow_internal+OFWH_1.mC_gen 
    "Trace flow rate source/sinks within volumes (e.g., chemical reactions, external convection)";
  Modelica.Units.SI.Volume OFWH_1.geometry.V = 2 "Volume";
  Modelica.Units.SI.Angle OFWH_1.geometry.angle(min = -1.5807963267948966, 
    max = 1.5807963267948966) = 0.0 "Vertical angle from the horizontal (-pi/2 <= x <= pi/2)";
  Modelica.Units.SI.Length OFWH_1.geometry.dheight = 0*sin(OFWH_1.geometry.angle)
     "Height(port_b) - Height(port_a)";
  Modelica.Units.SI.Length OFWH_1.geometry.height_a = 0 "Elevation at port_a: Reference value only. No impact on calculations.";
  Modelica.Units.SI.Length OFWH_1.geometry.height_b = OFWH_1.geometry.height_a+
    OFWH_1.geometry.dheight "Elevation at port_b: Reference value only. No impact on calculations.";
  Modelica.Units.SI.Acceleration OFWH_1.g_n = 9.80665 "Gravitational acceleration";
  Modelica.Units.SI.HeatFlowRate OFWH_1.Q_gen = 0 "Internal heat generation";
  TRANSFORM.Units.ExtraPropertyFlowRate OFWH_1.mC_gen[0] = fill(0, 0) 
    "Internal trace mass generation";
  Modelica.Units.SI.HeatFlowRate OFWH_1.Q_flow_internal;
  TRANSFORM.Units.ExtraPropertyFlowRate OFWH_1.mC_flow_internal[0];
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate HPT_bypass_valve.port_a.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure HPT_bypass_valve.port_a.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy HPT_bypass_valve.port_a.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction HPT_bypass_valve.port_a.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty HPT_bypass_valve.port_a.C_outflow
    [0](start = fill(1.0, size(HPT_bypass_valve.port_a.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate HPT_bypass_valve.port_b.m_flow
    (max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure HPT_bypass_valve.port_b.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy HPT_bypass_valve.port_b.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction HPT_bypass_valve.port_b.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty HPT_bypass_valve.port_b.C_outflow
    [0](start = fill(1.0, size(HPT_bypass_valve.port_b.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate HPT_bypass_valve.m_flow(
    start = HPT_bypass_valve.m_flow_start, min = -1E+60) "Mass flow rate in design flow direction";
  Modelica.Units.SI.Pressure HPT_bypass_valve.dp(start = HPT_bypass_valve.dp_start)
     "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
  Modelica.Units.SI.VolumeFlowRate HPT_bypass_valve.V_flow = HPT_bypass_valve.m_flow
    /Modelica.Fluid.Utilities.regStep(HPT_bypass_valve.m_flow, Modelica.Media.Water.WaterIF97_ph.density_Unique20
    (
    HPT_bypass_valve.state_a), Modelica.Media.Water.WaterIF97_ph.density_Unique20
    (
    HPT_bypass_valve.state_b), HPT_bypass_valve.m_flow_small) "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";
  Modelica.Media.Interfaces.Types.Temperature HPT_bypass_valve.port_a_T(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) = Modelica.Fluid.Utilities.regStep
    (HPT_bypass_valve.port_a.m_flow, Modelica.Media.Water.WaterIF97_ph.temperature_Unique25
    (
    HPT_bypass_valve.state_a), Modelica.Media.Water.WaterIF97_ph.temperature_Unique25
    (
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(HPT_bypass_valve.port_a.p,
       HPT_bypass_valve.port_a.h_outflow, HPT_bypass_valve.port_a.Xi_outflow, 0,
       0)), HPT_bypass_valve.m_flow_small) "Temperature close to port_a, if show_T = true";
  Modelica.Media.Interfaces.Types.Temperature HPT_bypass_valve.port_b_T(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) = Modelica.Fluid.Utilities.regStep
    (HPT_bypass_valve.port_b.m_flow, Modelica.Media.Water.WaterIF97_ph.temperature_Unique25
    (
    HPT_bypass_valve.state_b), Modelica.Media.Water.WaterIF97_ph.temperature_Unique25
    (
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(HPT_bypass_valve.port_b.p,
       HPT_bypass_valve.port_b.h_outflow, HPT_bypass_valve.port_b.Xi_outflow, 0,
       0)), HPT_bypass_valve.m_flow_small) "Temperature close to port_b, if show_T = true";
  Modelica.Media.Interfaces.Types.FixedPhase HPT_bypass_valve.state_a.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy HPT_bypass_valve.state_a.h(
    start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density HPT_bypass_valve.state_a.d(start = 150,
     nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature HPT_bypass_valve.state_a.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure HPT_bypass_valve.state_a.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase HPT_bypass_valve.state_b.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy HPT_bypass_valve.state_b.h(
    start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density HPT_bypass_valve.state_b.d(start = 150,
     nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature HPT_bypass_valve.state_b.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure HPT_bypass_valve.state_b.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Blocks.Interfaces.RealInput HPT_bypass_valve.opening(min = 0.0, 
    max = 1.0) "=1: completely open, =0: completely closed";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate OFWH_2.port_a.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure OFWH_2.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy OFWH_2.port_a.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction OFWH_2.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty OFWH_2.port_a.C_outflow[0](
    start = fill(1.0, size(OFWH_2.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate OFWH_2.port_b.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure OFWH_2.port_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy OFWH_2.port_b.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction OFWH_2.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty OFWH_2.port_b.C_outflow[0](
    start = fill(1.0, size(OFWH_2.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Volume OFWH_2.V(min = 0.0) = OFWH_2.geometry.V "Volume";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    OFWH_2.medium.p(start = OFWH_2.p_start, nominal = 100000.0, unit = "Pa", 
    displayUnit = "bar", min = 0.0, stateSelect = StateSelect.prefer) 
    "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    OFWH_2.medium.Xi[0](start = OFWH_2.X_start[1:0], unit = "1", min = 0.0, 
    max = 1.0) "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    OFWH_2.medium.h(start = (if  not OFWH_2.use_T_start then OFWH_2.h_start
     else Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique1(
    OFWH_2.p_start, OFWH_2.T_start, OFWH_2.X_start[1:0], 0)), unit = "J/kg", 
    stateSelect = StateSelect.prefer) "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density OFWH_2.medium.d(start = (if 
    OFWH_2.use_T_start then Modelica.Media.Water.WaterIF97_ph.density_pTX_Unique22
    (OFWH_2.p_start, OFWH_2.T_start, OFWH_2.X_start[1:0]) else Modelica.Media.Water.WaterIF97_ph.density_phX_Unique23
    (OFWH_2.p_start, OFWH_2.h_start, OFWH_2.X_start[1:0], 0)), nominal = 500.0) 
    "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature OFWH_2.medium.T(start = (if 
    OFWH_2.use_T_start then OFWH_2.T_start else Modelica.Media.Water.WaterIF97_ph.temperature_phX_Unique24
    (OFWH_2.p_start, OFWH_2.h_start, OFWH_2.X_start[1:0], 0)), nominal = 500.0, 
    min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction OFWH_2.medium.X[1](start = 
    OFWH_2.X_start) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy OFWH_2.medium.u 
    "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity OFWH_2.medium.R_s 
    "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass OFWH_2.medium.MM "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase OFWH_2.medium.state.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy OFWH_2.medium.state.h(
    start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density OFWH_2.medium.state.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature OFWH_2.medium.state.T(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure OFWH_2.medium.state.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC OFWH_2.medium.T_degC = Modelica.Units.Conversions.to_degC
    (OFWH_2.medium.T) "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar OFWH_2.medium.p_bar = Modelica.Units.Conversions.to_bar
    (OFWH_2.medium.p) "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure OFWH_2.medium.sat.psat(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature OFWH_2.medium.sat.Tsat(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer OFWH_2.medium.phase(start = 1, fixed = false, min = 0.0, max = 2.0) 
    "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Units.SI.Mass OFWH_2.m "Mass";
  Modelica.Units.SI.InternalEnergy OFWH_2.U "Internal energy";
  Modelica.Units.SI.Mass OFWH_2.mXi[0] "Species mass";
  TRANSFORM.Units.ExtraPropertyExtrinsic OFWH_2.mC[0] "Trace substance extrinsic value";
  TRANSFORM.Units.ExtraPropertyExtrinsic OFWH_2.mC_scaled[0] "Scaled trace substance for improved numerical stability";
  TRANSFORM.Units.ExtraProperty OFWH_2.C[0](start = OFWH_2.C_start, 
    stateSelect = StateSelect.prefer) "Trace substance mass-specific value";
  Modelica.Units.SI.MassFlowRate OFWH_2.mb = OFWH_2.port_a.m_flow+
    OFWH_2.port_b.m_flow "Mass flow rate source/sinks within volumes";
  Modelica.Units.SI.HeatFlowRate OFWH_2.Ub = OFWH_2.port_a.m_flow*actualStream(
    OFWH_2.port_a.h_outflow)+OFWH_2.port_b.m_flow*actualStream(OFWH_2.port_b.h_outflow)
    +OFWH_2.Q_flow_internal+OFWH_2.Q_gen "Energy source/sinks within volumes (e.g., ohmic heating, external convection)";
  Modelica.Units.SI.MassFlowRate OFWH_2.mXib[0] = OFWH_2.port_a.m_flow*
    actualStream(OFWH_2.port_a.Xi_outflow)+OFWH_2.port_b.m_flow*actualStream(
    OFWH_2.port_b.Xi_outflow) "Species mass flow rates source/sinks within volumes";
  TRANSFORM.Units.ExtraPropertyFlowRate OFWH_2.mCb[0] = OFWH_2.port_a.m_flow*
    actualStream(OFWH_2.port_a.C_outflow)+OFWH_2.port_b.m_flow*actualStream(
    OFWH_2.port_b.C_outflow)+OFWH_2.mC_flow_internal+OFWH_2.mC_gen 
    "Trace flow rate source/sinks within volumes (e.g., chemical reactions, external convection)";
  Modelica.Units.SI.Volume OFWH_2.geometry.V = 2 "Volume";
  Modelica.Units.SI.Angle OFWH_2.geometry.angle(min = -1.5807963267948966, 
    max = 1.5807963267948966) = 0.0 "Vertical angle from the horizontal (-pi/2 <= x <= pi/2)";
  Modelica.Units.SI.Length OFWH_2.geometry.dheight = 0*sin(OFWH_2.geometry.angle)
     "Height(port_b) - Height(port_a)";
  Modelica.Units.SI.Length OFWH_2.geometry.height_a = 0 "Elevation at port_a: Reference value only. No impact on calculations.";
  Modelica.Units.SI.Length OFWH_2.geometry.height_b = OFWH_2.geometry.height_a+
    OFWH_2.geometry.dheight "Elevation at port_b: Reference value only. No impact on calculations.";
  Modelica.Units.SI.Acceleration OFWH_2.g_n = 9.80665 "Gravitational acceleration";
  Modelica.Units.SI.HeatFlowRate OFWH_2.Q_gen = 0 "Internal heat generation";
  TRANSFORM.Units.ExtraPropertyFlowRate OFWH_2.mC_gen[0] = fill(0, 0) 
    "Internal trace mass generation";
  Modelica.Units.SI.HeatFlowRate OFWH_2.Q_flow_internal;
  TRANSFORM.Units.ExtraPropertyFlowRate OFWH_2.mC_flow_internal[0];
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate FWCP.port_a.m_flow(min = 
    -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure FWCP.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy FWCP.port_a.h_outflow(
    start = FWCP.h_a_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction FWCP.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty FWCP.port_a.C_outflow[0](
    start = fill(1.0, size(FWCP.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate FWCP.port_b.m_flow(max = 
    1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure FWCP.port_b.p(start = 
    FWCP.p_b_start, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy FWCP.port_b.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction FWCP.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty FWCP.port_b.C_outflow[0](
    start = fill(1.0, size(FWCP.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Efficiency FWCP.eta_is "Isentropic or aerodynamic efficiency";
  Modelica.Media.Interfaces.Types.FixedPhase FWCP.state_a.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy FWCP.state_a.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density FWCP.state_a.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature FWCP.state_a.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure FWCP.state_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase FWCP.state_b.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy FWCP.state_b.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density FWCP.state_b.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature FWCP.state_b.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure FWCP.state_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.SI.PressureDifference FWCP.dp(start = FWCP.p_b_start-
    FWCP.p_a_start) "Pressure change";
  Modelica.Units.SI.MassFlowRate FWCP.m_flow(start = FWCP.m_flow_start) 
    "Mass flow rate";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy FWCP.dh_ideal(start = 
    100000.0, nominal = 500000.0) "Ideal enthalpy change";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy FWCP.dh(start = 100000.0, 
    nominal = 500000.0) "Actual enthalpy change";
  Modelica.Units.SI.Power FWCP.W "Pumping power required";
  Modelica.Units.SI.Power FWCP.W_ideal = FWCP.dh_ideal*FWCP.m_flow 
    "Ideal pumping power required";
  Modelica.Units.SI.Power FWCP.Ub "Energy balance";
  Modelica.Units.SI.MassFlowRate FWCP.m_flow_internal;
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate TCV.port_a.m_flow(min = 
    -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure TCV.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy TCV.port_a.h_outflow(start = 
    100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction TCV.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty TCV.port_a.C_outflow[0](start = 
    fill(1.0, size(TCV.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate TCV.port_b.m_flow(max = 
    1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure TCV.port_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy TCV.port_b.h_outflow(start = 
    100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction TCV.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty TCV.port_b.C_outflow[0](start = 
    fill(1.0, size(TCV.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate TCV.m_flow(start = 
    TCV.m_flow_start, min = -1E+60) "Mass flow rate in design flow direction";
  Modelica.Units.SI.Pressure TCV.dp(start = TCV.dp_start) "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
  Modelica.Units.SI.VolumeFlowRate TCV.V_flow = TCV.m_flow/Modelica.Fluid.Utilities.regStep
    (TCV.m_flow, Modelica.Media.Water.WaterIF97_ph.density_Unique20(
    TCV.state_a), Modelica.Media.Water.WaterIF97_ph.density_Unique20(
    TCV.state_b), TCV.m_flow_small) "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";
  Modelica.Media.Interfaces.Types.Temperature TCV.port_a_T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) = Modelica.Fluid.Utilities.regStep
    (TCV.port_a.m_flow, Modelica.Media.Water.WaterIF97_ph.temperature_Unique25(
    TCV.state_a), Modelica.Media.Water.WaterIF97_ph.temperature_Unique25(
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(TCV.port_a.p, 
      TCV.port_a.h_outflow, TCV.port_a.Xi_outflow, 0, 0)), TCV.m_flow_small) 
    "Temperature close to port_a, if show_T = true";
  Modelica.Media.Interfaces.Types.Temperature TCV.port_b_T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) = Modelica.Fluid.Utilities.regStep
    (TCV.port_b.m_flow, Modelica.Media.Water.WaterIF97_ph.temperature_Unique25(
    TCV.state_b), Modelica.Media.Water.WaterIF97_ph.temperature_Unique25(
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(TCV.port_b.p, 
      TCV.port_b.h_outflow, TCV.port_b.Xi_outflow, 0, 0)), TCV.m_flow_small) 
    "Temperature close to port_b, if show_T = true";
  Modelica.Media.Interfaces.Types.FixedPhase TCV.state_a.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy TCV.state_a.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density TCV.state_a.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature TCV.state_a.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure TCV.state_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase TCV.state_b.phase "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy TCV.state_b.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density TCV.state_b.d(start = 150, nominal = 
    500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature TCV.state_b.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure TCV.state_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Blocks.Interfaces.RealInput TCV.opening(min = 0.0, max = 1.0) 
    "=1: completely open, =0: completely closed";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate Feed_T.port.m_flow(min = 
    -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure Feed_T.port.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy Feed_T.port.h_outflow(
    start = 84013.0581525969, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction Feed_T.port.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty Feed_T.port.C_outflow[0](
    start = fill(1.0, size(Feed_T.port.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Real Feed_T.var = Feed_T.T "Variable to be converted";
  Real Feed_T.y = Feed_T.iconUnit_Unique35(Feed_T.var) "Icon display";
  Modelica.Blocks.Interfaces.RealOutput Feed_T.T(unit = "K", displayUnit = 
    "degC", min = 0.0) "Temperature in port medium";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate Steam_T.port.m_flow(
    min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure Steam_T.port.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy Steam_T.port.h_outflow(
    start = 84013.0581525969, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction Steam_T.port.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty Steam_T.port.C_outflow[0](
    start = fill(1.0, size(Steam_T.port.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Real Steam_T.var = Steam_T.T "Variable to be converted";
  Real Steam_T.y = Steam_T.iconUnit_Unique40(Steam_T.var) "Icon display";
  Modelica.Blocks.Interfaces.RealOutput Steam_T.T(unit = "K", displayUnit = 
    "degC", min = 0.0) "Temperature in port medium";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate sensor_p.port.m_flow(
    min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure sensor_p.port.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy sensor_p.port.h_outflow(
    start = 84013.0581525969, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction sensor_p.port.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty sensor_p.port.C_outflow[0](
    start = fill(1.0, size(sensor_p.port.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Real sensor_p.var = sensor_p.p "Variable to be converted";
  Real sensor_p.y = sensor_p.iconUnit_Unique41(sensor_p.var) "Icon display";
  Modelica.Blocks.Interfaces.RealOutput sensor_p.p(unit = "Pa", displayUnit = 
    "bar", min = 0.0) "Pressure at port";
  Real sensorW.var = sensorW.W "Variable to be converted";
  Real sensorW.y = sensorW.iconUnit_Unique42(sensorW.var) "Icon display";
  Modelica.Units.SI.Power sensorW.port_a.W "Active power";
  Modelica.Units.SI.Frequency sensorW.port_a.f "Frequency";
  Modelica.Units.SI.Power sensorW.port_b.W "Active power";
  Modelica.Units.SI.Frequency sensorW.port_b.f "Frequency";
  Modelica.Blocks.Interfaces.RealOutput sensorW.W "Power flowing from port_a to port_b";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate port_a_cond.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure port_a_cond.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy port_a_cond.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction port_a_cond.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty port_a_cond.C_outflow[0](
    start = fill(1.0, size(port_a_cond.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate delay2.port_a.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2.port_a.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction delay2.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty delay2.port_a.C_outflow[0](
    start = fill(1.0, size(delay2.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate delay2.port_b.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2.port_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2.port_b.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction delay2.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty delay2.port_b.C_outflow[0](
    start = fill(1.0, size(delay2.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate delay2.sensor_p.port.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2.sensor_p.port.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2.sensor_p.port.h_outflow
    (start = 84013.0581525969, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction delay2.sensor_p.port.Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty delay2.sensor_p.port.C_outflow[0]
    (start = fill(1.0, size(delay2.sensor_p.port.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Real delay2.sensor_p.var = delay2.sensor_p.p "Variable to be converted";
  Real delay2.sensor_p.y = delay2.sensor_p.iconUnit_Unique43(delay2.sensor_p.var)
     "Icon display";
  Modelica.Blocks.Interfaces.RealOutput delay2.sensor_p.p(unit = "Pa", 
    displayUnit = "bar", min = 0.0) "Pressure at port";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate delay2.sensor_m_flow.port_a.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2.sensor_m_flow.port_a.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2.sensor_m_flow.port_a.h_outflow
    (start = delay2.sensor_m_flow.h_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction delay2.sensor_m_flow.port_a.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty delay2.sensor_m_flow.port_a.C_outflow
    [0](start = fill(1.0, size(delay2.sensor_m_flow.port_a.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate delay2.sensor_m_flow.port_b.m_flow
    (max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2.sensor_m_flow.port_b.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2.sensor_m_flow.port_b.h_outflow
    (start = delay2.sensor_m_flow.h_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction delay2.sensor_m_flow.port_b.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty delay2.sensor_m_flow.port_b.C_outflow
    [0](start = fill(1.0, size(delay2.sensor_m_flow.port_b.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Real delay2.sensor_m_flow.var = delay2.sensor_m_flow.m_flow "Variable to be converted";
  Real delay2.sensor_m_flow.y = delay2.sensor_m_flow.iconUnit_Unique44(
    delay2.sensor_m_flow.var) "Icon display";
  Modelica.Blocks.Interfaces.RealOutput delay2.sensor_m_flow.m_flow(unit = 
    "kg/s") "Mass flow rate from port_a to port_b";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate delay2.sensor_h.port.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2.sensor_h.port.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2.sensor_h.port.h_outflow
    (start = 84013.0581525969, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction delay2.sensor_h.port.Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty delay2.sensor_h.port.C_outflow[0]
    (start = fill(1.0, size(delay2.sensor_h.port.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Real delay2.sensor_h.var = delay2.sensor_h.h_out "Variable to be converted";
  Real delay2.sensor_h.y = delay2.sensor_h.iconUnit_Unique45(delay2.sensor_h.var)
     "Icon display";
  Modelica.Blocks.Interfaces.RealOutput delay2.sensor_h.h_out(unit = "J/kg") 
    "Specific enthalpy in port medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    delay2.boundary.medium.p(nominal = 100000.0, unit = "Pa", displayUnit = 
    "bar", min = 0.0) "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    delay2.boundary.medium.Xi[0](start = {}, unit = "1", min = 0.0, max = 1.0) 
    "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    delay2.boundary.medium.h(unit = "J/kg") "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density delay2.boundary.medium.d(start = 150, 
    nominal = 500.0) "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature delay2.boundary.medium.T(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction delay2.boundary.medium.X[1](
    start = {1.0}) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy delay2.boundary.medium.u
     "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity delay2.boundary.medium.R_s
     "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass delay2.boundary.medium.MM 
    "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase delay2.boundary.medium.state.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2.boundary.medium.state.h
    (start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density delay2.boundary.medium.state.d(
    start = 150, nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature delay2.boundary.medium.state.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2.boundary.medium.state.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC delay2.boundary.medium.T_degC = 
    Modelica.Units.Conversions.to_degC(delay2.boundary.medium.T) 
    "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar delay2.boundary.medium.p_bar = 
    Modelica.Units.Conversions.to_bar(delay2.boundary.medium.p) "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2.boundary.medium.sat.psat
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature delay2.boundary.medium.sat.Tsat(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer delay2.boundary.medium.phase(start = 1, fixed = false, min = 0.0, 
    max = 2.0) "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate delay2.boundary.ports[1].m_flow
    (min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2.boundary.ports[1].p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2.boundary.ports[1].h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction delay2.boundary.ports[1].Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty delay2.boundary.ports[1].C_outflow
    [0](start = fill(1.0, size(delay2.boundary.ports[1].C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealInput delay2.boundary.p_in "Prescribed boundary pressure";
  Modelica.Blocks.Interfaces.RealInput delay2.boundary.p_in_internal 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput delay2.boundary.h_in_internal 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput delay2.boundary.X_in_internal[1] 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput delay2.boundary.C_in_internal[0] 
    "Needed to connect to conditional connector";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    delay2.boundary1.medium.p(nominal = 100000.0, unit = "Pa", displayUnit = 
    "bar", min = 0.0) "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    delay2.boundary1.medium.Xi[0](start = {}, unit = "1", min = 0.0, max = 1.0) 
    "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    delay2.boundary1.medium.h(unit = "J/kg") "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density delay2.boundary1.medium.d(start = 150,
     nominal = 500.0) "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature delay2.boundary1.medium.T(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction delay2.boundary1.medium.X[1](
    start = {1.0}) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy delay2.boundary1.medium.u
     "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity delay2.boundary1.medium.R_s
     "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass delay2.boundary1.medium.MM 
    "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase delay2.boundary1.medium.state.phase
     "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2.boundary1.medium.state.h
    (start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density delay2.boundary1.medium.state.d(
    start = 150, nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature delay2.boundary1.medium.state.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2.boundary1.medium.state.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC delay2.boundary1.medium.T_degC = 
    Modelica.Units.Conversions.to_degC(delay2.boundary1.medium.T) 
    "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar delay2.boundary1.medium.p_bar = 
    Modelica.Units.Conversions.to_bar(delay2.boundary1.medium.p) 
    "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2.boundary1.medium.sat.psat
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature delay2.boundary1.medium.sat.Tsat(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer delay2.boundary1.medium.phase(start = 1, fixed = false, min = 0.0, 
    max = 2.0) "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate delay2.boundary1.ports[1].m_flow
    (min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2.boundary1.ports[1].p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2.boundary1.ports[1].h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction delay2.boundary1.ports[1].Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty delay2.boundary1.ports[1].C_outflow
    [0](start = fill(1.0, size(delay2.boundary1.ports[1].C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealInput delay2.boundary1.m_flow_in 
    "Prescribed mass flow rate";
  Modelica.Blocks.Interfaces.RealInput delay2.boundary1.h_in "Prescribed fluid specific enthalpy";
  Modelica.Blocks.Interfaces.RealInput delay2.boundary1.m_flow_in_internal 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput delay2.boundary1.h_in_internal 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput delay2.boundary1.X_in_internal[1] 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput delay2.boundary1.C_in_internal[0] 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput delay2.limiter1.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput delay2.limiter1.y "Connector of Real output signal";
  Real delay2.limiter1.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealInput delay2.limiter2.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput delay2.limiter2.y "Connector of Real output signal";
  Real delay2.limiter2.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealInput delay2.limiter.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput delay2.limiter.y "Connector of Real output signal";
  Real delay2.limiter.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate delay2_2.port_a.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2_2.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2_2.port_a.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction delay2_2.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty delay2_2.port_a.C_outflow[0](
    start = fill(1.0, size(delay2_2.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate delay2_2.port_b.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2_2.port_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2_2.port_b.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction delay2_2.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty delay2_2.port_b.C_outflow[0](
    start = fill(1.0, size(delay2_2.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate delay2_2.sensor_p.port.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2_2.sensor_p.port.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2_2.sensor_p.port.h_outflow
    (start = 84013.0581525969, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction delay2_2.sensor_p.port.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty delay2_2.sensor_p.port.C_outflow
    [0](start = fill(1.0, size(delay2_2.sensor_p.port.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Real delay2_2.sensor_p.var = delay2_2.sensor_p.p "Variable to be converted";
  Real delay2_2.sensor_p.y = delay2_2.sensor_p.iconUnit_Unique46(
    delay2_2.sensor_p.var) "Icon display";
  Modelica.Blocks.Interfaces.RealOutput delay2_2.sensor_p.p(unit = "Pa", 
    displayUnit = "bar", min = 0.0) "Pressure at port";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate delay2_2.sensor_m_flow.port_a.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2_2.sensor_m_flow.port_a.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2_2.sensor_m_flow.port_a.h_outflow
    (start = delay2_2.sensor_m_flow.h_start, nominal = 500000.0) 
    "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction delay2_2.sensor_m_flow.port_a.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty delay2_2.sensor_m_flow.port_a.C_outflow
    [0](start = fill(1.0, size(delay2_2.sensor_m_flow.port_a.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate delay2_2.sensor_m_flow.port_b.m_flow
    (max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2_2.sensor_m_flow.port_b.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2_2.sensor_m_flow.port_b.h_outflow
    (start = delay2_2.sensor_m_flow.h_start, nominal = 500000.0) 
    "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction delay2_2.sensor_m_flow.port_b.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty delay2_2.sensor_m_flow.port_b.C_outflow
    [0](start = fill(1.0, size(delay2_2.sensor_m_flow.port_b.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Real delay2_2.sensor_m_flow.var = delay2_2.sensor_m_flow.m_flow 
    "Variable to be converted";
  Real delay2_2.sensor_m_flow.y = delay2_2.sensor_m_flow.iconUnit_Unique47(
    delay2_2.sensor_m_flow.var) "Icon display";
  Modelica.Blocks.Interfaces.RealOutput delay2_2.sensor_m_flow.m_flow(unit = 
    "kg/s") "Mass flow rate from port_a to port_b";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate delay2_2.sensor_h.port.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2_2.sensor_h.port.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2_2.sensor_h.port.h_outflow
    (start = 84013.0581525969, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction delay2_2.sensor_h.port.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty delay2_2.sensor_h.port.C_outflow
    [0](start = fill(1.0, size(delay2_2.sensor_h.port.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Real delay2_2.sensor_h.var = delay2_2.sensor_h.h_out "Variable to be converted";
  Real delay2_2.sensor_h.y = delay2_2.sensor_h.iconUnit_Unique48(
    delay2_2.sensor_h.var) "Icon display";
  Modelica.Blocks.Interfaces.RealOutput delay2_2.sensor_h.h_out(unit = "J/kg") 
    "Specific enthalpy in port medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    delay2_2.boundary.medium.p(nominal = 100000.0, unit = "Pa", displayUnit = 
    "bar", min = 0.0) "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    delay2_2.boundary.medium.Xi[0](start = {}, unit = "1", min = 0.0, max = 1.0)
     "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    delay2_2.boundary.medium.h(unit = "J/kg") "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density delay2_2.boundary.medium.d(start = 150,
     nominal = 500.0) "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature delay2_2.boundary.medium.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction delay2_2.boundary.medium.X[1](
    start = {1.0}) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy delay2_2.boundary.medium.u
     "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity delay2_2.boundary.medium.R_s
     "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass delay2_2.boundary.medium.MM 
    "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase delay2_2.boundary.medium.state.phase
     "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2_2.boundary.medium.state.h
    (start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density delay2_2.boundary.medium.state.d(
    start = 150, nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature delay2_2.boundary.medium.state.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2_2.boundary.medium.state.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC delay2_2.boundary.medium.T_degC = 
    Modelica.Units.Conversions.to_degC(delay2_2.boundary.medium.T) 
    "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar delay2_2.boundary.medium.p_bar = 
    Modelica.Units.Conversions.to_bar(delay2_2.boundary.medium.p) 
    "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2_2.boundary.medium.sat.psat
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature delay2_2.boundary.medium.sat.Tsat(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer delay2_2.boundary.medium.phase(start = 1, fixed = false, min = 0.0, 
    max = 2.0) "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate delay2_2.boundary.ports[1].m_flow
    (min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2_2.boundary.ports[1].p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2_2.boundary.ports[1].h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction delay2_2.boundary.ports[1].Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty delay2_2.boundary.ports[1].C_outflow
    [0](start = fill(1.0, size(delay2_2.boundary.ports[1].C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealInput delay2_2.boundary.p_in "Prescribed boundary pressure";
  Modelica.Blocks.Interfaces.RealInput delay2_2.boundary.p_in_internal 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput delay2_2.boundary.h_in_internal 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput delay2_2.boundary.X_in_internal[1] 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput delay2_2.boundary.C_in_internal[0] 
    "Needed to connect to conditional connector";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    delay2_2.boundary1.medium.p(nominal = 100000.0, unit = "Pa", displayUnit = 
    "bar", min = 0.0) "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    delay2_2.boundary1.medium.Xi[0](start = {}, unit = "1", min = 0.0, max = 1.0)
     "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    delay2_2.boundary1.medium.h(unit = "J/kg") "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density delay2_2.boundary1.medium.d(start = 150,
     nominal = 500.0) "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature delay2_2.boundary1.medium.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction delay2_2.boundary1.medium.X[1](
    start = {1.0}) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy delay2_2.boundary1.medium.u
     "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity delay2_2.boundary1.medium.R_s
     "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass delay2_2.boundary1.medium.MM 
    "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase delay2_2.boundary1.medium.state.phase
     "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2_2.boundary1.medium.state.h
    (start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density delay2_2.boundary1.medium.state.d(
    start = 150, nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature delay2_2.boundary1.medium.state.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2_2.boundary1.medium.state.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC delay2_2.boundary1.medium.T_degC = 
    Modelica.Units.Conversions.to_degC(delay2_2.boundary1.medium.T) 
    "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar delay2_2.boundary1.medium.p_bar = 
    Modelica.Units.Conversions.to_bar(delay2_2.boundary1.medium.p) 
    "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2_2.boundary1.medium.sat.psat
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature delay2_2.boundary1.medium.sat.Tsat
    (start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer delay2_2.boundary1.medium.phase(start = 1, fixed = false, min = 0.0, 
    max = 2.0) "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate delay2_2.boundary1.ports[1].m_flow
    (min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure delay2_2.boundary1.ports[1].p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy delay2_2.boundary1.ports[1].h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction delay2_2.boundary1.ports[1].Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty delay2_2.boundary1.ports[1].C_outflow
    [0](start = fill(1.0, size(delay2_2.boundary1.ports[1].C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealInput delay2_2.boundary1.m_flow_in 
    "Prescribed mass flow rate";
  Modelica.Blocks.Interfaces.RealInput delay2_2.boundary1.h_in "Prescribed fluid specific enthalpy";
  Modelica.Blocks.Interfaces.RealInput delay2_2.boundary1.m_flow_in_internal 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput delay2_2.boundary1.h_in_internal 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput delay2_2.boundary1.X_in_internal[1] 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput delay2_2.boundary1.C_in_internal[0] 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput delay2_2.limiter1.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput delay2_2.limiter1.y "Connector of Real output signal";
  Real delay2_2.limiter1.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealInput delay2_2.limiter2.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput delay2_2.limiter2.y "Connector of Real output signal";
  Real delay2_2.limiter2.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealInput delay2_2.limiter.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput delay2_2.limiter.y "Connector of Real output signal";
  Real delay2_2.limiter.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate sensor_m_flow.port_a.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure sensor_m_flow.port_a.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy sensor_m_flow.port_a.h_outflow
    (start = sensor_m_flow.h_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction sensor_m_flow.port_a.Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty sensor_m_flow.port_a.C_outflow[0]
    (start = fill(1.0, size(sensor_m_flow.port_a.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate sensor_m_flow.port_b.m_flow
    (max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure sensor_m_flow.port_b.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy sensor_m_flow.port_b.h_outflow
    (start = sensor_m_flow.h_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction sensor_m_flow.port_b.Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty sensor_m_flow.port_b.C_outflow[0]
    (start = fill(1.0, size(sensor_m_flow.port_b.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Real sensor_m_flow.var = sensor_m_flow.m_flow "Variable to be converted";
  Real sensor_m_flow.y = sensor_m_flow.iconUnit_Unique49(sensor_m_flow.var) 
    "Icon display";
  Modelica.Blocks.Interfaces.RealOutput sensor_m_flow.m_flow(unit = "kg/s") 
    "Mass flow rate from port_a to port_b";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate sensor_p1.port.m_flow(
    min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure sensor_p1.port.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy sensor_p1.port.h_outflow(
    start = 84013.0581525969, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction sensor_p1.port.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty sensor_p1.port.C_outflow[0](
    start = fill(1.0, size(sensor_p1.port.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Real sensor_p1.var = sensor_p1.p "Variable to be converted";
  Real sensor_p1.y = sensor_p1.iconUnit_Unique50(sensor_p1.var) "Icon display";
  Modelica.Blocks.Interfaces.RealOutput sensor_p1.p(unit = "Pa", displayUnit = 
    "bar", min = 0.0) "Pressure at port";
  Modelica.Blocks.Interfaces.RealOutput realExpression.y = 0.6939 
    "Value of Real output";
  Modelica.Blocks.Interfaces.RealInput switch1.u1 "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.BooleanInput switch1.u2 "Connector of Boolean input signal";
  Modelica.Blocks.Interfaces.RealInput switch1.u3 "Connector of second Real input signal";
  Modelica.Blocks.Interfaces.RealOutput switch1.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.BooleanOutput booleanStep1.y "Connector of Boolean output signal";

// Equations and algorithms

  // Component CS.FeedPump_PID.addP
  // class Modelica.Blocks.Math.Add
  equation
    CS.FeedPump_PID.addP.y = CS.FeedPump_PID.addP.k1*CS.FeedPump_PID.addP.u1+
      CS.FeedPump_PID.addP.k2*CS.FeedPump_PID.addP.u2;

  // Component CS.FeedPump_PID.P
  // class Modelica.Blocks.Math.Gain
  equation
    CS.FeedPump_PID.P.y = CS.FeedPump_PID.P.k*CS.FeedPump_PID.P.u;

  // Component CS.FeedPump_PID.gainPID
  // class Modelica.Blocks.Math.Gain
  equation
    CS.FeedPump_PID.gainPID.y = CS.FeedPump_PID.gainPID.k*CS.FeedPump_PID.gainPID.u;

  // Component CS.FeedPump_PID.addPID
  // class Modelica.Blocks.Math.Add3
  equation
    CS.FeedPump_PID.addPID.y = CS.FeedPump_PID.addPID.k1*CS.FeedPump_PID.addPID.u1
      +CS.FeedPump_PID.addPID.k2*CS.FeedPump_PID.addPID.u2+CS.FeedPump_PID.addPID.k3
      *CS.FeedPump_PID.addPID.u3;

  // Component CS.FeedPump_PID.limiter
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(CS.FeedPump_PID.limiter.uMax >= CS.FeedPump_PID.limiter.uMin, 
      "Limiter: Limits must be consistent. However, uMax (="+       String(
      CS.FeedPump_PID.limiter.uMax, true, 0)+") < uMin (="+       String(
      CS.FeedPump_PID.limiter.uMin, true, 0)+")");
    CS.FeedPump_PID.limiter.simplifiedExpr = (if CS.FeedPump_PID.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.Linear then CS.FeedPump_PID.limiter.u
       else (if CS.FeedPump_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then CS.FeedPump_PID.limiter.uMax else (if CS.FeedPump_PID.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then CS.FeedPump_PID.limiter.uMin
       else 0)));
    if (CS.FeedPump_PID.limiter.strict) then 
      if (CS.FeedPump_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        CS.FeedPump_PID.limiter.y = smooth(0, noEvent((if CS.FeedPump_PID.limiter.u
           > CS.FeedPump_PID.limiter.uMax then CS.FeedPump_PID.limiter.uMax
           else (if CS.FeedPump_PID.limiter.u < CS.FeedPump_PID.limiter.uMin
           then CS.FeedPump_PID.limiter.uMin else CS.FeedPump_PID.limiter.u))));
      else
        CS.FeedPump_PID.limiter.y = homotopy(smooth(0, noEvent((if 
          CS.FeedPump_PID.limiter.u > CS.FeedPump_PID.limiter.uMax then 
          CS.FeedPump_PID.limiter.uMax else (if CS.FeedPump_PID.limiter.u < 
          CS.FeedPump_PID.limiter.uMin then CS.FeedPump_PID.limiter.uMin else 
          CS.FeedPump_PID.limiter.u)))), CS.FeedPump_PID.limiter.simplifiedExpr);
      end if;
    else
      if (CS.FeedPump_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        CS.FeedPump_PID.limiter.y = smooth(0, (if CS.FeedPump_PID.limiter.u > 
          CS.FeedPump_PID.limiter.uMax then CS.FeedPump_PID.limiter.uMax else (
          if CS.FeedPump_PID.limiter.u < CS.FeedPump_PID.limiter.uMin then 
          CS.FeedPump_PID.limiter.uMin else CS.FeedPump_PID.limiter.u)));
      else
        CS.FeedPump_PID.limiter.y = homotopy(smooth(0, (if CS.FeedPump_PID.limiter.u
           > CS.FeedPump_PID.limiter.uMax then CS.FeedPump_PID.limiter.uMax
           else (if CS.FeedPump_PID.limiter.u < CS.FeedPump_PID.limiter.uMin
           then CS.FeedPump_PID.limiter.uMin else CS.FeedPump_PID.limiter.u))), 
          CS.FeedPump_PID.limiter.simplifiedExpr);
      end if;
    end if;

  // Component CS.FeedPump_PID.Fzero
  // class Modelica.Blocks.Sources.Constant
  equation
    CS.FeedPump_PID.Fzero.y = CS.FeedPump_PID.Fzero.k;

  // Component CS.FeedPump_PID.addFF
  // class Modelica.Blocks.Math.Add3
  equation
    CS.FeedPump_PID.addFF.y = CS.FeedPump_PID.addFF.k1*CS.FeedPump_PID.addFF.u1+
      CS.FeedPump_PID.addFF.k2*CS.FeedPump_PID.addFF.u2+CS.FeedPump_PID.addFF.k3
      *CS.FeedPump_PID.addFF.u3;

  // Component CS.FeedPump_PID.gain_u_s
  // class Modelica.Blocks.Math.Gain
  equation
    CS.FeedPump_PID.gain_u_s.y = CS.FeedPump_PID.gain_u_s.k*CS.FeedPump_PID.gain_u_s.u;

  // Component CS.FeedPump_PID.gain_u_m
  // class Modelica.Blocks.Math.Gain
  equation
    CS.FeedPump_PID.gain_u_m.y = CS.FeedPump_PID.gain_u_m.k*CS.FeedPump_PID.gain_u_m.u;

  // Component CS.FeedPump_PID.null_bias
  // class Modelica.Blocks.Sources.Constant
  equation
    CS.FeedPump_PID.null_bias.y = CS.FeedPump_PID.null_bias.k;

  // Component CS.FeedPump_PID.I
  // class TRANSFORM.Blocks.IntegratorWithReset
  equation
    der(CS.FeedPump_PID.I.y) = CS.FeedPump_PID.I.k*CS.FeedPump_PID.I.u;
    if (CS.FeedPump_PID.I.reset <> TRANSFORM.Types.Reset.Input) then 
      CS.FeedPump_PID.I.y_reset_internal = CS.FeedPump_PID.I.y_reset;
    end if;
    if (CS.FeedPump_PID.I.reset == TRANSFORM.Types.Reset.Disabled) then 
      CS.FeedPump_PID.I.trigger_internal = false;
    else
      when CS.FeedPump_PID.I.trigger_internal then
        reinit(CS.FeedPump_PID.I.y, CS.FeedPump_PID.I.y_reset_internal);
      end when;
    end if;

  // Component CS.FeedPump_PID.addI
  // class Modelica.Blocks.Math.Add3
  equation
    CS.FeedPump_PID.addI.y = CS.FeedPump_PID.addI.k1*CS.FeedPump_PID.addI.u1+
      CS.FeedPump_PID.addI.k2*CS.FeedPump_PID.addI.u2+CS.FeedPump_PID.addI.k3*
      CS.FeedPump_PID.addI.u3;

  // Component CS.FeedPump_PID.addSat
  // class Modelica.Blocks.Math.Add
  equation
    CS.FeedPump_PID.addSat.y = CS.FeedPump_PID.addSat.k1*CS.FeedPump_PID.addSat.u1
      +CS.FeedPump_PID.addSat.k2*CS.FeedPump_PID.addSat.u2;

  // Component CS.FeedPump_PID.gainTrack
  // class Modelica.Blocks.Math.Gain
  equation
    CS.FeedPump_PID.gainTrack.y = CS.FeedPump_PID.gainTrack.k*CS.FeedPump_PID.gainTrack.u;

  // Component CS.FeedPump_PID.Dzero
  // class Modelica.Blocks.Sources.Constant
  equation
    CS.FeedPump_PID.Dzero.y = CS.FeedPump_PID.Dzero.k;

  // Component CS.FeedPump_PID
  // class TRANSFORM.Controls.LimPID
  equation
    assert(CS.FeedPump_PID.yMax >= CS.FeedPump_PID.yMin, "LimPID: Limits must be consistent. However, yMax (="
      +       String(CS.FeedPump_PID.yMax, true, 0)+") < yMin (="+       String(
      CS.FeedPump_PID.yMin, true, 0)+")");
    if (CS.FeedPump_PID.initType == Modelica.Blocks.Types.Init.InitialOutput
       and (CS.FeedPump_PID.y_start < CS.FeedPump_PID.yMin or CS.FeedPump_PID.y_start
       > CS.FeedPump_PID.yMax)) then 
      ModelicaError("LimPID: Start value y_start (="+       String(
        CS.FeedPump_PID.y_start, true, 0)+") is outside of the limits of yMin (="
        +       String(CS.FeedPump_PID.yMin, true, 0)+") and yMax (="+
               String(CS.FeedPump_PID.yMax, true, 0)+")");
    end if;
    if (CS.FeedPump_PID.reset <> TRANSFORM.Types.Reset.Input) then 
      CS.FeedPump_PID.y_reset_internal = CS.FeedPump_PID.y_reset;
    end if;
    CS.FeedPump_PID.addPID.u2 = CS.FeedPump_PID.Dzero.y;
    CS.FeedPump_PID.addFF.u1 = CS.FeedPump_PID.Fzero.y;
    CS.FeedPump_PID.addI.y = CS.FeedPump_PID.I.u;
    CS.FeedPump_PID.addPID.u3 = CS.FeedPump_PID.I.y;
    CS.FeedPump_PID.addP.y = CS.FeedPump_PID.P.u;
    CS.FeedPump_PID.addPID.u1 = CS.FeedPump_PID.P.y;
    CS.FeedPump_PID.gainPID.y = CS.FeedPump_PID.addFF.u2;
    CS.FeedPump_PID.null_bias.y = CS.FeedPump_PID.addFF.u3;
    CS.FeedPump_PID.addSat.u2 = CS.FeedPump_PID.addFF.y;
    CS.FeedPump_PID.limiter.u = CS.FeedPump_PID.addFF.y;
    CS.FeedPump_PID.addP.u1 = CS.FeedPump_PID.addI.u1;
    CS.FeedPump_PID.gain_u_s.y = CS.FeedPump_PID.addI.u1;
    CS.FeedPump_PID.addP.u2 = CS.FeedPump_PID.addI.u2;
    CS.FeedPump_PID.gain_u_m.y = CS.FeedPump_PID.addI.u2;
    CS.FeedPump_PID.gainTrack.y = CS.FeedPump_PID.addI.u3;
    CS.FeedPump_PID.gainPID.u = CS.FeedPump_PID.addPID.y;
    CS.FeedPump_PID.limiter.y = CS.FeedPump_PID.addSat.u1;
    CS.FeedPump_PID.y = CS.FeedPump_PID.addSat.u1;
    CS.FeedPump_PID.gainTrack.u = CS.FeedPump_PID.addSat.y;
    CS.FeedPump_PID.u_m = CS.FeedPump_PID.gain_u_m.u;
    CS.FeedPump_PID.u_s = CS.FeedPump_PID.gain_u_s.u;

  // Component CS.TCV_PID.addP
  // class Modelica.Blocks.Math.Add
  equation
    CS.TCV_PID.addP.y = CS.TCV_PID.addP.k1*CS.TCV_PID.addP.u1+CS.TCV_PID.addP.k2
      *CS.TCV_PID.addP.u2;

  // Component CS.TCV_PID.P
  // class Modelica.Blocks.Math.Gain
  equation
    CS.TCV_PID.P.y = CS.TCV_PID.P.k*CS.TCV_PID.P.u;

  // Component CS.TCV_PID.gainPID
  // class Modelica.Blocks.Math.Gain
  equation
    CS.TCV_PID.gainPID.y = CS.TCV_PID.gainPID.k*CS.TCV_PID.gainPID.u;

  // Component CS.TCV_PID.addPID
  // class Modelica.Blocks.Math.Add3
  equation
    CS.TCV_PID.addPID.y = CS.TCV_PID.addPID.k1*CS.TCV_PID.addPID.u1+
      CS.TCV_PID.addPID.k2*CS.TCV_PID.addPID.u2+CS.TCV_PID.addPID.k3*
      CS.TCV_PID.addPID.u3;

  // Component CS.TCV_PID.limiter
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(CS.TCV_PID.limiter.uMax >= CS.TCV_PID.limiter.uMin, "Limiter: Limits must be consistent. However, uMax (="
      +       String(CS.TCV_PID.limiter.uMax, true, 0)+") < uMin (="+
             String(CS.TCV_PID.limiter.uMin, true, 0)+")");
    CS.TCV_PID.limiter.simplifiedExpr = (if CS.TCV_PID.limiter.homotopyType == 
      Modelica.Blocks.Types.LimiterHomotopy.Linear then CS.TCV_PID.limiter.u
       else (if CS.TCV_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then CS.TCV_PID.limiter.uMax else (if CS.TCV_PID.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then CS.TCV_PID.limiter.uMin
       else 0)));
    if (CS.TCV_PID.limiter.strict) then 
      if (CS.TCV_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        CS.TCV_PID.limiter.y = smooth(0, noEvent((if CS.TCV_PID.limiter.u > 
          CS.TCV_PID.limiter.uMax then CS.TCV_PID.limiter.uMax else (if 
          CS.TCV_PID.limiter.u < CS.TCV_PID.limiter.uMin then CS.TCV_PID.limiter.uMin
           else CS.TCV_PID.limiter.u))));
      else
        CS.TCV_PID.limiter.y = homotopy(smooth(0, noEvent((if CS.TCV_PID.limiter.u
           > CS.TCV_PID.limiter.uMax then CS.TCV_PID.limiter.uMax else (if 
          CS.TCV_PID.limiter.u < CS.TCV_PID.limiter.uMin then CS.TCV_PID.limiter.uMin
           else CS.TCV_PID.limiter.u)))), CS.TCV_PID.limiter.simplifiedExpr);
      end if;
    else
      if (CS.TCV_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        CS.TCV_PID.limiter.y = smooth(0, (if CS.TCV_PID.limiter.u > 
          CS.TCV_PID.limiter.uMax then CS.TCV_PID.limiter.uMax else (if 
          CS.TCV_PID.limiter.u < CS.TCV_PID.limiter.uMin then CS.TCV_PID.limiter.uMin
           else CS.TCV_PID.limiter.u)));
      else
        CS.TCV_PID.limiter.y = homotopy(smooth(0, (if CS.TCV_PID.limiter.u > 
          CS.TCV_PID.limiter.uMax then CS.TCV_PID.limiter.uMax else (if 
          CS.TCV_PID.limiter.u < CS.TCV_PID.limiter.uMin then CS.TCV_PID.limiter.uMin
           else CS.TCV_PID.limiter.u))), CS.TCV_PID.limiter.simplifiedExpr);
      end if;
    end if;

  // Component CS.TCV_PID.Fzero
  // class Modelica.Blocks.Sources.Constant
  equation
    CS.TCV_PID.Fzero.y = CS.TCV_PID.Fzero.k;

  // Component CS.TCV_PID.addFF
  // class Modelica.Blocks.Math.Add3
  equation
    CS.TCV_PID.addFF.y = CS.TCV_PID.addFF.k1*CS.TCV_PID.addFF.u1+
      CS.TCV_PID.addFF.k2*CS.TCV_PID.addFF.u2+CS.TCV_PID.addFF.k3*
      CS.TCV_PID.addFF.u3;

  // Component CS.TCV_PID.gain_u_s
  // class Modelica.Blocks.Math.Gain
  equation
    CS.TCV_PID.gain_u_s.y = CS.TCV_PID.gain_u_s.k*CS.TCV_PID.gain_u_s.u;

  // Component CS.TCV_PID.gain_u_m
  // class Modelica.Blocks.Math.Gain
  equation
    CS.TCV_PID.gain_u_m.y = CS.TCV_PID.gain_u_m.k*CS.TCV_PID.gain_u_m.u;

  // Component CS.TCV_PID.null_bias
  // class Modelica.Blocks.Sources.Constant
  equation
    CS.TCV_PID.null_bias.y = CS.TCV_PID.null_bias.k;

  // Component CS.TCV_PID.I
  // class TRANSFORM.Blocks.IntegratorWithReset
  equation
    der(CS.TCV_PID.I.y) = CS.TCV_PID.I.k*CS.TCV_PID.I.u;
    if (CS.TCV_PID.I.reset <> TRANSFORM.Types.Reset.Input) then 
      CS.TCV_PID.I.y_reset_internal = CS.TCV_PID.I.y_reset;
    end if;
    if (CS.TCV_PID.I.reset == TRANSFORM.Types.Reset.Disabled) then 
      CS.TCV_PID.I.trigger_internal = false;
    else
      when CS.TCV_PID.I.trigger_internal then
        reinit(CS.TCV_PID.I.y, CS.TCV_PID.I.y_reset_internal);
      end when;
    end if;

  // Component CS.TCV_PID.addI
  // class Modelica.Blocks.Math.Add3
  equation
    CS.TCV_PID.addI.y = CS.TCV_PID.addI.k1*CS.TCV_PID.addI.u1+CS.TCV_PID.addI.k2
      *CS.TCV_PID.addI.u2+CS.TCV_PID.addI.k3*CS.TCV_PID.addI.u3;

  // Component CS.TCV_PID.addSat
  // class Modelica.Blocks.Math.Add
  equation
    CS.TCV_PID.addSat.y = CS.TCV_PID.addSat.k1*CS.TCV_PID.addSat.u1+
      CS.TCV_PID.addSat.k2*CS.TCV_PID.addSat.u2;

  // Component CS.TCV_PID.gainTrack
  // class Modelica.Blocks.Math.Gain
  equation
    CS.TCV_PID.gainTrack.y = CS.TCV_PID.gainTrack.k*CS.TCV_PID.gainTrack.u;

  // Component CS.TCV_PID.Dzero
  // class Modelica.Blocks.Sources.Constant
  equation
    CS.TCV_PID.Dzero.y = CS.TCV_PID.Dzero.k;

  // Component CS.TCV_PID
  // class TRANSFORM.Controls.LimPID
  equation
    assert(CS.TCV_PID.yMax >= CS.TCV_PID.yMin, "LimPID: Limits must be consistent. However, yMax (="
      +       String(CS.TCV_PID.yMax, true, 0)+") < yMin (="+       String(
      CS.TCV_PID.yMin, true, 0)+")");
    if (CS.TCV_PID.initType == Modelica.Blocks.Types.Init.InitialOutput and (
      CS.TCV_PID.y_start < CS.TCV_PID.yMin or CS.TCV_PID.y_start > 
      CS.TCV_PID.yMax)) then 
      ModelicaError("LimPID: Start value y_start (="+       String(
        CS.TCV_PID.y_start, true, 0)+") is outside of the limits of yMin (="+
               String(CS.TCV_PID.yMin, true, 0)+") and yMax (="+       String(
        CS.TCV_PID.yMax, true, 0)+")");
    end if;
    if (CS.TCV_PID.reset <> TRANSFORM.Types.Reset.Input) then 
      CS.TCV_PID.y_reset_internal = CS.TCV_PID.y_reset;
    end if;
    CS.TCV_PID.addPID.u2 = CS.TCV_PID.Dzero.y;
    CS.TCV_PID.addFF.u1 = CS.TCV_PID.Fzero.y;
    CS.TCV_PID.addI.y = CS.TCV_PID.I.u;
    CS.TCV_PID.addPID.u3 = CS.TCV_PID.I.y;
    CS.TCV_PID.addP.y = CS.TCV_PID.P.u;
    CS.TCV_PID.addPID.u1 = CS.TCV_PID.P.y;
    CS.TCV_PID.gainPID.y = CS.TCV_PID.addFF.u2;
    CS.TCV_PID.null_bias.y = CS.TCV_PID.addFF.u3;
    CS.TCV_PID.addSat.u2 = CS.TCV_PID.addFF.y;
    CS.TCV_PID.limiter.u = CS.TCV_PID.addFF.y;
    CS.TCV_PID.addP.u1 = CS.TCV_PID.addI.u1;
    CS.TCV_PID.gain_u_s.y = CS.TCV_PID.addI.u1;
    CS.TCV_PID.addP.u2 = CS.TCV_PID.addI.u2;
    CS.TCV_PID.gain_u_m.y = CS.TCV_PID.addI.u2;
    CS.TCV_PID.gainTrack.y = CS.TCV_PID.addI.u3;
    CS.TCV_PID.gainPID.u = CS.TCV_PID.addPID.y;
    CS.TCV_PID.limiter.y = CS.TCV_PID.addSat.u1;
    CS.TCV_PID.y = CS.TCV_PID.addSat.u1;
    CS.TCV_PID.gainTrack.u = CS.TCV_PID.addSat.y;
    CS.TCV_PID.u_m = CS.TCV_PID.gain_u_m.u;
    CS.TCV_PID.u_s = CS.TCV_PID.gain_u_s.u;

  // Component CS.LPT1_BV_PID.addP
  // class Modelica.Blocks.Math.Add
  equation
    CS.LPT1_BV_PID.addP.y = CS.LPT1_BV_PID.addP.k1*CS.LPT1_BV_PID.addP.u1+
      CS.LPT1_BV_PID.addP.k2*CS.LPT1_BV_PID.addP.u2;

  // Component CS.LPT1_BV_PID.P
  // class Modelica.Blocks.Math.Gain
  equation
    CS.LPT1_BV_PID.P.y = CS.LPT1_BV_PID.P.k*CS.LPT1_BV_PID.P.u;

  // Component CS.LPT1_BV_PID.gainPID
  // class Modelica.Blocks.Math.Gain
  equation
    CS.LPT1_BV_PID.gainPID.y = CS.LPT1_BV_PID.gainPID.k*CS.LPT1_BV_PID.gainPID.u;

  // Component CS.LPT1_BV_PID.addPID
  // class Modelica.Blocks.Math.Add3
  equation
    CS.LPT1_BV_PID.addPID.y = CS.LPT1_BV_PID.addPID.k1*CS.LPT1_BV_PID.addPID.u1+
      CS.LPT1_BV_PID.addPID.k2*CS.LPT1_BV_PID.addPID.u2+CS.LPT1_BV_PID.addPID.k3
      *CS.LPT1_BV_PID.addPID.u3;

  // Component CS.LPT1_BV_PID.limiter
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(CS.LPT1_BV_PID.limiter.uMax >= CS.LPT1_BV_PID.limiter.uMin, 
      "Limiter: Limits must be consistent. However, uMax (="+       String(
      CS.LPT1_BV_PID.limiter.uMax, true, 0)+") < uMin (="+       String(
      CS.LPT1_BV_PID.limiter.uMin, true, 0)+")");
    CS.LPT1_BV_PID.limiter.simplifiedExpr = (if CS.LPT1_BV_PID.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.Linear then CS.LPT1_BV_PID.limiter.u
       else (if CS.LPT1_BV_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then CS.LPT1_BV_PID.limiter.uMax else (if CS.LPT1_BV_PID.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then CS.LPT1_BV_PID.limiter.uMin
       else 0)));
    if (CS.LPT1_BV_PID.limiter.strict) then 
      if (CS.LPT1_BV_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        CS.LPT1_BV_PID.limiter.y = smooth(0, noEvent((if CS.LPT1_BV_PID.limiter.u
           > CS.LPT1_BV_PID.limiter.uMax then CS.LPT1_BV_PID.limiter.uMax else (
          if CS.LPT1_BV_PID.limiter.u < CS.LPT1_BV_PID.limiter.uMin then 
          CS.LPT1_BV_PID.limiter.uMin else CS.LPT1_BV_PID.limiter.u))));
      else
        CS.LPT1_BV_PID.limiter.y = homotopy(smooth(0, noEvent((if 
          CS.LPT1_BV_PID.limiter.u > CS.LPT1_BV_PID.limiter.uMax then 
          CS.LPT1_BV_PID.limiter.uMax else (if CS.LPT1_BV_PID.limiter.u < 
          CS.LPT1_BV_PID.limiter.uMin then CS.LPT1_BV_PID.limiter.uMin else 
          CS.LPT1_BV_PID.limiter.u)))), CS.LPT1_BV_PID.limiter.simplifiedExpr);
      end if;
    else
      if (CS.LPT1_BV_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        CS.LPT1_BV_PID.limiter.y = smooth(0, (if CS.LPT1_BV_PID.limiter.u > 
          CS.LPT1_BV_PID.limiter.uMax then CS.LPT1_BV_PID.limiter.uMax else (if 
          CS.LPT1_BV_PID.limiter.u < CS.LPT1_BV_PID.limiter.uMin then 
          CS.LPT1_BV_PID.limiter.uMin else CS.LPT1_BV_PID.limiter.u)));
      else
        CS.LPT1_BV_PID.limiter.y = homotopy(smooth(0, (if CS.LPT1_BV_PID.limiter.u
           > CS.LPT1_BV_PID.limiter.uMax then CS.LPT1_BV_PID.limiter.uMax else (
          if CS.LPT1_BV_PID.limiter.u < CS.LPT1_BV_PID.limiter.uMin then 
          CS.LPT1_BV_PID.limiter.uMin else CS.LPT1_BV_PID.limiter.u))), 
          CS.LPT1_BV_PID.limiter.simplifiedExpr);
      end if;
    end if;

  // Component CS.LPT1_BV_PID.Fzero
  // class Modelica.Blocks.Sources.Constant
  equation
    CS.LPT1_BV_PID.Fzero.y = CS.LPT1_BV_PID.Fzero.k;

  // Component CS.LPT1_BV_PID.addFF
  // class Modelica.Blocks.Math.Add3
  equation
    CS.LPT1_BV_PID.addFF.y = CS.LPT1_BV_PID.addFF.k1*CS.LPT1_BV_PID.addFF.u1+
      CS.LPT1_BV_PID.addFF.k2*CS.LPT1_BV_PID.addFF.u2+CS.LPT1_BV_PID.addFF.k3*
      CS.LPT1_BV_PID.addFF.u3;

  // Component CS.LPT1_BV_PID.gain_u_s
  // class Modelica.Blocks.Math.Gain
  equation
    CS.LPT1_BV_PID.gain_u_s.y = CS.LPT1_BV_PID.gain_u_s.k*CS.LPT1_BV_PID.gain_u_s.u;

  // Component CS.LPT1_BV_PID.gain_u_m
  // class Modelica.Blocks.Math.Gain
  equation
    CS.LPT1_BV_PID.gain_u_m.y = CS.LPT1_BV_PID.gain_u_m.k*CS.LPT1_BV_PID.gain_u_m.u;

  // Component CS.LPT1_BV_PID.null_bias
  // class Modelica.Blocks.Sources.Constant
  equation
    CS.LPT1_BV_PID.null_bias.y = CS.LPT1_BV_PID.null_bias.k;

  // Component CS.LPT1_BV_PID.I
  // class TRANSFORM.Blocks.IntegratorWithReset
  equation
    der(CS.LPT1_BV_PID.I.y) = CS.LPT1_BV_PID.I.k*CS.LPT1_BV_PID.I.u;
    if (CS.LPT1_BV_PID.I.reset <> TRANSFORM.Types.Reset.Input) then 
      CS.LPT1_BV_PID.I.y_reset_internal = CS.LPT1_BV_PID.I.y_reset;
    end if;
    if (CS.LPT1_BV_PID.I.reset == TRANSFORM.Types.Reset.Disabled) then 
      CS.LPT1_BV_PID.I.trigger_internal = false;
    else
      when CS.LPT1_BV_PID.I.trigger_internal then
        reinit(CS.LPT1_BV_PID.I.y, CS.LPT1_BV_PID.I.y_reset_internal);
      end when;
    end if;

  // Component CS.LPT1_BV_PID.addI
  // class Modelica.Blocks.Math.Add3
  equation
    CS.LPT1_BV_PID.addI.y = CS.LPT1_BV_PID.addI.k1*CS.LPT1_BV_PID.addI.u1+
      CS.LPT1_BV_PID.addI.k2*CS.LPT1_BV_PID.addI.u2+CS.LPT1_BV_PID.addI.k3*
      CS.LPT1_BV_PID.addI.u3;

  // Component CS.LPT1_BV_PID.addSat
  // class Modelica.Blocks.Math.Add
  equation
    CS.LPT1_BV_PID.addSat.y = CS.LPT1_BV_PID.addSat.k1*CS.LPT1_BV_PID.addSat.u1+
      CS.LPT1_BV_PID.addSat.k2*CS.LPT1_BV_PID.addSat.u2;

  // Component CS.LPT1_BV_PID.gainTrack
  // class Modelica.Blocks.Math.Gain
  equation
    CS.LPT1_BV_PID.gainTrack.y = CS.LPT1_BV_PID.gainTrack.k*CS.LPT1_BV_PID.gainTrack.u;

  // Component CS.LPT1_BV_PID.Dzero
  // class Modelica.Blocks.Sources.Constant
  equation
    CS.LPT1_BV_PID.Dzero.y = CS.LPT1_BV_PID.Dzero.k;

  // Component CS.LPT1_BV_PID
  // class TRANSFORM.Controls.LimPID
  equation
    assert(CS.LPT1_BV_PID.yMax >= CS.LPT1_BV_PID.yMin, "LimPID: Limits must be consistent. However, yMax (="
      +       String(CS.LPT1_BV_PID.yMax, true, 0)+") < yMin (="+       String(
      CS.LPT1_BV_PID.yMin, true, 0)+")");
    if (CS.LPT1_BV_PID.initType == Modelica.Blocks.Types.Init.InitialOutput and 
      (CS.LPT1_BV_PID.y_start < CS.LPT1_BV_PID.yMin or CS.LPT1_BV_PID.y_start > 
      CS.LPT1_BV_PID.yMax)) then 
      ModelicaError("LimPID: Start value y_start (="+       String(
        CS.LPT1_BV_PID.y_start, true, 0)+") is outside of the limits of yMin (="
        +       String(CS.LPT1_BV_PID.yMin, true, 0)+") and yMax (="+
               String(CS.LPT1_BV_PID.yMax, true, 0)+")");
    end if;
    if (CS.LPT1_BV_PID.reset <> TRANSFORM.Types.Reset.Input) then 
      CS.LPT1_BV_PID.y_reset_internal = CS.LPT1_BV_PID.y_reset;
    end if;
    CS.LPT1_BV_PID.addPID.u2 = CS.LPT1_BV_PID.Dzero.y;
    CS.LPT1_BV_PID.addFF.u1 = CS.LPT1_BV_PID.Fzero.y;
    CS.LPT1_BV_PID.addI.y = CS.LPT1_BV_PID.I.u;
    CS.LPT1_BV_PID.addPID.u3 = CS.LPT1_BV_PID.I.y;
    CS.LPT1_BV_PID.addP.y = CS.LPT1_BV_PID.P.u;
    CS.LPT1_BV_PID.addPID.u1 = CS.LPT1_BV_PID.P.y;
    CS.LPT1_BV_PID.gainPID.y = CS.LPT1_BV_PID.addFF.u2;
    CS.LPT1_BV_PID.null_bias.y = CS.LPT1_BV_PID.addFF.u3;
    CS.LPT1_BV_PID.addSat.u2 = CS.LPT1_BV_PID.addFF.y;
    CS.LPT1_BV_PID.limiter.u = CS.LPT1_BV_PID.addFF.y;
    CS.LPT1_BV_PID.addP.u1 = CS.LPT1_BV_PID.addI.u1;
    CS.LPT1_BV_PID.gain_u_s.y = CS.LPT1_BV_PID.addI.u1;
    CS.LPT1_BV_PID.addP.u2 = CS.LPT1_BV_PID.addI.u2;
    CS.LPT1_BV_PID.gain_u_m.y = CS.LPT1_BV_PID.addI.u2;
    CS.LPT1_BV_PID.gainTrack.y = CS.LPT1_BV_PID.addI.u3;
    CS.LPT1_BV_PID.gainPID.u = CS.LPT1_BV_PID.addPID.y;
    CS.LPT1_BV_PID.limiter.y = CS.LPT1_BV_PID.addSat.u1;
    CS.LPT1_BV_PID.y = CS.LPT1_BV_PID.addSat.u1;
    CS.LPT1_BV_PID.gainTrack.u = CS.LPT1_BV_PID.addSat.y;
    CS.LPT1_BV_PID.u_m = CS.LPT1_BV_PID.gain_u_m.u;
    CS.LPT1_BV_PID.u_s = CS.LPT1_BV_PID.gain_u_s.u;

  // Component CS.LPT2_BV_PID.addP
  // class Modelica.Blocks.Math.Add
  equation
    CS.LPT2_BV_PID.addP.y = CS.LPT2_BV_PID.addP.k1*CS.LPT2_BV_PID.addP.u1+
      CS.LPT2_BV_PID.addP.k2*CS.LPT2_BV_PID.addP.u2;

  // Component CS.LPT2_BV_PID.P
  // class Modelica.Blocks.Math.Gain
  equation
    CS.LPT2_BV_PID.P.y = CS.LPT2_BV_PID.P.k*CS.LPT2_BV_PID.P.u;

  // Component CS.LPT2_BV_PID.gainPID
  // class Modelica.Blocks.Math.Gain
  equation
    CS.LPT2_BV_PID.gainPID.y = CS.LPT2_BV_PID.gainPID.k*CS.LPT2_BV_PID.gainPID.u;

  // Component CS.LPT2_BV_PID.addPID
  // class Modelica.Blocks.Math.Add3
  equation
    CS.LPT2_BV_PID.addPID.y = CS.LPT2_BV_PID.addPID.k1*CS.LPT2_BV_PID.addPID.u1+
      CS.LPT2_BV_PID.addPID.k2*CS.LPT2_BV_PID.addPID.u2+CS.LPT2_BV_PID.addPID.k3
      *CS.LPT2_BV_PID.addPID.u3;

  // Component CS.LPT2_BV_PID.limiter
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(CS.LPT2_BV_PID.limiter.uMax >= CS.LPT2_BV_PID.limiter.uMin, 
      "Limiter: Limits must be consistent. However, uMax (="+       String(
      CS.LPT2_BV_PID.limiter.uMax, true, 0)+") < uMin (="+       String(
      CS.LPT2_BV_PID.limiter.uMin, true, 0)+")");
    CS.LPT2_BV_PID.limiter.simplifiedExpr = (if CS.LPT2_BV_PID.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.Linear then CS.LPT2_BV_PID.limiter.u
       else (if CS.LPT2_BV_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then CS.LPT2_BV_PID.limiter.uMax else (if CS.LPT2_BV_PID.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then CS.LPT2_BV_PID.limiter.uMin
       else 0)));
    if (CS.LPT2_BV_PID.limiter.strict) then 
      if (CS.LPT2_BV_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        CS.LPT2_BV_PID.limiter.y = smooth(0, noEvent((if CS.LPT2_BV_PID.limiter.u
           > CS.LPT2_BV_PID.limiter.uMax then CS.LPT2_BV_PID.limiter.uMax else (
          if CS.LPT2_BV_PID.limiter.u < CS.LPT2_BV_PID.limiter.uMin then 
          CS.LPT2_BV_PID.limiter.uMin else CS.LPT2_BV_PID.limiter.u))));
      else
        CS.LPT2_BV_PID.limiter.y = homotopy(smooth(0, noEvent((if 
          CS.LPT2_BV_PID.limiter.u > CS.LPT2_BV_PID.limiter.uMax then 
          CS.LPT2_BV_PID.limiter.uMax else (if CS.LPT2_BV_PID.limiter.u < 
          CS.LPT2_BV_PID.limiter.uMin then CS.LPT2_BV_PID.limiter.uMin else 
          CS.LPT2_BV_PID.limiter.u)))), CS.LPT2_BV_PID.limiter.simplifiedExpr);
      end if;
    else
      if (CS.LPT2_BV_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        CS.LPT2_BV_PID.limiter.y = smooth(0, (if CS.LPT2_BV_PID.limiter.u > 
          CS.LPT2_BV_PID.limiter.uMax then CS.LPT2_BV_PID.limiter.uMax else (if 
          CS.LPT2_BV_PID.limiter.u < CS.LPT2_BV_PID.limiter.uMin then 
          CS.LPT2_BV_PID.limiter.uMin else CS.LPT2_BV_PID.limiter.u)));
      else
        CS.LPT2_BV_PID.limiter.y = homotopy(smooth(0, (if CS.LPT2_BV_PID.limiter.u
           > CS.LPT2_BV_PID.limiter.uMax then CS.LPT2_BV_PID.limiter.uMax else (
          if CS.LPT2_BV_PID.limiter.u < CS.LPT2_BV_PID.limiter.uMin then 
          CS.LPT2_BV_PID.limiter.uMin else CS.LPT2_BV_PID.limiter.u))), 
          CS.LPT2_BV_PID.limiter.simplifiedExpr);
      end if;
    end if;

  // Component CS.LPT2_BV_PID.Fzero
  // class Modelica.Blocks.Sources.Constant
  equation
    CS.LPT2_BV_PID.Fzero.y = CS.LPT2_BV_PID.Fzero.k;

  // Component CS.LPT2_BV_PID.addFF
  // class Modelica.Blocks.Math.Add3
  equation
    CS.LPT2_BV_PID.addFF.y = CS.LPT2_BV_PID.addFF.k1*CS.LPT2_BV_PID.addFF.u1+
      CS.LPT2_BV_PID.addFF.k2*CS.LPT2_BV_PID.addFF.u2+CS.LPT2_BV_PID.addFF.k3*
      CS.LPT2_BV_PID.addFF.u3;

  // Component CS.LPT2_BV_PID.gain_u_s
  // class Modelica.Blocks.Math.Gain
  equation
    CS.LPT2_BV_PID.gain_u_s.y = CS.LPT2_BV_PID.gain_u_s.k*CS.LPT2_BV_PID.gain_u_s.u;

  // Component CS.LPT2_BV_PID.gain_u_m
  // class Modelica.Blocks.Math.Gain
  equation
    CS.LPT2_BV_PID.gain_u_m.y = CS.LPT2_BV_PID.gain_u_m.k*CS.LPT2_BV_PID.gain_u_m.u;

  // Component CS.LPT2_BV_PID.null_bias
  // class Modelica.Blocks.Sources.Constant
  equation
    CS.LPT2_BV_PID.null_bias.y = CS.LPT2_BV_PID.null_bias.k;

  // Component CS.LPT2_BV_PID.I
  // class TRANSFORM.Blocks.IntegratorWithReset
  equation
    der(CS.LPT2_BV_PID.I.y) = CS.LPT2_BV_PID.I.k*CS.LPT2_BV_PID.I.u;
    if (CS.LPT2_BV_PID.I.reset <> TRANSFORM.Types.Reset.Input) then 
      CS.LPT2_BV_PID.I.y_reset_internal = CS.LPT2_BV_PID.I.y_reset;
    end if;
    if (CS.LPT2_BV_PID.I.reset == TRANSFORM.Types.Reset.Disabled) then 
      CS.LPT2_BV_PID.I.trigger_internal = false;
    else
      when CS.LPT2_BV_PID.I.trigger_internal then
        reinit(CS.LPT2_BV_PID.I.y, CS.LPT2_BV_PID.I.y_reset_internal);
      end when;
    end if;

  // Component CS.LPT2_BV_PID.addI
  // class Modelica.Blocks.Math.Add3
  equation
    CS.LPT2_BV_PID.addI.y = CS.LPT2_BV_PID.addI.k1*CS.LPT2_BV_PID.addI.u1+
      CS.LPT2_BV_PID.addI.k2*CS.LPT2_BV_PID.addI.u2+CS.LPT2_BV_PID.addI.k3*
      CS.LPT2_BV_PID.addI.u3;

  // Component CS.LPT2_BV_PID.addSat
  // class Modelica.Blocks.Math.Add
  equation
    CS.LPT2_BV_PID.addSat.y = CS.LPT2_BV_PID.addSat.k1*CS.LPT2_BV_PID.addSat.u1+
      CS.LPT2_BV_PID.addSat.k2*CS.LPT2_BV_PID.addSat.u2;

  // Component CS.LPT2_BV_PID.gainTrack
  // class Modelica.Blocks.Math.Gain
  equation
    CS.LPT2_BV_PID.gainTrack.y = CS.LPT2_BV_PID.gainTrack.k*CS.LPT2_BV_PID.gainTrack.u;

  // Component CS.LPT2_BV_PID.Dzero
  // class Modelica.Blocks.Sources.Constant
  equation
    CS.LPT2_BV_PID.Dzero.y = CS.LPT2_BV_PID.Dzero.k;

  // Component CS.LPT2_BV_PID
  // class TRANSFORM.Controls.LimPID
  equation
    assert(CS.LPT2_BV_PID.yMax >= CS.LPT2_BV_PID.yMin, "LimPID: Limits must be consistent. However, yMax (="
      +       String(CS.LPT2_BV_PID.yMax, true, 0)+") < yMin (="+       String(
      CS.LPT2_BV_PID.yMin, true, 0)+")");
    if (CS.LPT2_BV_PID.initType == Modelica.Blocks.Types.Init.InitialOutput and 
      (CS.LPT2_BV_PID.y_start < CS.LPT2_BV_PID.yMin or CS.LPT2_BV_PID.y_start > 
      CS.LPT2_BV_PID.yMax)) then 
      ModelicaError("LimPID: Start value y_start (="+       String(
        CS.LPT2_BV_PID.y_start, true, 0)+") is outside of the limits of yMin (="
        +       String(CS.LPT2_BV_PID.yMin, true, 0)+") and yMax (="+
               String(CS.LPT2_BV_PID.yMax, true, 0)+")");
    end if;
    if (CS.LPT2_BV_PID.reset <> TRANSFORM.Types.Reset.Input) then 
      CS.LPT2_BV_PID.y_reset_internal = CS.LPT2_BV_PID.y_reset;
    end if;
    CS.LPT2_BV_PID.addPID.u2 = CS.LPT2_BV_PID.Dzero.y;
    CS.LPT2_BV_PID.addFF.u1 = CS.LPT2_BV_PID.Fzero.y;
    CS.LPT2_BV_PID.addI.y = CS.LPT2_BV_PID.I.u;
    CS.LPT2_BV_PID.addPID.u3 = CS.LPT2_BV_PID.I.y;
    CS.LPT2_BV_PID.addP.y = CS.LPT2_BV_PID.P.u;
    CS.LPT2_BV_PID.addPID.u1 = CS.LPT2_BV_PID.P.y;
    CS.LPT2_BV_PID.gainPID.y = CS.LPT2_BV_PID.addFF.u2;
    CS.LPT2_BV_PID.null_bias.y = CS.LPT2_BV_PID.addFF.u3;
    CS.LPT2_BV_PID.addSat.u2 = CS.LPT2_BV_PID.addFF.y;
    CS.LPT2_BV_PID.limiter.u = CS.LPT2_BV_PID.addFF.y;
    CS.LPT2_BV_PID.addP.u1 = CS.LPT2_BV_PID.addI.u1;
    CS.LPT2_BV_PID.gain_u_s.y = CS.LPT2_BV_PID.addI.u1;
    CS.LPT2_BV_PID.addP.u2 = CS.LPT2_BV_PID.addI.u2;
    CS.LPT2_BV_PID.gain_u_m.y = CS.LPT2_BV_PID.addI.u2;
    CS.LPT2_BV_PID.gainTrack.y = CS.LPT2_BV_PID.addI.u3;
    CS.LPT2_BV_PID.gainPID.u = CS.LPT2_BV_PID.addPID.y;
    CS.LPT2_BV_PID.limiter.y = CS.LPT2_BV_PID.addSat.u1;
    CS.LPT2_BV_PID.y = CS.LPT2_BV_PID.addSat.u1;
    CS.LPT2_BV_PID.gainTrack.u = CS.LPT2_BV_PID.addSat.y;
    CS.LPT2_BV_PID.u_m = CS.LPT2_BV_PID.gain_u_m.u;
    CS.LPT2_BV_PID.u_s = CS.LPT2_BV_PID.gain_u_s.u;

  // Component CS.hysteresis
  // class Modelica.Blocks.Logical.Hysteresis
  equation
    assert(CS.hysteresis.uHigh > CS.hysteresis.uLow, "Hysteresis limits wrong (uHigh <= uLow)");
    CS.hysteresis.y =  not pre(CS.hysteresis.y) and CS.hysteresis.u > 
      CS.hysteresis.uHigh or pre(CS.hysteresis.y) and CS.hysteresis.u >= 
      CS.hysteresis.uLow;

  // Component CS.switch1
  // class Modelica.Blocks.Logical.Switch
  equation
    CS.switch1.y = (if CS.switch1.u2 then CS.switch1.u1 else CS.switch1.u3);

  // Component CS.switch2
  // class Modelica.Blocks.Logical.Switch
  equation
    CS.switch2.y = (if CS.switch2.u2 then CS.switch2.u1 else CS.switch2.u3);

  // Component CS.booleanStep
  // class Modelica.Blocks.Sources.BooleanStep
  equation
    CS.booleanStep.y = (if time >= CS.booleanStep.startTime then  not 
      CS.booleanStep.startValue else CS.booleanStep.startValue);

  // Component CS.switch3
  // class Modelica.Blocks.Logical.Switch
  equation
    CS.switch3.y = (if CS.switch3.u2 then CS.switch3.u1 else CS.switch3.u3);

  // Component CS.switch4
  // class Modelica.Blocks.Logical.Switch
  equation
    CS.switch4.y = (if CS.switch4.u2 then CS.switch4.u1 else CS.switch4.u3);

  // Component CS.booleanStep1
  // class Modelica.Blocks.Sources.BooleanStep
  equation
    CS.booleanStep1.y = (if time >= CS.booleanStep1.startTime then  not 
      CS.booleanStep1.startValue else CS.booleanStep1.startValue);

  // Component CS.switch5
  // class Modelica.Blocks.Logical.Switch
  equation
    CS.switch5.y = (if CS.switch5.u2 then CS.switch5.u1 else CS.switch5.u3);

  // Component CS.switch6
  // class Modelica.Blocks.Logical.Switch
  equation
    CS.switch6.y = (if CS.switch6.u2 then CS.switch6.u1 else CS.switch6.u3);

  // Component CS.booleanStep2
  // class Modelica.Blocks.Sources.BooleanStep
  equation
    CS.booleanStep2.y = (if time >= CS.booleanStep2.startTime then  not 
      CS.booleanStep2.startValue else CS.booleanStep2.startValue);

  // Component CS.switch7
  // class Modelica.Blocks.Logical.Switch
  equation
    CS.switch7.y = (if CS.switch7.u2 then CS.switch7.u1 else CS.switch7.u3);

  // Component CS.ext_pos_start
  // class Modelica.Blocks.Sources.Ramp
  equation
    CS.ext_pos_start.y = CS.ext_pos_start.offset+(if time < CS.ext_pos_start.startTime
       then 0 else (if time < CS.ext_pos_start.startTime+CS.ext_pos_start.duration
       then (time-CS.ext_pos_start.startTime)*CS.ext_pos_start.height/
      CS.ext_pos_start.duration else CS.ext_pos_start.height));

  // Component CS
  // class NHES.Systems.BalanceOfPlant.RankineCycle.ControlSystems.CS_L3_HTGR_extraction_logan_new
  equation
    CS.switch3.y = CS.FeedPump_PID.u_m;
    CS.T_in_set.y = CS.FeedPump_PID.u_s;
    CS.switch3.u3 = CS.FeedPump_PID.u_s;
    CS.switch2.u1 = CS.FeedPump_PID.y;
    CS.switch6.y = CS.LPT1_BV_PID.u_m;
    CS.Steam_Extraction.y = CS.LPT1_BV_PID.u_s;
    CS.switch6.u3 = CS.LPT1_BV_PID.u_s;
    CS.switch7.u1 = CS.LPT1_BV_PID.y;
    CS.switch4.y = CS.LPT2_BV_PID.u_m;
    CS.T_feed_set.y = CS.LPT2_BV_PID.u_s;
    CS.switch4.u3 = CS.LPT2_BV_PID.u_s;
    CS.switch5.u1 = CS.LPT2_BV_PID.y;
    CS.switch1.u3 = CS.P_dump_open0.y;
    CS.switch1.u1 = CS.P_dump_open1.y;
    CS.TCV_PID.u_s = CS.P_in_set.y;
    CS.hysteresis.u = CS.TCV_PID.u_m;
    CS.sensorBus.Steam_Pressure = CS.TCV_PID.u_m;
    CS.actuatorBus.opening_TCV = CS.TCV_PID.y;
    CS.switch2.u3 = CS.T_in_set1.y;
    CS.switch5.u3 = CS.T_in_set2.y;
    CS.switch2.y = CS.actuatorBus.Feed_Pump_Speed;
    CS.switch7.y = CS.actuatorBus.LPT1_BV;
    CS.switch5.y = CS.actuatorBus.LPT2_BV;
    CS.switch1.y = CS.actuatorBus.TBV;
    CS.switch2.u2 = CS.booleanStep.y;
    CS.switch3.u2 = CS.booleanStep.y;
    CS.switch4.u2 = CS.booleanStep1.y;
    CS.switch5.u2 = CS.booleanStep1.y;
    CS.switch6.u2 = CS.booleanStep2.y;
    CS.switch7.u2 = CS.booleanStep2.y;
    CS.switch7.u3 = CS.ext_pos_start.y;
    CS.switch1.u2 = CS.hysteresis.y;
    CS.switch6.u1 = CS.sensorBus.Extract_flow;
    CS.switch4.u1 = CS.sensorBus.Feedwater_Temp;
    CS.switch3.u1 = CS.sensorBus.Steam_Temperature;

  // Component HPT.eta_wetSteam
  // class NHES.Systems.BalanceOfPlant.RankineCycle.Models.SteamTurbine_L3_HPOFWHsimplified_sec_RealExpressionswitch_FWHExtractionLPT.Eta_wetSteam
    // extends TRANSFORM.Fluid.Machines.BaseClasses.WetSteamEfficiency.eta_Constant
    equation
      HPT.eta_wetSteam.eta = HPT.eta_wetSteam.eta_nominal;
    // end of extends 

  // Component HPT
  // class TRANSFORM.Fluid.Machines.SteamTurbine
    // extends TRANSFORM.Fluid.Machines.BaseClasses.SteamTurbineBase
    equation
      HPT.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(
        HPT.portHP.p, inStream(HPT.portHP.h_outflow), inStream(HPT.portHP.Xi_outflow),
         0, 0);
      HPT.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(
        HPT.portLP.p, inStream(HPT.portLP.h_outflow), inStream(HPT.portLP.Xi_outflow),
         0, 0);
      HPT.p_ratio = HPT.p_out/HPT.p_in;
      if (cardinality(HPT.partialArc) == 0) then 
        HPT.partialArc = 1.0;
      end if;
      HPT.h_is = Modelica.Media.Water.WaterIF97_ph.isentropicEnthalpy_Unique7(
        HPT.portLP.p, 
        HPT.state_a);
      HPT.eta_is = HPT.eta_wetSteam.eta;
      HPT.h_in-HPT.h_out = HPT.eta_is*(HPT.h_in-HPT.h_is);
      HPT.Q_mech = HPT.eta_mech*HPT.m_flow*(HPT.h_in-HPT.h_out);
      sum(HPT.Q_units) =  -HPT.omega*HPT.tau;
      HPT.Qbs = HPT.Q_mech*HPT.Q_fracs-HPT.Q_units;
      if (HPT.energyDynamics == TRANSFORM.Types.Dynamics.SteadyState) then 
        for i in (1:HPT.nUnits) loop
          0 = HPT.Qbs[i];
        end for;
      else
        for i in (1:HPT.nUnits) loop
          HPT.taus[i]*der(HPT.Q_units[i]) = HPT.Qbs[i];
        end for;
      end if;
      HPT.portHP.m_flow+HPT.portLP.m_flow = 0;
      HPT.tau = HPT.shaft_a.tau+HPT.shaft_b.tau;
      HPT.shaft_a.phi = HPT.phi;
      HPT.shaft_b.phi = HPT.phi;
      der(HPT.phi) = HPT.omega;
      HPT.h_in = inStream(HPT.portHP.h_outflow);
      HPT.m_flow = HPT.portHP.m_flow;
      HPT.portHP.p = HPT.p_in;
      HPT.portLP.p = HPT.p_out;
      HPT.portHP.h_outflow = inStream(HPT.portLP.h_outflow)+HPT.h_in-HPT.h_out;
      HPT.portHP.Xi_outflow = inStream(HPT.portLP.Xi_outflow);
      HPT.portHP.C_outflow = inStream(HPT.portLP.C_outflow);
      HPT.portLP.h_outflow = inStream(HPT.portHP.h_outflow)+HPT.h_out-HPT.h_in;
      HPT.portLP.Xi_outflow = inStream(HPT.portHP.Xi_outflow);
      HPT.portLP.C_outflow = inStream(HPT.portHP.C_outflow);
      HPT.x_th_in = (HPT.h_in-HPT.h_fsat_in)/max(HPT.h_gsat_in-HPT.h_fsat_in, 
        1E-06);
      HPT.x_th_out = (HPT.h_out-HPT.h_fsat_out)/max(HPT.h_gsat_out-
        HPT.h_fsat_out, 1E-06);
      HPT.x_abs_in = noEvent((if HPT.p_in/HPT.p_crit < 1.0 then max(0.0, min(1.0,
         HPT.x_th_in)) else 1.0));
      HPT.x_abs_out = noEvent((if HPT.p_out/HPT.p_crit < 1.0 then max(0.0, min(
        1.0, HPT.x_th_out)) else 1.0));
    // end of extends 
  equation
    if (HPT.use_Stodola) then 
      HPT.m_flow = homotopy(HPT.Kt*HPT.partialArc*sqrt(HPT.p_in*Modelica.Media.Water.WaterIF97_ph.density_Unique20
        (
        HPT.state_a))*Modelica.Fluid.Utilities.regRoot(1-HPT.p_ratio^2, 0.01), 
        HPT.partialArc/HPT.partialArc_nominal*HPT.m_flow_nominal/
        HPT.p_inlet_nominal*HPT.p_in);
    else
      HPT.m_flow = homotopy(HPT.portHP.p*HPT.partialArc*HPT.m_flow_nominal/
        HPT.p_inlet_nominal, HPT.partialArc/HPT.partialArc_nominal*
        HPT.m_flow_nominal/HPT.p_inlet_nominal*HPT.p_in);
    end if;
    // extends NHES.Systems.BalanceOfPlant.RankineCycle.Models.SteamTurbine_L3_HPOFWHsimplified_sec_RealExpressionswitch_FWHExtractionLPT
    equation
      HPT.shaft_a.tau = 0.0;
    // end of extends 

  // Component LPT1.eta_wetSteam
  // class NHES.Systems.BalanceOfPlant.RankineCycle.Models.SteamTurbine_L3_HPOFWHsimplified_sec_RealExpressionswitch_FWHExtractionLPT.Eta_wetSteam
    // extends TRANSFORM.Fluid.Machines.BaseClasses.WetSteamEfficiency.eta_Constant
    equation
      LPT1.eta_wetSteam.eta = LPT1.eta_wetSteam.eta_nominal;
    // end of extends 

  // Component LPT1
  // class TRANSFORM.Fluid.Machines.SteamTurbine
    // extends TRANSFORM.Fluid.Machines.BaseClasses.SteamTurbineBase
    equation
      LPT1.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(
        LPT1.portHP.p, inStream(LPT1.portHP.h_outflow), inStream(
        LPT1.portHP.Xi_outflow), 0, 0);
      LPT1.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(
        LPT1.portLP.p, inStream(LPT1.portLP.h_outflow), inStream(
        LPT1.portLP.Xi_outflow), 0, 0);
      LPT1.p_ratio = LPT1.p_out/LPT1.p_in;
      if (cardinality(LPT1.partialArc) == 0) then 
        LPT1.partialArc = 1.0;
      end if;
      LPT1.h_is = Modelica.Media.Water.WaterIF97_ph.isentropicEnthalpy_Unique7(
        LPT1.portLP.p, 
        LPT1.state_a);
      LPT1.eta_is = LPT1.eta_wetSteam.eta;
      LPT1.h_in-LPT1.h_out = LPT1.eta_is*(LPT1.h_in-LPT1.h_is);
      LPT1.Q_mech = LPT1.eta_mech*LPT1.m_flow*(LPT1.h_in-LPT1.h_out);
      sum(LPT1.Q_units) =  -LPT1.omega*LPT1.tau;
      LPT1.Qbs = LPT1.Q_mech*LPT1.Q_fracs-LPT1.Q_units;
      if (LPT1.energyDynamics == TRANSFORM.Types.Dynamics.SteadyState) then 
        for i in (1:LPT1.nUnits) loop
          0 = LPT1.Qbs[i];
        end for;
      else
        for i in (1:LPT1.nUnits) loop
          LPT1.taus[i]*der(LPT1.Q_units[i]) = LPT1.Qbs[i];
        end for;
      end if;
      LPT1.portHP.m_flow+LPT1.portLP.m_flow = 0;
      LPT1.tau = LPT1.shaft_a.tau+LPT1.shaft_b.tau;
      LPT1.shaft_a.phi = LPT1.phi;
      LPT1.shaft_b.phi = LPT1.phi;
      der(LPT1.phi) = LPT1.omega;
      LPT1.h_in = inStream(LPT1.portHP.h_outflow);
      LPT1.m_flow = LPT1.portHP.m_flow;
      LPT1.portHP.p = LPT1.p_in;
      LPT1.portLP.p = LPT1.p_out;
      LPT1.portHP.h_outflow = inStream(LPT1.portLP.h_outflow)+LPT1.h_in-
        LPT1.h_out;
      LPT1.portHP.Xi_outflow = inStream(LPT1.portLP.Xi_outflow);
      LPT1.portHP.C_outflow = inStream(LPT1.portLP.C_outflow);
      LPT1.portLP.h_outflow = inStream(LPT1.portHP.h_outflow)+LPT1.h_out-
        LPT1.h_in;
      LPT1.portLP.Xi_outflow = inStream(LPT1.portHP.Xi_outflow);
      LPT1.portLP.C_outflow = inStream(LPT1.portHP.C_outflow);
      LPT1.x_th_in = (LPT1.h_in-LPT1.h_fsat_in)/max(LPT1.h_gsat_in-
        LPT1.h_fsat_in, 1E-06);
      LPT1.x_th_out = (LPT1.h_out-LPT1.h_fsat_out)/max(LPT1.h_gsat_out-
        LPT1.h_fsat_out, 1E-06);
      LPT1.x_abs_in = noEvent((if LPT1.p_in/LPT1.p_crit < 1.0 then max(0.0, min(
        1.0, LPT1.x_th_in)) else 1.0));
      LPT1.x_abs_out = noEvent((if LPT1.p_out/LPT1.p_crit < 1.0 then max(0.0, 
        min(1.0, LPT1.x_th_out)) else 1.0));
    // end of extends 
  equation
    if (LPT1.use_Stodola) then 
      LPT1.m_flow = homotopy(LPT1.Kt*LPT1.partialArc*sqrt(LPT1.p_in*
        Modelica.Media.Water.WaterIF97_ph.density_Unique20(
        LPT1.state_a))*Modelica.Fluid.Utilities.regRoot(1-LPT1.p_ratio^2, 0.01),
         LPT1.partialArc/LPT1.partialArc_nominal*LPT1.m_flow_nominal/
        LPT1.p_inlet_nominal*LPT1.p_in);
    else
      LPT1.m_flow = homotopy(LPT1.portHP.p*LPT1.partialArc*LPT1.m_flow_nominal/
        LPT1.p_inlet_nominal, LPT1.partialArc/LPT1.partialArc_nominal*
        LPT1.m_flow_nominal/LPT1.p_inlet_nominal*LPT1.p_in);
    end if;

  // Component LPT2.eta_wetSteam
  // class NHES.Systems.BalanceOfPlant.RankineCycle.Models.SteamTurbine_L3_HPOFWHsimplified_sec_RealExpressionswitch_FWHExtractionLPT.Eta_wetSteam
    // extends TRANSFORM.Fluid.Machines.BaseClasses.WetSteamEfficiency.eta_Constant
    equation
      LPT2.eta_wetSteam.eta = LPT2.eta_wetSteam.eta_nominal;
    // end of extends 

  // Component LPT2
  // class TRANSFORM.Fluid.Machines.SteamTurbine
    // extends TRANSFORM.Fluid.Machines.BaseClasses.SteamTurbineBase
    equation
      LPT2.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(
        LPT2.portHP.p, inStream(LPT2.portHP.h_outflow), inStream(
        LPT2.portHP.Xi_outflow), 0, 0);
      LPT2.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(
        LPT2.portLP.p, inStream(LPT2.portLP.h_outflow), inStream(
        LPT2.portLP.Xi_outflow), 0, 0);
      LPT2.p_ratio = LPT2.p_out/LPT2.p_in;
      if (cardinality(LPT2.partialArc) == 0) then 
        LPT2.partialArc = 1.0;
      end if;
      LPT2.h_is = Modelica.Media.Water.WaterIF97_ph.isentropicEnthalpy_Unique7(
        LPT2.portLP.p, 
        LPT2.state_a);
      LPT2.eta_is = LPT2.eta_wetSteam.eta;
      LPT2.h_in-LPT2.h_out = LPT2.eta_is*(LPT2.h_in-LPT2.h_is);
      LPT2.Q_mech = LPT2.eta_mech*LPT2.m_flow*(LPT2.h_in-LPT2.h_out);
      sum(LPT2.Q_units) =  -LPT2.omega*LPT2.tau;
      LPT2.Qbs = LPT2.Q_mech*LPT2.Q_fracs-LPT2.Q_units;
      if (LPT2.energyDynamics == TRANSFORM.Types.Dynamics.SteadyState) then 
        for i in (1:LPT2.nUnits) loop
          0 = LPT2.Qbs[i];
        end for;
      else
        for i in (1:LPT2.nUnits) loop
          LPT2.taus[i]*der(LPT2.Q_units[i]) = LPT2.Qbs[i];
        end for;
      end if;
      LPT2.portHP.m_flow+LPT2.portLP.m_flow = 0;
      LPT2.tau = LPT2.shaft_a.tau+LPT2.shaft_b.tau;
      LPT2.shaft_a.phi = LPT2.phi;
      LPT2.shaft_b.phi = LPT2.phi;
      der(LPT2.phi) = LPT2.omega;
      LPT2.h_in = inStream(LPT2.portHP.h_outflow);
      LPT2.m_flow = LPT2.portHP.m_flow;
      LPT2.portHP.p = LPT2.p_in;
      LPT2.portLP.p = LPT2.p_out;
      LPT2.portHP.h_outflow = inStream(LPT2.portLP.h_outflow)+LPT2.h_in-
        LPT2.h_out;
      LPT2.portHP.Xi_outflow = inStream(LPT2.portLP.Xi_outflow);
      LPT2.portHP.C_outflow = inStream(LPT2.portLP.C_outflow);
      LPT2.portLP.h_outflow = inStream(LPT2.portHP.h_outflow)+LPT2.h_out-
        LPT2.h_in;
      LPT2.portLP.Xi_outflow = inStream(LPT2.portHP.Xi_outflow);
      LPT2.portLP.C_outflow = inStream(LPT2.portHP.C_outflow);
      LPT2.x_th_in = (LPT2.h_in-LPT2.h_fsat_in)/max(LPT2.h_gsat_in-
        LPT2.h_fsat_in, 1E-06);
      LPT2.x_th_out = (LPT2.h_out-LPT2.h_fsat_out)/max(LPT2.h_gsat_out-
        LPT2.h_fsat_out, 1E-06);
      LPT2.x_abs_in = noEvent((if LPT2.p_in/LPT2.p_crit < 1.0 then max(0.0, min(
        1.0, LPT2.x_th_in)) else 1.0));
      LPT2.x_abs_out = noEvent((if LPT2.p_out/LPT2.p_crit < 1.0 then max(0.0, 
        min(1.0, LPT2.x_th_out)) else 1.0));
    // end of extends 
  equation
    if (LPT2.use_Stodola) then 
      LPT2.m_flow = homotopy(LPT2.Kt*LPT2.partialArc*sqrt(LPT2.p_in*
        Modelica.Media.Water.WaterIF97_ph.density_Unique20(
        LPT2.state_a))*Modelica.Fluid.Utilities.regRoot(1-LPT2.p_ratio^2, 0.01),
         LPT2.partialArc/LPT2.partialArc_nominal*LPT2.m_flow_nominal/
        LPT2.p_inlet_nominal*LPT2.p_in);
    else
      LPT2.m_flow = homotopy(LPT2.portHP.p*LPT2.partialArc*LPT2.m_flow_nominal/
        LPT2.p_inlet_nominal, LPT2.partialArc/LPT2.partialArc_nominal*
        LPT2.m_flow_nominal/LPT2.p_inlet_nominal*LPT2.p_in);
    end if;

  // Component moistureSeperator.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (moistureSeperator.medium.standardOrderComponents) then 
        moistureSeperator.medium.Xi = moistureSeperator.medium.X[1:0];
        moistureSeperator.medium.X = {1.0};
        for i in (1:1) loop
          assert(moistureSeperator.medium.X[i] >= -1E-05 and moistureSeperator.medium.X
            [i] <= 1.00001, "Mass fraction X["+       String(i, true, 0)+"] = "+
                   String(moistureSeperator.medium.X[i], true, 0)+
            "of substance "+({"water"})[i]+"\nof medium "+"WaterIF97"+
            " is not in the range 0..1");
        end for;
      end if;
      assert(moistureSeperator.medium.p >= 0.0, "Pressure (= "+       String(
        moistureSeperator.medium.p, true, 0)+" Pa) of medium \""+"WaterIF97"+
        "\" is negative\n(Temperature = "+       String(moistureSeperator.medium.T,
         true, 0)+" K)");
    // end of extends 
  equation
    moistureSeperator.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    moistureSeperator.medium.phase = (if moistureSeperator.medium.h < 
      Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique15(
      moistureSeperator.medium.sat) or moistureSeperator.medium.h > 
      Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique18(
      moistureSeperator.medium.sat) or moistureSeperator.medium.p > 
      _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].
      criticalPressure then 1 else 2);
    moistureSeperator.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique10
      (moistureSeperator.medium.p, moistureSeperator.medium.h, moistureSeperator.medium.phase,
       0);
    moistureSeperator.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique11
      (moistureSeperator.medium.p, moistureSeperator.medium.h, moistureSeperator.medium.phase,
       0);
    moistureSeperator.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique13
      (moistureSeperator.medium.p);
    moistureSeperator.medium.sat.psat = moistureSeperator.medium.p;
    moistureSeperator.medium.u = moistureSeperator.medium.h-moistureSeperator.medium.p
      /moistureSeperator.medium.d;
    moistureSeperator.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    moistureSeperator.medium.h = moistureSeperator.medium.state.h;
    moistureSeperator.medium.p = moistureSeperator.medium.state.p;
    moistureSeperator.medium.T = moistureSeperator.medium.state.T;
    moistureSeperator.medium.d = moistureSeperator.medium.state.d;
    moistureSeperator.medium.phase = moistureSeperator.medium.state.phase;

  // Component moistureSeperator
  // class TRANSFORM.Fluid.Volumes.Separator
    // extends TRANSFORM.Fluid.Volumes.BaseClasses.PartialVolume
    equation
      assert( not (moistureSeperator.energyDynamics <> Modelica.Fluid.Types.Dynamics.
        SteadyState and moistureSeperator.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) or false, "If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState' or Medium not conserving mass if volume is fixed.");
      moistureSeperator.m = moistureSeperator.V*moistureSeperator.medium.d;
      moistureSeperator.U = moistureSeperator.m*moistureSeperator.medium.u;
      moistureSeperator.mXi = moistureSeperator.m*moistureSeperator.medium.Xi;
      moistureSeperator.mC = moistureSeperator.m*moistureSeperator.C;
      if (moistureSeperator.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) then 
        0 = moistureSeperator.mb;
      else
        der(moistureSeperator.m) = moistureSeperator.mb;
      end if;
      if (moistureSeperator.energyDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) then 
        0 = moistureSeperator.Ub;
      else
        der(moistureSeperator.U) = moistureSeperator.Ub;
      end if;
      if (moistureSeperator.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) then 
        zeros(0) = moistureSeperator.mXib;
      else
        der(moistureSeperator.mXi) = moistureSeperator.mXib;
      end if;
      if (moistureSeperator.traceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) then 
        zeros(0) = moistureSeperator.mCb;
      else
        der(moistureSeperator.mC_scaled) = moistureSeperator.mCb./{};
        moistureSeperator.mC = moistureSeperator.mC_scaled.*{};
      end if;
    // extends TRANSFORM.Fluid.Volumes.MixingVolume
    equation
      if ( not moistureSeperator.use_HeatPort) then 
        moistureSeperator.Q_flow_internal = 0;
      end if;
      if ( not moistureSeperator.use_TraceMassPort) then 
        moistureSeperator.mC_flow_internal = zeros(0);
      end if;
      moistureSeperator.port_a.p = fill(moistureSeperator.medium.p+
        moistureSeperator.medium.d*moistureSeperator.g_n*0.5*moistureSeperator.geometry.dheight,
         moistureSeperator.nPorts_a);
      moistureSeperator.port_b.p = fill(moistureSeperator.medium.p-
        moistureSeperator.medium.d*moistureSeperator.g_n*0.5*moistureSeperator.geometry.dheight,
         moistureSeperator.nPorts_b);
      moistureSeperator.port_a.h_outflow = fill(moistureSeperator.medium.h, 
        moistureSeperator.nPorts_a);
      moistureSeperator.port_b.h_outflow = fill(moistureSeperator.medium.h, 
        moistureSeperator.nPorts_b);
      moistureSeperator.port_a.Xi_outflow = fill(moistureSeperator.medium.Xi, 
        moistureSeperator.nPorts_a);
      moistureSeperator.port_b.Xi_outflow = fill(moistureSeperator.medium.Xi, 
        moistureSeperator.nPorts_b);
      moistureSeperator.port_a.C_outflow = fill(moistureSeperator.C, 
        moistureSeperator.nPorts_a);
      moistureSeperator.port_b.C_outflow = fill(moistureSeperator.C, 
        moistureSeperator.nPorts_b);
      for i in (1:moistureSeperator.nPorts_a) loop
        moistureSeperator.H_flows_a[i] = moistureSeperator.port_a[i].m_flow*
          actualStream(moistureSeperator.port_a[i].h_outflow);
        moistureSeperator.mXi_flows_a[i, :] = moistureSeperator.port_a[i].m_flow
          *actualStream(moistureSeperator.port_a[i].Xi_outflow);
        moistureSeperator.mC_flows_a[i, :] = moistureSeperator.port_a[i].m_flow*
          actualStream(moistureSeperator.port_a[i].C_outflow);
      end for;
      for i in (1:moistureSeperator.nPorts_b) loop
        moistureSeperator.H_flows_b[i] = moistureSeperator.port_b[i].m_flow*
          actualStream(moistureSeperator.port_b[i].h_outflow);
        moistureSeperator.mXi_flows_b[i, :] = moistureSeperator.port_b[i].m_flow
          *actualStream(moistureSeperator.port_b[i].Xi_outflow);
        moistureSeperator.mC_flows_b[i, :] = moistureSeperator.port_b[i].m_flow*
          actualStream(moistureSeperator.port_b[i].C_outflow);
      end for;
    // end of extends 
  equation
    moistureSeperator.x_abs = noEvent((if moistureSeperator.medium.p/
      moistureSeperator.p_crit < 1.0 then max(0.0, min(1.0, (moistureSeperator.medium.h
      -moistureSeperator.h_lsat)/max(moistureSeperator.h_vsat-moistureSeperator.h_lsat,
       1E-06))) else 1.0));
    moistureSeperator.h_lsat = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_Unique2
      (
      Modelica.Media.Water.WaterIF97_ph.setBubbleState_Unique14(
        Modelica.Media.Water.WaterIF97_ph.setSat_p_Unique12(moistureSeperator.medium.p),
           
        1));
    moistureSeperator.h_vsat = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_Unique2
      (
      Modelica.Media.Water.WaterIF97_ph.setDewState_Unique17(
        Modelica.Media.Water.WaterIF97_ph.setSat_p_Unique12(moistureSeperator.medium.p),
           
        1));
    if (moistureSeperator.portMixed) then 
      moistureSeperator.m_flow_a_inflow = max(sum(moistureSeperator.port_a.
        m_flow), 0);
      moistureSeperator.m_flow_b_inflow = max(sum(moistureSeperator.port_b.
        m_flow), 0);
    else
      moistureSeperator.m_flow_a_inflow = sum(array(max(moistureSeperator.port_a
        [i].m_flow, 0) for i in 1:moistureSeperator.nPorts_a));
      moistureSeperator.m_flow_b_inflow = sum(array(max(moistureSeperator.port_b
        [i].m_flow, 0) for i in 1:moistureSeperator.nPorts_b));
    end if;
    moistureSeperator.m_flow_liquid =  -(1-moistureSeperator.x_abs)*(
      moistureSeperator.m_flow_a_inflow+moistureSeperator.m_flow_b_inflow)*
      moistureSeperator.eta_sep;
    moistureSeperator.port_Liquid.m_flow = moistureSeperator.m_flow_liquid;
    moistureSeperator.port_Liquid.h_outflow = noEvent((if moistureSeperator.x_abs
       > 0 then moistureSeperator.h_lsat else moistureSeperator.medium.h));
    moistureSeperator.port_Liquid.Xi_outflow = moistureSeperator.medium.Xi;
    moistureSeperator.port_Liquid.C_outflow = moistureSeperator.C;

  // Component LPT1_bypass.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (LPT1_bypass.medium.standardOrderComponents) then 
        LPT1_bypass.medium.Xi = LPT1_bypass.medium.X[1:0];
        LPT1_bypass.medium.X = {1.0};
        for i in (1:1) loop
          assert(LPT1_bypass.medium.X[i] >= -1E-05 and LPT1_bypass.medium.X[i]
             <= 1.00001, "Mass fraction X["+       String(i, true, 0)+"] = "+
                   String(LPT1_bypass.medium.X[i], true, 0)+"of substance "+({
            "water"})[i]+"\nof medium "+"WaterIF97"+" is not in the range 0..1");
        end for;
      end if;
      assert(LPT1_bypass.medium.p >= 0.0, "Pressure (= "+       String(
        LPT1_bypass.medium.p, true, 0)+" Pa) of medium \""+"WaterIF97"+
        "\" is negative\n(Temperature = "+       String(LPT1_bypass.medium.T, 
        true, 0)+" K)");
    // end of extends 
  equation
    LPT1_bypass.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    LPT1_bypass.medium.phase = (if LPT1_bypass.medium.h < Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique15
      (
      LPT1_bypass.medium.sat) or LPT1_bypass.medium.h > Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique18
      (
      LPT1_bypass.medium.sat) or LPT1_bypass.medium.p > _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .criticalPressure then 1 else 2);
    LPT1_bypass.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique10
      (LPT1_bypass.medium.p, LPT1_bypass.medium.h, LPT1_bypass.medium.phase, 0);
    LPT1_bypass.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique11
      (LPT1_bypass.medium.p, LPT1_bypass.medium.h, LPT1_bypass.medium.phase, 0);
    LPT1_bypass.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique13
      (LPT1_bypass.medium.p);
    LPT1_bypass.medium.sat.psat = LPT1_bypass.medium.p;
    LPT1_bypass.medium.u = LPT1_bypass.medium.h-LPT1_bypass.medium.p/
      LPT1_bypass.medium.d;
    LPT1_bypass.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    LPT1_bypass.medium.h = LPT1_bypass.medium.state.h;
    LPT1_bypass.medium.p = LPT1_bypass.medium.state.p;
    LPT1_bypass.medium.T = LPT1_bypass.medium.state.T;
    LPT1_bypass.medium.d = LPT1_bypass.medium.state.d;
    LPT1_bypass.medium.phase = LPT1_bypass.medium.state.phase;

  // Component LPT1_bypass
  // class TRANSFORM.Fluid.FittingsAndResistances.TeeJunctionVolume
    // extends TRANSFORM.Fluid.Volumes.BaseClasses.PartialVolume
    equation
      assert( not (LPT1_bypass.energyDynamics <> Modelica.Fluid.Types.Dynamics.
        SteadyState and LPT1_bypass.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) or false, "If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState' or Medium not conserving mass if volume is fixed.");
      LPT1_bypass.m = LPT1_bypass.V*LPT1_bypass.medium.d;
      LPT1_bypass.U = LPT1_bypass.m*LPT1_bypass.medium.u;
      LPT1_bypass.mXi = LPT1_bypass.m*LPT1_bypass.medium.Xi;
      LPT1_bypass.mC = LPT1_bypass.m*LPT1_bypass.C;
      if (LPT1_bypass.massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        0 = LPT1_bypass.mb;
      else
        der(LPT1_bypass.m) = LPT1_bypass.mb;
      end if;
      if (LPT1_bypass.energyDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) then 
        0 = LPT1_bypass.Ub;
      else
        der(LPT1_bypass.U) = LPT1_bypass.Ub;
      end if;
      if (LPT1_bypass.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) then 
        zeros(0) = LPT1_bypass.mXib;
      else
        der(LPT1_bypass.mXi) = LPT1_bypass.mXib;
      end if;
      if (LPT1_bypass.traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        zeros(0) = LPT1_bypass.mCb;
      else
        der(LPT1_bypass.mC_scaled) = LPT1_bypass.mCb./{};
        LPT1_bypass.mC = LPT1_bypass.mC_scaled.*{};
      end if;
    // end of extends 
  equation
    assert(cardinality(LPT1_bypass.port_1) <= 1, "
port_1 of volume can at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections which is usually not the intention
of the modeller.
");
    assert(cardinality(LPT1_bypass.port_2) <= 1, "
port_2 of volume can at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections which is usually not the intention
of the modeller.
");
    assert(cardinality(LPT1_bypass.port_3) <= 1, "
port_3 of volume can at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections which is usually not the intention
of the modeller.
");
    LPT1_bypass.port_1.h_outflow = LPT1_bypass.medium.h;
    LPT1_bypass.port_2.h_outflow = LPT1_bypass.medium.h;
    LPT1_bypass.port_3.h_outflow = LPT1_bypass.medium.h;
    LPT1_bypass.port_1.Xi_outflow = LPT1_bypass.medium.Xi;
    LPT1_bypass.port_2.Xi_outflow = LPT1_bypass.medium.Xi;
    LPT1_bypass.port_3.Xi_outflow = LPT1_bypass.medium.Xi;
    LPT1_bypass.port_1.C_outflow = LPT1_bypass.C;
    LPT1_bypass.port_2.C_outflow = LPT1_bypass.C;
    LPT1_bypass.port_3.C_outflow = LPT1_bypass.C;
    LPT1_bypass.port_1.p = LPT1_bypass.medium.p;
    LPT1_bypass.port_2.p = LPT1_bypass.medium.p;
    LPT1_bypass.port_3.p = LPT1_bypass.medium.p;

  // Component LPT1_bypass_valve
  // class TRANSFORM.Fluid.Valves.ValveLinear
    // extends TRANSFORM.Fluid.Valves.BaseClasses.PartialTwoPortTransport
    equation
      LPT1_bypass_valve.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9
        (LPT1_bypass_valve.port_a.p, inStream(LPT1_bypass_valve.port_a.h_outflow),
         inStream(LPT1_bypass_valve.port_a.Xi_outflow), 0, 0);
      LPT1_bypass_valve.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9
        (LPT1_bypass_valve.port_b.p, inStream(LPT1_bypass_valve.port_b.h_outflow),
         inStream(LPT1_bypass_valve.port_b.Xi_outflow), 0, 0);
      LPT1_bypass_valve.dp = LPT1_bypass_valve.port_a.p-LPT1_bypass_valve.port_b.p;
      LPT1_bypass_valve.m_flow = LPT1_bypass_valve.port_a.m_flow;
      assert(LPT1_bypass_valve.m_flow >  -LPT1_bypass_valve.m_flow_small or 
        LPT1_bypass_valve.allowFlowReversal, "Reverting flow occurs even though allowFlowReversal is false");
      LPT1_bypass_valve.port_a.m_flow+LPT1_bypass_valve.port_b.m_flow = 0;
      LPT1_bypass_valve.port_a.Xi_outflow = inStream(LPT1_bypass_valve.port_b.Xi_outflow);
      LPT1_bypass_valve.port_b.Xi_outflow = inStream(LPT1_bypass_valve.port_a.Xi_outflow);
      LPT1_bypass_valve.port_a.C_outflow = inStream(LPT1_bypass_valve.port_b.C_outflow);
      LPT1_bypass_valve.port_b.C_outflow = inStream(LPT1_bypass_valve.port_a.C_outflow);
    // end of extends 
  equation
    LPT1_bypass_valve.m_flow = LPT1_bypass_valve.opening*LPT1_bypass_valve.k*
      LPT1_bypass_valve.dp;
    LPT1_bypass_valve.port_a.h_outflow = inStream(LPT1_bypass_valve.port_b.h_outflow);
    LPT1_bypass_valve.port_b.h_outflow = inStream(LPT1_bypass_valve.port_a.h_outflow);

  // Component TBV
  // class TRANSFORM.Fluid.Valves.ValveLinear
    // extends TRANSFORM.Fluid.Valves.BaseClasses.PartialTwoPortTransport
    equation
      TBV.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(
        TBV.port_a.p, inStream(TBV.port_a.h_outflow), inStream(TBV.port_a.Xi_outflow),
         0, 0);
      TBV.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(
        TBV.port_b.p, inStream(TBV.port_b.h_outflow), inStream(TBV.port_b.Xi_outflow),
         0, 0);
      TBV.dp = TBV.port_a.p-TBV.port_b.p;
      TBV.m_flow = TBV.port_a.m_flow;
      assert(TBV.m_flow >  -TBV.m_flow_small or TBV.allowFlowReversal, 
        "Reverting flow occurs even though allowFlowReversal is false");
      TBV.port_a.m_flow+TBV.port_b.m_flow = 0;
      TBV.port_a.Xi_outflow = inStream(TBV.port_b.Xi_outflow);
      TBV.port_b.Xi_outflow = inStream(TBV.port_a.Xi_outflow);
      TBV.port_a.C_outflow = inStream(TBV.port_b.C_outflow);
      TBV.port_b.C_outflow = inStream(TBV.port_a.C_outflow);
    // end of extends 
  equation
    TBV.m_flow = TBV.opening*TBV.k*TBV.dp;
    TBV.port_a.h_outflow = inStream(TBV.port_b.h_outflow);
    TBV.port_b.h_outflow = inStream(TBV.port_a.h_outflow);

  // Component condenser
  // class TRANSFORM.Fluid.Volumes.IdealCondenser
  equation
    assert(condenser.V_liquid < condenser.V_total, "Liquid volume has exceed the total condenser volume.");
    condenser.sat.psat = condenser.p;
    condenser.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique13
      (condenser.p);
    condenser.m_liquid = condenser.V_liquid*condenser.rho_fsat;
    condenser.m_vapor = condenser.V_vapor*condenser.rho_gsat;
    condenser.V_total = condenser.V_vapor+condenser.V_liquid;
    condenser.m_total = condenser.m_liquid+condenser.m_vapor;
    condenser.E = condenser.m_liquid*condenser.h_fsat+condenser.m_vapor*inStream
      (condenser.port_a.h_outflow)-condenser.p*condenser.V_total;
    der(condenser.m_total) = condenser.port_a.m_flow+condenser.port_b.m_flow;
    der(condenser.E) = condenser.port_a.m_flow*actualStream(condenser.port_a.h_outflow)
      +condenser.port_b.m_flow*actualStream(condenser.port_b.h_outflow)+
      condenser.Q_total;
    condenser.port_a.p = condenser.p;
    if (condenser.set_m_flow) then 
      condenser.port_b.m_flow =  -condenser.port_a.m_flow;
    else
      condenser.port_b.p = condenser.p;
    end if;
    condenser.port_a.h_outflow = condenser.h_gsat;
    condenser.port_b.h_outflow = condenser.h_fsat;

  // Component generator
  // class TRANSFORM.Electrical.PowerConverters.Generator
  equation
    generator.omega_m = der(generator.shaft.phi);
    generator.omega_e = generator.omega_m*generator.nPoles;
    generator.f = generator.omega_e/6.283185307179586;
    generator.Q_mech = generator.omega_m*generator.tau;
    if (generator.J > 0) then 
      generator.Q_loss = generator.J*der(generator.omega_m)*generator.omega_m;
    else
      generator.Q_loss = 0;
    end if;
    generator.Q_mech = generator.Q_elec/generator.eta+generator.Q_loss;
    generator.f = generator.port.f;
    generator.Q_elec =  -generator.port.W;
    generator.tau = generator.shaft.tau;

  // Component pump
  // class NHES.Fluid.Machines.Pump_Pressure
    // extends TRANSFORM.Fluid.Machines.BaseClasses.PartialPump_Simple
    equation
      pump.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(
        pump.port_a.p, inStream(pump.port_a.h_outflow), inStream(
        pump.port_a.Xi_outflow), 0, 0);
      pump.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(
        pump.port_b.p, inStream(pump.port_b.h_outflow), inStream(
        pump.port_b.Xi_outflow), 0, 0);
      pump.dp = pump.port_b.p-pump.port_a.p;
      pump.port_a.m_flow+pump.port_b.m_flow = 0;
      pump.dh_ideal = pump.dp/Modelica.Media.Water.WaterIF97_ph.density_Unique20
        (
        pump.state_a);
      pump.dh*pump.eta_is = pump.dh_ideal;
      pump.Ub = pump.port_a.m_flow*actualStream(pump.port_a.h_outflow)+
        pump.port_b.m_flow*actualStream(pump.port_b.h_outflow)+pump.W*
        pump.nParallel;
      0 = pump.Ub;
      pump.m_flow = pump.port_a.m_flow/pump.nParallel;
      pump.port_a.h_outflow = inStream(pump.port_b.h_outflow)+pump.dh;
      pump.port_a.Xi_outflow = inStream(pump.port_b.Xi_outflow);
      pump.port_a.C_outflow = inStream(pump.port_b.C_outflow);
      pump.port_b.h_outflow = inStream(pump.port_a.h_outflow)+pump.dh;
      pump.port_b.Xi_outflow = inStream(pump.port_a.Xi_outflow);
      pump.port_b.C_outflow = inStream(pump.port_a.C_outflow);
    // end of extends 
  equation
    pump.eta_is = pump.eta;
    if ( not pump.use_input) then 
      pump.p_internal = pump.p_nominal;
    end if;
    pump.p = pump.p_internal;
    pump.port_b.p = pump.p;
    pump.port_a.Xi_outflow = inStream(pump.port_b.Xi_outflow);
    pump.port_b.Xi_outflow = inStream(pump.port_a.Xi_outflow);
    pump.port_a.C_outflow = inStream(pump.port_b.C_outflow);
    pump.port_b.C_outflow = inStream(pump.port_a.C_outflow);

  // Component pump1
  // class NHES.Fluid.Machines.Pump_Pressure
    // extends TRANSFORM.Fluid.Machines.BaseClasses.PartialPump_Simple
    equation
      pump1.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(
        pump1.port_a.p, inStream(pump1.port_a.h_outflow), inStream(
        pump1.port_a.Xi_outflow), 0, 0);
      pump1.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(
        pump1.port_b.p, inStream(pump1.port_b.h_outflow), inStream(
        pump1.port_b.Xi_outflow), 0, 0);
      pump1.dp = pump1.port_b.p-pump1.port_a.p;
      pump1.port_a.m_flow+pump1.port_b.m_flow = 0;
      pump1.dh_ideal = pump1.dp/Modelica.Media.Water.WaterIF97_ph.density_Unique20
        (
        pump1.state_a);
      pump1.dh*pump1.eta_is = pump1.dh_ideal;
      pump1.Ub = pump1.port_a.m_flow*actualStream(pump1.port_a.h_outflow)+
        pump1.port_b.m_flow*actualStream(pump1.port_b.h_outflow)+pump1.W*
        pump1.nParallel;
      0 = pump1.Ub;
      pump1.m_flow = pump1.port_a.m_flow/pump1.nParallel;
      pump1.port_a.h_outflow = inStream(pump1.port_b.h_outflow)+pump1.dh;
      pump1.port_a.Xi_outflow = inStream(pump1.port_b.Xi_outflow);
      pump1.port_a.C_outflow = inStream(pump1.port_b.C_outflow);
      pump1.port_b.h_outflow = inStream(pump1.port_a.h_outflow)+pump1.dh;
      pump1.port_b.Xi_outflow = inStream(pump1.port_a.Xi_outflow);
      pump1.port_b.C_outflow = inStream(pump1.port_a.C_outflow);
    // end of extends 
  equation
    pump1.eta_is = pump1.eta;
    if ( not pump1.use_input) then 
      pump1.p_internal = pump1.p_nominal;
    end if;
    pump1.p = pump1.p_internal;
    pump1.port_b.p = pump1.p;
    pump1.port_a.Xi_outflow = inStream(pump1.port_b.Xi_outflow);
    pump1.port_b.Xi_outflow = inStream(pump1.port_a.Xi_outflow);
    pump1.port_a.C_outflow = inStream(pump1.port_b.C_outflow);
    pump1.port_b.C_outflow = inStream(pump1.port_a.C_outflow);

  // Component OFWH_1.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (OFWH_1.medium.standardOrderComponents) then 
        OFWH_1.medium.Xi = OFWH_1.medium.X[1:0];
        OFWH_1.medium.X = {1.0};
        for i in (1:1) loop
          assert(OFWH_1.medium.X[i] >= -1E-05 and OFWH_1.medium.X[i] <= 1.00001,
             "Mass fraction X["+       String(i, true, 0)+"] = "+       String(
            OFWH_1.medium.X[i], true, 0)+"of substance "+({"water"})[i]+
            "\nof medium "+"WaterIF97"+" is not in the range 0..1");
        end for;
      end if;
      assert(OFWH_1.medium.p >= 0.0, "Pressure (= "+       String(
        OFWH_1.medium.p, true, 0)+" Pa) of medium \""+"WaterIF97"+
        "\" is negative\n(Temperature = "+       String(OFWH_1.medium.T, true, 0)
        +" K)");
    // end of extends 
  equation
    OFWH_1.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    OFWH_1.medium.phase = (if OFWH_1.medium.h < Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique15
      (
      OFWH_1.medium.sat) or OFWH_1.medium.h > Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique18
      (
      OFWH_1.medium.sat) or OFWH_1.medium.p > _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .criticalPressure then 1 else 2);
    OFWH_1.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique10(
      OFWH_1.medium.p, OFWH_1.medium.h, OFWH_1.medium.phase, 0);
    OFWH_1.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique11(
      OFWH_1.medium.p, OFWH_1.medium.h, OFWH_1.medium.phase, 0);
    OFWH_1.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique13
      (OFWH_1.medium.p);
    OFWH_1.medium.sat.psat = OFWH_1.medium.p;
    OFWH_1.medium.u = OFWH_1.medium.h-OFWH_1.medium.p/OFWH_1.medium.d;
    OFWH_1.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    OFWH_1.medium.h = OFWH_1.medium.state.h;
    OFWH_1.medium.p = OFWH_1.medium.state.p;
    OFWH_1.medium.T = OFWH_1.medium.state.T;
    OFWH_1.medium.d = OFWH_1.medium.state.d;
    OFWH_1.medium.phase = OFWH_1.medium.state.phase;

  // Component OFWH_1
  // class TRANSFORM.Fluid.Volumes.SimpleVolume
    // extends TRANSFORM.Fluid.Volumes.BaseClasses.PartialVolume
    equation
      assert( not (OFWH_1.energyDynamics <> Modelica.Fluid.Types.Dynamics.
        SteadyState and OFWH_1.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) or false, "If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState' or Medium not conserving mass if volume is fixed.");
      OFWH_1.m = OFWH_1.V*OFWH_1.medium.d;
      OFWH_1.U = OFWH_1.m*OFWH_1.medium.u;
      OFWH_1.mXi = OFWH_1.m*OFWH_1.medium.Xi;
      OFWH_1.mC = OFWH_1.m*OFWH_1.C;
      if (OFWH_1.massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        0 = OFWH_1.mb;
      else
        der(OFWH_1.m) = OFWH_1.mb;
      end if;
      if (OFWH_1.energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        0 = OFWH_1.Ub;
      else
        der(OFWH_1.U) = OFWH_1.Ub;
      end if;
      if (OFWH_1.substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        zeros(0) = OFWH_1.mXib;
      else
        der(OFWH_1.mXi) = OFWH_1.mXib;
      end if;
      if (OFWH_1.traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        zeros(0) = OFWH_1.mCb;
      else
        der(OFWH_1.mC_scaled) = OFWH_1.mCb./{};
        OFWH_1.mC = OFWH_1.mC_scaled.*{};
      end if;
    // end of extends 
  equation
    if ( not OFWH_1.use_HeatPort) then 
      OFWH_1.Q_flow_internal = 0;
    end if;
    if ( not OFWH_1.use_TraceMassPort) then 
      OFWH_1.mC_flow_internal = zeros(0);
    end if;
    OFWH_1.port_a.p = OFWH_1.medium.p+OFWH_1.medium.d*OFWH_1.g_n*0.5*
      OFWH_1.geometry.dheight;
    OFWH_1.port_b.p = OFWH_1.medium.p-OFWH_1.medium.d*OFWH_1.g_n*0.5*
      OFWH_1.geometry.dheight;
    OFWH_1.port_a.h_outflow = OFWH_1.medium.h;
    OFWH_1.port_b.h_outflow = OFWH_1.medium.h;
    OFWH_1.port_a.Xi_outflow = OFWH_1.medium.Xi;
    OFWH_1.port_b.Xi_outflow = OFWH_1.medium.Xi;
    OFWH_1.port_a.C_outflow = OFWH_1.C;
    OFWH_1.port_b.C_outflow = OFWH_1.C;

  // Component HPT_bypass_valve
  // class TRANSFORM.Fluid.Valves.ValveLinear
    // extends TRANSFORM.Fluid.Valves.BaseClasses.PartialTwoPortTransport
    equation
      HPT_bypass_valve.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9
        (HPT_bypass_valve.port_a.p, inStream(HPT_bypass_valve.port_a.h_outflow),
         inStream(HPT_bypass_valve.port_a.Xi_outflow), 0, 0);
      HPT_bypass_valve.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9
        (HPT_bypass_valve.port_b.p, inStream(HPT_bypass_valve.port_b.h_outflow),
         inStream(HPT_bypass_valve.port_b.Xi_outflow), 0, 0);
      HPT_bypass_valve.dp = HPT_bypass_valve.port_a.p-HPT_bypass_valve.port_b.p;
      HPT_bypass_valve.m_flow = HPT_bypass_valve.port_a.m_flow;
      assert(HPT_bypass_valve.m_flow >  -HPT_bypass_valve.m_flow_small or 
        HPT_bypass_valve.allowFlowReversal, "Reverting flow occurs even though allowFlowReversal is false");
      HPT_bypass_valve.port_a.m_flow+HPT_bypass_valve.port_b.m_flow = 0;
      HPT_bypass_valve.port_a.Xi_outflow = inStream(HPT_bypass_valve.port_b.Xi_outflow);
      HPT_bypass_valve.port_b.Xi_outflow = inStream(HPT_bypass_valve.port_a.Xi_outflow);
      HPT_bypass_valve.port_a.C_outflow = inStream(HPT_bypass_valve.port_b.C_outflow);
      HPT_bypass_valve.port_b.C_outflow = inStream(HPT_bypass_valve.port_a.C_outflow);
    // end of extends 
  equation
    HPT_bypass_valve.m_flow = HPT_bypass_valve.opening*HPT_bypass_valve.k*
      HPT_bypass_valve.dp;
    HPT_bypass_valve.port_a.h_outflow = inStream(HPT_bypass_valve.port_b.h_outflow);
    HPT_bypass_valve.port_b.h_outflow = inStream(HPT_bypass_valve.port_a.h_outflow);

  // Component OFWH_2.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (OFWH_2.medium.standardOrderComponents) then 
        OFWH_2.medium.Xi = OFWH_2.medium.X[1:0];
        OFWH_2.medium.X = {1.0};
        for i in (1:1) loop
          assert(OFWH_2.medium.X[i] >= -1E-05 and OFWH_2.medium.X[i] <= 1.00001,
             "Mass fraction X["+       String(i, true, 0)+"] = "+       String(
            OFWH_2.medium.X[i], true, 0)+"of substance "+({"water"})[i]+
            "\nof medium "+"WaterIF97"+" is not in the range 0..1");
        end for;
      end if;
      assert(OFWH_2.medium.p >= 0.0, "Pressure (= "+       String(
        OFWH_2.medium.p, true, 0)+" Pa) of medium \""+"WaterIF97"+
        "\" is negative\n(Temperature = "+       String(OFWH_2.medium.T, true, 0)
        +" K)");
    // end of extends 
  equation
    OFWH_2.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    OFWH_2.medium.phase = (if OFWH_2.medium.h < Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique15
      (
      OFWH_2.medium.sat) or OFWH_2.medium.h > Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique18
      (
      OFWH_2.medium.sat) or OFWH_2.medium.p > _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .criticalPressure then 1 else 2);
    OFWH_2.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique10(
      OFWH_2.medium.p, OFWH_2.medium.h, OFWH_2.medium.phase, 0);
    OFWH_2.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique11(
      OFWH_2.medium.p, OFWH_2.medium.h, OFWH_2.medium.phase, 0);
    OFWH_2.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique13
      (OFWH_2.medium.p);
    OFWH_2.medium.sat.psat = OFWH_2.medium.p;
    OFWH_2.medium.u = OFWH_2.medium.h-OFWH_2.medium.p/OFWH_2.medium.d;
    OFWH_2.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    OFWH_2.medium.h = OFWH_2.medium.state.h;
    OFWH_2.medium.p = OFWH_2.medium.state.p;
    OFWH_2.medium.T = OFWH_2.medium.state.T;
    OFWH_2.medium.d = OFWH_2.medium.state.d;
    OFWH_2.medium.phase = OFWH_2.medium.state.phase;

  // Component OFWH_2
  // class TRANSFORM.Fluid.Volumes.SimpleVolume
    // extends TRANSFORM.Fluid.Volumes.BaseClasses.PartialVolume
    equation
      assert( not (OFWH_2.energyDynamics <> Modelica.Fluid.Types.Dynamics.
        SteadyState and OFWH_2.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) or false, "If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState' or Medium not conserving mass if volume is fixed.");
      OFWH_2.m = OFWH_2.V*OFWH_2.medium.d;
      OFWH_2.U = OFWH_2.m*OFWH_2.medium.u;
      OFWH_2.mXi = OFWH_2.m*OFWH_2.medium.Xi;
      OFWH_2.mC = OFWH_2.m*OFWH_2.C;
      if (OFWH_2.massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        0 = OFWH_2.mb;
      else
        der(OFWH_2.m) = OFWH_2.mb;
      end if;
      if (OFWH_2.energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        0 = OFWH_2.Ub;
      else
        der(OFWH_2.U) = OFWH_2.Ub;
      end if;
      if (OFWH_2.substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        zeros(0) = OFWH_2.mXib;
      else
        der(OFWH_2.mXi) = OFWH_2.mXib;
      end if;
      if (OFWH_2.traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        zeros(0) = OFWH_2.mCb;
      else
        der(OFWH_2.mC_scaled) = OFWH_2.mCb./{};
        OFWH_2.mC = OFWH_2.mC_scaled.*{};
      end if;
    // end of extends 
  equation
    if ( not OFWH_2.use_HeatPort) then 
      OFWH_2.Q_flow_internal = 0;
    end if;
    if ( not OFWH_2.use_TraceMassPort) then 
      OFWH_2.mC_flow_internal = zeros(0);
    end if;
    OFWH_2.port_a.p = OFWH_2.medium.p+OFWH_2.medium.d*OFWH_2.g_n*0.5*
      OFWH_2.geometry.dheight;
    OFWH_2.port_b.p = OFWH_2.medium.p-OFWH_2.medium.d*OFWH_2.g_n*0.5*
      OFWH_2.geometry.dheight;
    OFWH_2.port_a.h_outflow = OFWH_2.medium.h;
    OFWH_2.port_b.h_outflow = OFWH_2.medium.h;
    OFWH_2.port_a.Xi_outflow = OFWH_2.medium.Xi;
    OFWH_2.port_b.Xi_outflow = OFWH_2.medium.Xi;
    OFWH_2.port_a.C_outflow = OFWH_2.C;
    OFWH_2.port_b.C_outflow = OFWH_2.C;

  // Component FWCP
  // class NHES.Fluid.Machines.Pump_MassFlow
    // extends TRANSFORM.Fluid.Machines.BaseClasses.PartialPump_Simple
    equation
      FWCP.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(
        FWCP.port_a.p, inStream(FWCP.port_a.h_outflow), inStream(
        FWCP.port_a.Xi_outflow), 0, 0);
      FWCP.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(
        FWCP.port_b.p, inStream(FWCP.port_b.h_outflow), inStream(
        FWCP.port_b.Xi_outflow), 0, 0);
      FWCP.dp = FWCP.port_b.p-FWCP.port_a.p;
      FWCP.port_a.m_flow+FWCP.port_b.m_flow = 0;
      FWCP.dh_ideal = FWCP.dp/Modelica.Media.Water.WaterIF97_ph.density_Unique20
        (
        FWCP.state_a);
      FWCP.dh*FWCP.eta_is = FWCP.dh_ideal;
      FWCP.Ub = FWCP.port_a.m_flow*actualStream(FWCP.port_a.h_outflow)+
        FWCP.port_b.m_flow*actualStream(FWCP.port_b.h_outflow)+FWCP.W*
        FWCP.nParallel;
      0 = FWCP.Ub;
      FWCP.m_flow = FWCP.port_a.m_flow/FWCP.nParallel;
      FWCP.port_a.h_outflow = inStream(FWCP.port_b.h_outflow)+FWCP.dh;
      FWCP.port_a.Xi_outflow = inStream(FWCP.port_b.Xi_outflow);
      FWCP.port_a.C_outflow = inStream(FWCP.port_b.C_outflow);
      FWCP.port_b.h_outflow = inStream(FWCP.port_a.h_outflow)+FWCP.dh;
      FWCP.port_b.Xi_outflow = inStream(FWCP.port_a.Xi_outflow);
      FWCP.port_b.C_outflow = inStream(FWCP.port_a.C_outflow);
    // end of extends 
  equation
    FWCP.eta_is = FWCP.eta;
    if ( not FWCP.use_input) then 
      FWCP.m_flow_internal = FWCP.m_flow_nominal;
    end if;
    FWCP.m_flow = FWCP.m_flow_internal;
    FWCP.port_a.Xi_outflow = inStream(FWCP.port_b.Xi_outflow);
    FWCP.port_b.Xi_outflow = inStream(FWCP.port_a.Xi_outflow);
    FWCP.port_a.C_outflow = inStream(FWCP.port_b.C_outflow);
    FWCP.port_b.C_outflow = inStream(FWCP.port_a.C_outflow);

  // Component TCV
  // class TRANSFORM.Fluid.Valves.ValveLinear
    // extends TRANSFORM.Fluid.Valves.BaseClasses.PartialTwoPortTransport
    equation
      TCV.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(
        TCV.port_a.p, inStream(TCV.port_a.h_outflow), inStream(TCV.port_a.Xi_outflow),
         0, 0);
      TCV.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique9(
        TCV.port_b.p, inStream(TCV.port_b.h_outflow), inStream(TCV.port_b.Xi_outflow),
         0, 0);
      TCV.dp = TCV.port_a.p-TCV.port_b.p;
      TCV.m_flow = TCV.port_a.m_flow;
      assert(TCV.m_flow >  -TCV.m_flow_small or TCV.allowFlowReversal, 
        "Reverting flow occurs even though allowFlowReversal is false");
      TCV.port_a.m_flow+TCV.port_b.m_flow = 0;
      TCV.port_a.Xi_outflow = inStream(TCV.port_b.Xi_outflow);
      TCV.port_b.Xi_outflow = inStream(TCV.port_a.Xi_outflow);
      TCV.port_a.C_outflow = inStream(TCV.port_b.C_outflow);
      TCV.port_b.C_outflow = inStream(TCV.port_a.C_outflow);
    // end of extends 
  equation
    TCV.m_flow = TCV.opening*TCV.k*TCV.dp;
    TCV.port_a.h_outflow = inStream(TCV.port_b.h_outflow);
    TCV.port_b.h_outflow = inStream(TCV.port_a.h_outflow);

  // Component Feed_T
  // class TRANSFORM.Fluid.Sensors.Temperature
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      Feed_T.port.m_flow = 0;
      Feed_T.port.h_outflow = 84013.0581525969;
      Feed_T.port.Xi_outflow = {};
      Feed_T.port.C_outflow = zeros(0);
    // end of extends 
  equation
    Feed_T.T = Modelica.Media.Water.WaterIF97_ph.temperature_Unique36(
      Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique37(Feed_T.port.p, 
        inStream(Feed_T.port.h_outflow), inStream(Feed_T.port.Xi_outflow), 0, 0));

  // Component Steam_T
  // class TRANSFORM.Fluid.Sensors.Temperature
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      Steam_T.port.m_flow = 0;
      Steam_T.port.h_outflow = 84013.0581525969;
      Steam_T.port.Xi_outflow = {};
      Steam_T.port.C_outflow = zeros(0);
    // end of extends 
  equation
    Steam_T.T = Modelica.Media.Water.WaterIF97_ph.temperature_Unique36(
      Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique37(Steam_T.port.p, 
        inStream(Steam_T.port.h_outflow), inStream(Steam_T.port.Xi_outflow), 0, 0));

  // Component sensor_p
  // class TRANSFORM.Fluid.Sensors.Pressure
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      sensor_p.port.m_flow = 0;
      sensor_p.port.h_outflow = 84013.0581525969;
      sensor_p.port.Xi_outflow = {};
      sensor_p.port.C_outflow = zeros(0);
    // end of extends 
  equation
    sensor_p.p = sensor_p.port.p;

  // Component sensorW
  // class TRANSFORM.Electrical.Sensors.PowerSensor
  equation
    sensorW.port_a.W+sensorW.port_b.W = 0;
    sensorW.port_a.f = sensorW.port_b.f;
    sensorW.W = sensorW.port_a.W;

  // Component delay2.sensor_p
  // class TRANSFORM.Fluid.Sensors.Pressure
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      delay2.sensor_p.port.m_flow = 0;
      delay2.sensor_p.port.h_outflow = 84013.0581525969;
      delay2.sensor_p.port.Xi_outflow = {};
      delay2.sensor_p.port.C_outflow = zeros(0);
    // end of extends 
  equation
    delay2.sensor_p.p = delay2.sensor_p.port.p;

  // Component delay2.sensor_m_flow
  // class TRANSFORM.Fluid.Sensors.MassFlowRate
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialTwoPortSensor
    equation
      0 = delay2.sensor_m_flow.port_a.m_flow+delay2.sensor_m_flow.port_b.m_flow;
      delay2.sensor_m_flow.port_a.p = delay2.sensor_m_flow.port_b.p;
      delay2.sensor_m_flow.port_a.h_outflow = inStream(delay2.sensor_m_flow.port_b.h_outflow);
      delay2.sensor_m_flow.port_b.h_outflow = inStream(delay2.sensor_m_flow.port_a.h_outflow);
      delay2.sensor_m_flow.port_a.Xi_outflow = inStream(delay2.sensor_m_flow.port_b.Xi_outflow);
      delay2.sensor_m_flow.port_b.Xi_outflow = inStream(delay2.sensor_m_flow.port_a.Xi_outflow);
      delay2.sensor_m_flow.port_a.C_outflow = inStream(delay2.sensor_m_flow.port_b.C_outflow);
      delay2.sensor_m_flow.port_b.C_outflow = inStream(delay2.sensor_m_flow.port_a.C_outflow);
    // end of extends 
  equation
    delay2.sensor_m_flow.m_flow = delay2.sensor_m_flow.port_a.m_flow;

  // Component delay2.sensor_h
  // class TRANSFORM.Fluid.Sensors.SpecificEnthalpy
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      delay2.sensor_h.port.m_flow = 0;
      delay2.sensor_h.port.h_outflow = 84013.0581525969;
      delay2.sensor_h.port.Xi_outflow = {};
      delay2.sensor_h.port.C_outflow = zeros(0);
    // end of extends 
  equation
    delay2.sensor_h.h_out = inStream(delay2.sensor_h.port.h_outflow);

  // Component delay2.boundary.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (delay2.boundary.medium.standardOrderComponents) then 
        delay2.boundary.medium.Xi = delay2.boundary.medium.X[1:0];
        delay2.boundary.medium.X = {1.0};
        for i in (1:1) loop
          assert(delay2.boundary.medium.X[i] >= -1E-05 and delay2.boundary.medium.X
            [i] <= 1.00001, "Mass fraction X["+       String(i, true, 0)+"] = "+
                   String(delay2.boundary.medium.X[i], true, 0)+"of substance "+
            ({"water"})[i]+"\nof medium "+"WaterIF97"+" is not in the range 0..1");
        end for;
      end if;
      assert(delay2.boundary.medium.p >= 0.0, "Pressure (= "+       String(
        delay2.boundary.medium.p, true, 0)+" Pa) of medium \""+"WaterIF97"+
        "\" is negative\n(Temperature = "+       String(delay2.boundary.medium.T,
         true, 0)+" K)");
    // end of extends 
  equation
    delay2.boundary.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    delay2.boundary.medium.phase = (if delay2.boundary.medium.h < 
      Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique15(
      delay2.boundary.medium.sat) or delay2.boundary.medium.h > Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique18
      (
      delay2.boundary.medium.sat) or delay2.boundary.medium.p > _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .criticalPressure then 1 else 2);
    delay2.boundary.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique10
      (delay2.boundary.medium.p, delay2.boundary.medium.h, delay2.boundary.medium.phase,
       0);
    delay2.boundary.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique11
      (delay2.boundary.medium.p, delay2.boundary.medium.h, delay2.boundary.medium.phase,
       0);
    delay2.boundary.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique13
      (delay2.boundary.medium.p);
    delay2.boundary.medium.sat.psat = delay2.boundary.medium.p;
    delay2.boundary.medium.u = delay2.boundary.medium.h-delay2.boundary.medium.p
      /delay2.boundary.medium.d;
    delay2.boundary.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    delay2.boundary.medium.h = delay2.boundary.medium.state.h;
    delay2.boundary.medium.p = delay2.boundary.medium.state.p;
    delay2.boundary.medium.T = delay2.boundary.medium.state.T;
    delay2.boundary.medium.d = delay2.boundary.medium.state.d;
    delay2.boundary.medium.phase = delay2.boundary.medium.state.phase;

  // Component delay2.boundary
  // class TRANSFORM.Fluid.BoundaryConditions.Boundary_ph
    // extends TRANSFORM.Fluid.BoundaryConditions.BaseClasses.PartialSource
    equation
      for i in (1:delay2.boundary.nPorts) loop
        assert(cardinality(delay2.boundary.ports[i]) <= 1, "
each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
        delay2.boundary.ports[i].p = delay2.boundary.medium.p;
        delay2.boundary.ports[i].h_outflow = delay2.boundary.medium.h;
        delay2.boundary.ports[i].Xi_outflow = delay2.boundary.medium.Xi;
      end for;
    // end of extends 
  equation
    Modelica.Fluid.Utilities.checkBoundary("WaterIF97", {"water"}, false, true, 
      delay2.boundary.X_in_internal, "Boundary_ph");
    if ( not delay2.boundary.use_p_in) then 
      delay2.boundary.p_in_internal = delay2.boundary.p;
    end if;
    if ( not delay2.boundary.use_h_in) then 
      delay2.boundary.h_in_internal = delay2.boundary.h;
    end if;
    if ( not delay2.boundary.use_X_in) then 
      delay2.boundary.X_in_internal = delay2.boundary.X;
    end if;
    if ( not delay2.boundary.use_C_in) then 
      delay2.boundary.C_in_internal = delay2.boundary.C;
    end if;
    delay2.boundary.medium.p = delay2.boundary.p_in_internal;
    delay2.boundary.medium.h = delay2.boundary.h_in_internal;
    delay2.boundary.medium.Xi = delay2.boundary.X_in_internal[1:0];
    delay2.boundary.ports.C_outflow = fill(delay2.boundary.C_in_internal, 
      delay2.boundary.nPorts);
    delay2.boundary.p_in_internal = delay2.boundary.p_in;

  // Component delay2.boundary1.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (delay2.boundary1.medium.standardOrderComponents) then 
        delay2.boundary1.medium.Xi = delay2.boundary1.medium.X[1:0];
        delay2.boundary1.medium.X = {1.0};
        for i in (1:1) loop
          assert(delay2.boundary1.medium.X[i] >= -1E-05 and delay2.boundary1.medium.X
            [i] <= 1.00001, "Mass fraction X["+       String(i, true, 0)+"] = "+
                   String(delay2.boundary1.medium.X[i], true, 0)+"of substance "
            +({"water"})[i]+"\nof medium "+"WaterIF97"+" is not in the range 0..1");
        end for;
      end if;
      assert(delay2.boundary1.medium.p >= 0.0, "Pressure (= "+       String(
        delay2.boundary1.medium.p, true, 0)+" Pa) of medium \""+"WaterIF97"+
        "\" is negative\n(Temperature = "+       String(delay2.boundary1.medium.T,
         true, 0)+" K)");
    // end of extends 
  equation
    delay2.boundary1.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    delay2.boundary1.medium.phase = (if delay2.boundary1.medium.h < 
      Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique15(
      delay2.boundary1.medium.sat) or delay2.boundary1.medium.h > 
      Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique18(
      delay2.boundary1.medium.sat) or delay2.boundary1.medium.p > 
      _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].
      criticalPressure then 1 else 2);
    delay2.boundary1.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique10
      (delay2.boundary1.medium.p, delay2.boundary1.medium.h, delay2.boundary1.medium.phase,
       0);
    delay2.boundary1.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique11
      (delay2.boundary1.medium.p, delay2.boundary1.medium.h, delay2.boundary1.medium.phase,
       0);
    delay2.boundary1.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique13
      (delay2.boundary1.medium.p);
    delay2.boundary1.medium.sat.psat = delay2.boundary1.medium.p;
    delay2.boundary1.medium.u = delay2.boundary1.medium.h-delay2.boundary1.medium.p
      /delay2.boundary1.medium.d;
    delay2.boundary1.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    delay2.boundary1.medium.h = delay2.boundary1.medium.state.h;
    delay2.boundary1.medium.p = delay2.boundary1.medium.state.p;
    delay2.boundary1.medium.T = delay2.boundary1.medium.state.T;
    delay2.boundary1.medium.d = delay2.boundary1.medium.state.d;
    delay2.boundary1.medium.phase = delay2.boundary1.medium.state.phase;

  // Component delay2.boundary1
  // class TRANSFORM.Fluid.BoundaryConditions.MassFlowSource_h
    // extends TRANSFORM.Fluid.BoundaryConditions.BaseClasses.PartialFlowSource
    equation
      assert(abs(sum(abs(delay2.boundary1.ports.m_flow))-max(abs(
        delay2.boundary1.ports.m_flow))) <= 1E-60, "FlowSource only supports one connection with flow");
      for i in (1:delay2.boundary1.nPorts) loop
        assert(cardinality(delay2.boundary1.ports[i]) <= 1, "
each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
        delay2.boundary1.ports[i].p = delay2.boundary1.medium.p;
        delay2.boundary1.ports[i].h_outflow = delay2.boundary1.medium.h;
        delay2.boundary1.ports[i].Xi_outflow = delay2.boundary1.medium.Xi;
      end for;
    // end of extends 
  equation
    Modelica.Fluid.Utilities.checkBoundary("WaterIF97", {"water"}, false, true, 
      delay2.boundary1.X_in_internal, "MassFlowSource_h");
    if ( not delay2.boundary1.use_m_flow_in) then 
      delay2.boundary1.m_flow_in_internal = delay2.boundary1.m_flow;
    end if;
    if ( not delay2.boundary1.use_h_in) then 
      delay2.boundary1.h_in_internal = delay2.boundary1.h;
    end if;
    if ( not delay2.boundary1.use_X_in) then 
      delay2.boundary1.X_in_internal = delay2.boundary1.X;
    end if;
    if ( not delay2.boundary1.use_C_in) then 
      delay2.boundary1.C_in_internal = delay2.boundary1.C;
    end if;
    delay2.boundary1.medium.h = delay2.boundary1.h_in_internal;
    sum(delay2.boundary1.ports.m_flow) =  -delay2.boundary1.m_flow_in_internal;
    delay2.boundary1.medium.Xi = delay2.boundary1.X_in_internal[1:0];
    delay2.boundary1.ports.C_outflow = fill(delay2.boundary1.C_in_internal, 
      delay2.boundary1.nPorts);
    delay2.boundary1.h_in_internal = delay2.boundary1.h_in;
    delay2.boundary1.m_flow_in_internal = delay2.boundary1.m_flow_in;

  // Component delay2.limiter1
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(delay2.limiter1.uMax >= delay2.limiter1.uMin, "Limiter: Limits must be consistent. However, uMax (="
      +       String(delay2.limiter1.uMax, true, 0)+") < uMin (="+       String(
      delay2.limiter1.uMin, true, 0)+")");
    delay2.limiter1.simplifiedExpr = (if delay2.limiter1.homotopyType == 
      Modelica.Blocks.Types.LimiterHomotopy.Linear then delay2.limiter1.u else (
      if delay2.limiter1.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then delay2.limiter1.uMax else (if delay2.limiter1.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then delay2.limiter1.uMin
       else 0)));
    if (delay2.limiter1.strict) then 
      if (delay2.limiter1.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        delay2.limiter1.y = smooth(0, noEvent((if delay2.limiter1.u > 
          delay2.limiter1.uMax then delay2.limiter1.uMax else (if 
          delay2.limiter1.u < delay2.limiter1.uMin then delay2.limiter1.uMin
           else delay2.limiter1.u))));
      else
        delay2.limiter1.y = homotopy(smooth(0, noEvent((if delay2.limiter1.u > 
          delay2.limiter1.uMax then delay2.limiter1.uMax else (if 
          delay2.limiter1.u < delay2.limiter1.uMin then delay2.limiter1.uMin
           else delay2.limiter1.u)))), delay2.limiter1.simplifiedExpr);
      end if;
    else
      if (delay2.limiter1.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        delay2.limiter1.y = smooth(0, (if delay2.limiter1.u > delay2.limiter1.uMax
           then delay2.limiter1.uMax else (if delay2.limiter1.u < 
          delay2.limiter1.uMin then delay2.limiter1.uMin else delay2.limiter1.u)));
      else
        delay2.limiter1.y = homotopy(smooth(0, (if delay2.limiter1.u > 
          delay2.limiter1.uMax then delay2.limiter1.uMax else (if 
          delay2.limiter1.u < delay2.limiter1.uMin then delay2.limiter1.uMin
           else delay2.limiter1.u))), delay2.limiter1.simplifiedExpr);
      end if;
    end if;

  // Component delay2.limiter2
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(delay2.limiter2.uMax >= delay2.limiter2.uMin, "Limiter: Limits must be consistent. However, uMax (="
      +       String(delay2.limiter2.uMax, true, 0)+") < uMin (="+       String(
      delay2.limiter2.uMin, true, 0)+")");
    delay2.limiter2.simplifiedExpr = (if delay2.limiter2.homotopyType == 
      Modelica.Blocks.Types.LimiterHomotopy.Linear then delay2.limiter2.u else (
      if delay2.limiter2.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then delay2.limiter2.uMax else (if delay2.limiter2.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then delay2.limiter2.uMin
       else 0)));
    if (delay2.limiter2.strict) then 
      if (delay2.limiter2.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        delay2.limiter2.y = smooth(0, noEvent((if delay2.limiter2.u > 
          delay2.limiter2.uMax then delay2.limiter2.uMax else (if 
          delay2.limiter2.u < delay2.limiter2.uMin then delay2.limiter2.uMin
           else delay2.limiter2.u))));
      else
        delay2.limiter2.y = homotopy(smooth(0, noEvent((if delay2.limiter2.u > 
          delay2.limiter2.uMax then delay2.limiter2.uMax else (if 
          delay2.limiter2.u < delay2.limiter2.uMin then delay2.limiter2.uMin
           else delay2.limiter2.u)))), delay2.limiter2.simplifiedExpr);
      end if;
    else
      if (delay2.limiter2.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        delay2.limiter2.y = smooth(0, (if delay2.limiter2.u > delay2.limiter2.uMax
           then delay2.limiter2.uMax else (if delay2.limiter2.u < 
          delay2.limiter2.uMin then delay2.limiter2.uMin else delay2.limiter2.u)));
      else
        delay2.limiter2.y = homotopy(smooth(0, (if delay2.limiter2.u > 
          delay2.limiter2.uMax then delay2.limiter2.uMax else (if 
          delay2.limiter2.u < delay2.limiter2.uMin then delay2.limiter2.uMin
           else delay2.limiter2.u))), delay2.limiter2.simplifiedExpr);
      end if;
    end if;

  // Component delay2.limiter
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(delay2.limiter.uMax >= delay2.limiter.uMin, "Limiter: Limits must be consistent. However, uMax (="
      +       String(delay2.limiter.uMax, true, 0)+") < uMin (="+       String(
      delay2.limiter.uMin, true, 0)+")");
    delay2.limiter.simplifiedExpr = (if delay2.limiter.homotopyType == 
      Modelica.Blocks.Types.LimiterHomotopy.Linear then delay2.limiter.u else (
      if delay2.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then delay2.limiter.uMax else (if delay2.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then delay2.limiter.uMin
       else 0)));
    if (delay2.limiter.strict) then 
      if (delay2.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        delay2.limiter.y = smooth(0, noEvent((if delay2.limiter.u > 
          delay2.limiter.uMax then delay2.limiter.uMax else (if delay2.limiter.u
           < delay2.limiter.uMin then delay2.limiter.uMin else delay2.limiter.u))));
      else
        delay2.limiter.y = homotopy(smooth(0, noEvent((if delay2.limiter.u > 
          delay2.limiter.uMax then delay2.limiter.uMax else (if delay2.limiter.u
           < delay2.limiter.uMin then delay2.limiter.uMin else delay2.limiter.u)))),
           delay2.limiter.simplifiedExpr);
      end if;
    else
      if (delay2.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        delay2.limiter.y = smooth(0, (if delay2.limiter.u > delay2.limiter.uMax
           then delay2.limiter.uMax else (if delay2.limiter.u < delay2.limiter.uMin
           then delay2.limiter.uMin else delay2.limiter.u)));
      else
        delay2.limiter.y = homotopy(smooth(0, (if delay2.limiter.u > 
          delay2.limiter.uMax then delay2.limiter.uMax else (if delay2.limiter.u
           < delay2.limiter.uMin then delay2.limiter.uMin else delay2.limiter.u))),
           delay2.limiter.simplifiedExpr);
      end if;
    end if;

  // Component delay2
  // class NHES.Fluid.Utilities.NonLinear_Break
  equation
    delay2.limiter2.y = delay2.boundary.p_in;
    delay2.boundary.ports[1].m_flow+delay2.sensor_m_flow.port_b.m_flow = 0.0;
    delay2.sensor_m_flow.port_b.p = delay2.boundary.ports[1].p;
    delay2.limiter1.y = delay2.boundary1.h_in;
    delay2.limiter.y = delay2.boundary1.m_flow_in;
    delay2.port_b.m_flow-delay2.boundary1.ports[1].m_flow-delay2.sensor_p.port.m_flow
       = 0.0;
    delay2.port_b.p = delay2.boundary1.ports[1].p;
    delay2.sensor_p.port.p = delay2.boundary1.ports[1].p;
    delay2.sensor_m_flow.m_flow = delay2.limiter.u;
    delay2.sensor_h.h_out = delay2.limiter1.u;
    delay2.sensor_p.p = delay2.limiter2.u;
    delay2.port_a.m_flow-delay2.sensor_h.port.m_flow-delay2.sensor_m_flow.port_a.m_flow
       = 0.0;
    delay2.sensor_h.port.p = delay2.port_a.p;
    delay2.sensor_m_flow.port_a.p = delay2.port_a.p;

  // Component delay2_2.sensor_p
  // class TRANSFORM.Fluid.Sensors.Pressure
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      delay2_2.sensor_p.port.m_flow = 0;
      delay2_2.sensor_p.port.h_outflow = 84013.0581525969;
      delay2_2.sensor_p.port.Xi_outflow = {};
      delay2_2.sensor_p.port.C_outflow = zeros(0);
    // end of extends 
  equation
    delay2_2.sensor_p.p = delay2_2.sensor_p.port.p;

  // Component delay2_2.sensor_m_flow
  // class TRANSFORM.Fluid.Sensors.MassFlowRate
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialTwoPortSensor
    equation
      0 = delay2_2.sensor_m_flow.port_a.m_flow+delay2_2.sensor_m_flow.port_b.m_flow;
      delay2_2.sensor_m_flow.port_a.p = delay2_2.sensor_m_flow.port_b.p;
      delay2_2.sensor_m_flow.port_a.h_outflow = inStream(delay2_2.sensor_m_flow.port_b.h_outflow);
      delay2_2.sensor_m_flow.port_b.h_outflow = inStream(delay2_2.sensor_m_flow.port_a.h_outflow);
      delay2_2.sensor_m_flow.port_a.Xi_outflow = inStream(delay2_2.sensor_m_flow.port_b.Xi_outflow);
      delay2_2.sensor_m_flow.port_b.Xi_outflow = inStream(delay2_2.sensor_m_flow.port_a.Xi_outflow);
      delay2_2.sensor_m_flow.port_a.C_outflow = inStream(delay2_2.sensor_m_flow.port_b.C_outflow);
      delay2_2.sensor_m_flow.port_b.C_outflow = inStream(delay2_2.sensor_m_flow.port_a.C_outflow);
    // end of extends 
  equation
    delay2_2.sensor_m_flow.m_flow = delay2_2.sensor_m_flow.port_a.m_flow;

  // Component delay2_2.sensor_h
  // class TRANSFORM.Fluid.Sensors.SpecificEnthalpy
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      delay2_2.sensor_h.port.m_flow = 0;
      delay2_2.sensor_h.port.h_outflow = 84013.0581525969;
      delay2_2.sensor_h.port.Xi_outflow = {};
      delay2_2.sensor_h.port.C_outflow = zeros(0);
    // end of extends 
  equation
    delay2_2.sensor_h.h_out = inStream(delay2_2.sensor_h.port.h_outflow);

  // Component delay2_2.boundary.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (delay2_2.boundary.medium.standardOrderComponents) then 
        delay2_2.boundary.medium.Xi = delay2_2.boundary.medium.X[1:0];
        delay2_2.boundary.medium.X = {1.0};
        for i in (1:1) loop
          assert(delay2_2.boundary.medium.X[i] >= -1E-05 and delay2_2.boundary.medium.X
            [i] <= 1.00001, "Mass fraction X["+       String(i, true, 0)+"] = "+
                   String(delay2_2.boundary.medium.X[i], true, 0)+
            "of substance "+({"water"})[i]+"\nof medium "+"WaterIF97"+
            " is not in the range 0..1");
        end for;
      end if;
      assert(delay2_2.boundary.medium.p >= 0.0, "Pressure (= "+       String(
        delay2_2.boundary.medium.p, true, 0)+" Pa) of medium \""+"WaterIF97"+
        "\" is negative\n(Temperature = "+       String(delay2_2.boundary.medium.T,
         true, 0)+" K)");
    // end of extends 
  equation
    delay2_2.boundary.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    delay2_2.boundary.medium.phase = (if delay2_2.boundary.medium.h < 
      Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique15(
      delay2_2.boundary.medium.sat) or delay2_2.boundary.medium.h > 
      Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique18(
      delay2_2.boundary.medium.sat) or delay2_2.boundary.medium.p > 
      _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].
      criticalPressure then 1 else 2);
    delay2_2.boundary.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique10
      (delay2_2.boundary.medium.p, delay2_2.boundary.medium.h, delay2_2.boundary.medium.phase,
       0);
    delay2_2.boundary.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique11
      (delay2_2.boundary.medium.p, delay2_2.boundary.medium.h, delay2_2.boundary.medium.phase,
       0);
    delay2_2.boundary.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique13
      (delay2_2.boundary.medium.p);
    delay2_2.boundary.medium.sat.psat = delay2_2.boundary.medium.p;
    delay2_2.boundary.medium.u = delay2_2.boundary.medium.h-delay2_2.boundary.medium.p
      /delay2_2.boundary.medium.d;
    delay2_2.boundary.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    delay2_2.boundary.medium.h = delay2_2.boundary.medium.state.h;
    delay2_2.boundary.medium.p = delay2_2.boundary.medium.state.p;
    delay2_2.boundary.medium.T = delay2_2.boundary.medium.state.T;
    delay2_2.boundary.medium.d = delay2_2.boundary.medium.state.d;
    delay2_2.boundary.medium.phase = delay2_2.boundary.medium.state.phase;

  // Component delay2_2.boundary
  // class TRANSFORM.Fluid.BoundaryConditions.Boundary_ph
    // extends TRANSFORM.Fluid.BoundaryConditions.BaseClasses.PartialSource
    equation
      for i in (1:delay2_2.boundary.nPorts) loop
        assert(cardinality(delay2_2.boundary.ports[i]) <= 1, "
each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
        delay2_2.boundary.ports[i].p = delay2_2.boundary.medium.p;
        delay2_2.boundary.ports[i].h_outflow = delay2_2.boundary.medium.h;
        delay2_2.boundary.ports[i].Xi_outflow = delay2_2.boundary.medium.Xi;
      end for;
    // end of extends 
  equation
    Modelica.Fluid.Utilities.checkBoundary("WaterIF97", {"water"}, false, true, 
      delay2_2.boundary.X_in_internal, "Boundary_ph");
    if ( not delay2_2.boundary.use_p_in) then 
      delay2_2.boundary.p_in_internal = delay2_2.boundary.p;
    end if;
    if ( not delay2_2.boundary.use_h_in) then 
      delay2_2.boundary.h_in_internal = delay2_2.boundary.h;
    end if;
    if ( not delay2_2.boundary.use_X_in) then 
      delay2_2.boundary.X_in_internal = delay2_2.boundary.X;
    end if;
    if ( not delay2_2.boundary.use_C_in) then 
      delay2_2.boundary.C_in_internal = delay2_2.boundary.C;
    end if;
    delay2_2.boundary.medium.p = delay2_2.boundary.p_in_internal;
    delay2_2.boundary.medium.h = delay2_2.boundary.h_in_internal;
    delay2_2.boundary.medium.Xi = delay2_2.boundary.X_in_internal[1:0];
    delay2_2.boundary.ports.C_outflow = fill(delay2_2.boundary.C_in_internal, 
      delay2_2.boundary.nPorts);
    delay2_2.boundary.p_in_internal = delay2_2.boundary.p_in;

  // Component delay2_2.boundary1.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (delay2_2.boundary1.medium.standardOrderComponents) then 
        delay2_2.boundary1.medium.Xi = delay2_2.boundary1.medium.X[1:0];
        delay2_2.boundary1.medium.X = {1.0};
        for i in (1:1) loop
          assert(delay2_2.boundary1.medium.X[i] >= -1E-05 and delay2_2.boundary1.medium.X
            [i] <= 1.00001, "Mass fraction X["+       String(i, true, 0)+"] = "+
                   String(delay2_2.boundary1.medium.X[i], true, 0)+
            "of substance "+({"water"})[i]+"\nof medium "+"WaterIF97"+
            " is not in the range 0..1");
        end for;
      end if;
      assert(delay2_2.boundary1.medium.p >= 0.0, "Pressure (= "+       String(
        delay2_2.boundary1.medium.p, true, 0)+" Pa) of medium \""+"WaterIF97"+
        "\" is negative\n(Temperature = "+       String(delay2_2.boundary1.medium.T,
         true, 0)+" K)");
    // end of extends 
  equation
    delay2_2.boundary1.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    delay2_2.boundary1.medium.phase = (if delay2_2.boundary1.medium.h < 
      Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique15(
      delay2_2.boundary1.medium.sat) or delay2_2.boundary1.medium.h > 
      Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique18(
      delay2_2.boundary1.medium.sat) or delay2_2.boundary1.medium.p > 
      _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].
      criticalPressure then 1 else 2);
    delay2_2.boundary1.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique10
      (delay2_2.boundary1.medium.p, delay2_2.boundary1.medium.h, 
      delay2_2.boundary1.medium.phase, 0);
    delay2_2.boundary1.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique11
      (delay2_2.boundary1.medium.p, delay2_2.boundary1.medium.h, 
      delay2_2.boundary1.medium.phase, 0);
    delay2_2.boundary1.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique13
      (delay2_2.boundary1.medium.p);
    delay2_2.boundary1.medium.sat.psat = delay2_2.boundary1.medium.p;
    delay2_2.boundary1.medium.u = delay2_2.boundary1.medium.h-delay2_2.boundary1.medium.p
      /delay2_2.boundary1.medium.d;
    delay2_2.boundary1.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    delay2_2.boundary1.medium.h = delay2_2.boundary1.medium.state.h;
    delay2_2.boundary1.medium.p = delay2_2.boundary1.medium.state.p;
    delay2_2.boundary1.medium.T = delay2_2.boundary1.medium.state.T;
    delay2_2.boundary1.medium.d = delay2_2.boundary1.medium.state.d;
    delay2_2.boundary1.medium.phase = delay2_2.boundary1.medium.state.phase;

  // Component delay2_2.boundary1
  // class TRANSFORM.Fluid.BoundaryConditions.MassFlowSource_h
    // extends TRANSFORM.Fluid.BoundaryConditions.BaseClasses.PartialFlowSource
    equation
      assert(abs(sum(abs(delay2_2.boundary1.ports.m_flow))-max(abs(
        delay2_2.boundary1.ports.m_flow))) <= 1E-60, "FlowSource only supports one connection with flow");
      for i in (1:delay2_2.boundary1.nPorts) loop
        assert(cardinality(delay2_2.boundary1.ports[i]) <= 1, "
each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
        delay2_2.boundary1.ports[i].p = delay2_2.boundary1.medium.p;
        delay2_2.boundary1.ports[i].h_outflow = delay2_2.boundary1.medium.h;
        delay2_2.boundary1.ports[i].Xi_outflow = delay2_2.boundary1.medium.Xi;
      end for;
    // end of extends 
  equation
    Modelica.Fluid.Utilities.checkBoundary("WaterIF97", {"water"}, false, true, 
      delay2_2.boundary1.X_in_internal, "MassFlowSource_h");
    if ( not delay2_2.boundary1.use_m_flow_in) then 
      delay2_2.boundary1.m_flow_in_internal = delay2_2.boundary1.m_flow;
    end if;
    if ( not delay2_2.boundary1.use_h_in) then 
      delay2_2.boundary1.h_in_internal = delay2_2.boundary1.h;
    end if;
    if ( not delay2_2.boundary1.use_X_in) then 
      delay2_2.boundary1.X_in_internal = delay2_2.boundary1.X;
    end if;
    if ( not delay2_2.boundary1.use_C_in) then 
      delay2_2.boundary1.C_in_internal = delay2_2.boundary1.C;
    end if;
    delay2_2.boundary1.medium.h = delay2_2.boundary1.h_in_internal;
    sum(delay2_2.boundary1.ports.m_flow) =  -delay2_2.boundary1.m_flow_in_internal;
    delay2_2.boundary1.medium.Xi = delay2_2.boundary1.X_in_internal[1:0];
    delay2_2.boundary1.ports.C_outflow = fill(delay2_2.boundary1.C_in_internal, 
      delay2_2.boundary1.nPorts);
    delay2_2.boundary1.h_in_internal = delay2_2.boundary1.h_in;
    delay2_2.boundary1.m_flow_in_internal = delay2_2.boundary1.m_flow_in;

  // Component delay2_2.limiter1
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(delay2_2.limiter1.uMax >= delay2_2.limiter1.uMin, "Limiter: Limits must be consistent. However, uMax (="
      +       String(delay2_2.limiter1.uMax, true, 0)+") < uMin (="+
             String(delay2_2.limiter1.uMin, true, 0)+")");
    delay2_2.limiter1.simplifiedExpr = (if delay2_2.limiter1.homotopyType == 
      Modelica.Blocks.Types.LimiterHomotopy.Linear then delay2_2.limiter1.u
       else (if delay2_2.limiter1.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then delay2_2.limiter1.uMax else (if delay2_2.limiter1.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then delay2_2.limiter1.uMin
       else 0)));
    if (delay2_2.limiter1.strict) then 
      if (delay2_2.limiter1.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        delay2_2.limiter1.y = smooth(0, noEvent((if delay2_2.limiter1.u > 
          delay2_2.limiter1.uMax then delay2_2.limiter1.uMax else (if 
          delay2_2.limiter1.u < delay2_2.limiter1.uMin then delay2_2.limiter1.uMin
           else delay2_2.limiter1.u))));
      else
        delay2_2.limiter1.y = homotopy(smooth(0, noEvent((if delay2_2.limiter1.u
           > delay2_2.limiter1.uMax then delay2_2.limiter1.uMax else (if 
          delay2_2.limiter1.u < delay2_2.limiter1.uMin then delay2_2.limiter1.uMin
           else delay2_2.limiter1.u)))), delay2_2.limiter1.simplifiedExpr);
      end if;
    else
      if (delay2_2.limiter1.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        delay2_2.limiter1.y = smooth(0, (if delay2_2.limiter1.u > 
          delay2_2.limiter1.uMax then delay2_2.limiter1.uMax else (if 
          delay2_2.limiter1.u < delay2_2.limiter1.uMin then delay2_2.limiter1.uMin
           else delay2_2.limiter1.u)));
      else
        delay2_2.limiter1.y = homotopy(smooth(0, (if delay2_2.limiter1.u > 
          delay2_2.limiter1.uMax then delay2_2.limiter1.uMax else (if 
          delay2_2.limiter1.u < delay2_2.limiter1.uMin then delay2_2.limiter1.uMin
           else delay2_2.limiter1.u))), delay2_2.limiter1.simplifiedExpr);
      end if;
    end if;

  // Component delay2_2.limiter2
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(delay2_2.limiter2.uMax >= delay2_2.limiter2.uMin, "Limiter: Limits must be consistent. However, uMax (="
      +       String(delay2_2.limiter2.uMax, true, 0)+") < uMin (="+
             String(delay2_2.limiter2.uMin, true, 0)+")");
    delay2_2.limiter2.simplifiedExpr = (if delay2_2.limiter2.homotopyType == 
      Modelica.Blocks.Types.LimiterHomotopy.Linear then delay2_2.limiter2.u
       else (if delay2_2.limiter2.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then delay2_2.limiter2.uMax else (if delay2_2.limiter2.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then delay2_2.limiter2.uMin
       else 0)));
    if (delay2_2.limiter2.strict) then 
      if (delay2_2.limiter2.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        delay2_2.limiter2.y = smooth(0, noEvent((if delay2_2.limiter2.u > 
          delay2_2.limiter2.uMax then delay2_2.limiter2.uMax else (if 
          delay2_2.limiter2.u < delay2_2.limiter2.uMin then delay2_2.limiter2.uMin
           else delay2_2.limiter2.u))));
      else
        delay2_2.limiter2.y = homotopy(smooth(0, noEvent((if delay2_2.limiter2.u
           > delay2_2.limiter2.uMax then delay2_2.limiter2.uMax else (if 
          delay2_2.limiter2.u < delay2_2.limiter2.uMin then delay2_2.limiter2.uMin
           else delay2_2.limiter2.u)))), delay2_2.limiter2.simplifiedExpr);
      end if;
    else
      if (delay2_2.limiter2.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        delay2_2.limiter2.y = smooth(0, (if delay2_2.limiter2.u > 
          delay2_2.limiter2.uMax then delay2_2.limiter2.uMax else (if 
          delay2_2.limiter2.u < delay2_2.limiter2.uMin then delay2_2.limiter2.uMin
           else delay2_2.limiter2.u)));
      else
        delay2_2.limiter2.y = homotopy(smooth(0, (if delay2_2.limiter2.u > 
          delay2_2.limiter2.uMax then delay2_2.limiter2.uMax else (if 
          delay2_2.limiter2.u < delay2_2.limiter2.uMin then delay2_2.limiter2.uMin
           else delay2_2.limiter2.u))), delay2_2.limiter2.simplifiedExpr);
      end if;
    end if;

  // Component delay2_2.limiter
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(delay2_2.limiter.uMax >= delay2_2.limiter.uMin, "Limiter: Limits must be consistent. However, uMax (="
      +       String(delay2_2.limiter.uMax, true, 0)+") < uMin (="+       String
      (delay2_2.limiter.uMin, true, 0)+")");
    delay2_2.limiter.simplifiedExpr = (if delay2_2.limiter.homotopyType == 
      Modelica.Blocks.Types.LimiterHomotopy.Linear then delay2_2.limiter.u else 
      (if delay2_2.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then delay2_2.limiter.uMax else (if delay2_2.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then delay2_2.limiter.uMin
       else 0)));
    if (delay2_2.limiter.strict) then 
      if (delay2_2.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        delay2_2.limiter.y = smooth(0, noEvent((if delay2_2.limiter.u > 
          delay2_2.limiter.uMax then delay2_2.limiter.uMax else (if 
          delay2_2.limiter.u < delay2_2.limiter.uMin then delay2_2.limiter.uMin
           else delay2_2.limiter.u))));
      else
        delay2_2.limiter.y = homotopy(smooth(0, noEvent((if delay2_2.limiter.u
           > delay2_2.limiter.uMax then delay2_2.limiter.uMax else (if 
          delay2_2.limiter.u < delay2_2.limiter.uMin then delay2_2.limiter.uMin
           else delay2_2.limiter.u)))), delay2_2.limiter.simplifiedExpr);
      end if;
    else
      if (delay2_2.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        delay2_2.limiter.y = smooth(0, (if delay2_2.limiter.u > delay2_2.limiter.uMax
           then delay2_2.limiter.uMax else (if delay2_2.limiter.u < 
          delay2_2.limiter.uMin then delay2_2.limiter.uMin else delay2_2.limiter.u)));
      else
        delay2_2.limiter.y = homotopy(smooth(0, (if delay2_2.limiter.u > 
          delay2_2.limiter.uMax then delay2_2.limiter.uMax else (if 
          delay2_2.limiter.u < delay2_2.limiter.uMin then delay2_2.limiter.uMin
           else delay2_2.limiter.u))), delay2_2.limiter.simplifiedExpr);
      end if;
    end if;

  // Component delay2_2
  // class NHES.Fluid.Utilities.NonLinear_Break
  equation
    delay2_2.limiter2.y = delay2_2.boundary.p_in;
    delay2_2.boundary.ports[1].m_flow+delay2_2.sensor_m_flow.port_b.m_flow = 0.0;
    delay2_2.sensor_m_flow.port_b.p = delay2_2.boundary.ports[1].p;
    delay2_2.limiter1.y = delay2_2.boundary1.h_in;
    delay2_2.limiter.y = delay2_2.boundary1.m_flow_in;
    delay2_2.port_b.m_flow-delay2_2.boundary1.ports[1].m_flow-delay2_2.sensor_p.port.m_flow
       = 0.0;
    delay2_2.port_b.p = delay2_2.boundary1.ports[1].p;
    delay2_2.sensor_p.port.p = delay2_2.boundary1.ports[1].p;
    delay2_2.sensor_m_flow.m_flow = delay2_2.limiter.u;
    delay2_2.sensor_h.h_out = delay2_2.limiter1.u;
    delay2_2.sensor_p.p = delay2_2.limiter2.u;
    delay2_2.port_a.m_flow-delay2_2.sensor_h.port.m_flow-delay2_2.sensor_m_flow.port_a.m_flow
       = 0.0;
    delay2_2.sensor_h.port.p = delay2_2.port_a.p;
    delay2_2.sensor_m_flow.port_a.p = delay2_2.port_a.p;

  // Component sensor_m_flow
  // class TRANSFORM.Fluid.Sensors.MassFlowRate
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialTwoPortSensor
    equation
      0 = sensor_m_flow.port_a.m_flow+sensor_m_flow.port_b.m_flow;
      sensor_m_flow.port_a.p = sensor_m_flow.port_b.p;
      sensor_m_flow.port_a.h_outflow = inStream(sensor_m_flow.port_b.h_outflow);
      sensor_m_flow.port_b.h_outflow = inStream(sensor_m_flow.port_a.h_outflow);
      sensor_m_flow.port_a.Xi_outflow = inStream(sensor_m_flow.port_b.Xi_outflow);
      sensor_m_flow.port_b.Xi_outflow = inStream(sensor_m_flow.port_a.Xi_outflow);
      sensor_m_flow.port_a.C_outflow = inStream(sensor_m_flow.port_b.C_outflow);
      sensor_m_flow.port_b.C_outflow = inStream(sensor_m_flow.port_a.C_outflow);
    // end of extends 
  equation
    sensor_m_flow.m_flow = sensor_m_flow.port_a.m_flow;

  // Component sensor_p1
  // class TRANSFORM.Fluid.Sensors.Pressure
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      sensor_p1.port.m_flow = 0;
      sensor_p1.port.h_outflow = 84013.0581525969;
      sensor_p1.port.Xi_outflow = {};
      sensor_p1.port.C_outflow = zeros(0);
    // end of extends 
  equation
    sensor_p1.p = sensor_p1.port.p;

  // Component switch1
  // class Modelica.Blocks.Logical.Switch
  equation
    switch1.y = (if switch1.u2 then switch1.u1 else switch1.u3);

  // Component booleanStep1
  // class Modelica.Blocks.Sources.BooleanStep
  equation
    booleanStep1.y = (if time >= booleanStep1.startTime then  not 
      booleanStep1.startValue else booleanStep1.startValue);

  // This model
  // class NHES.Systems.BalanceOfPlant.RankineCycle.Models.SteamTurbine_L3_HPOFWHsimplified_sec_RealExpressionswitch_FWHExtractionLPT
  equation
    ED.actuatorBus.Feed_Pump_Speed = CS.actuatorBus.Feed_Pump_Speed;
    actuatorBus.Feed_Pump_Speed = CS.actuatorBus.Feed_Pump_Speed;
    ED.actuatorBus.LPT1_BV = CS.actuatorBus.LPT1_BV;
    LPT1_bypass_valve.opening = CS.actuatorBus.LPT1_BV;
    actuatorBus.LPT1_BV = CS.actuatorBus.LPT1_BV;
    ED.actuatorBus.LPT2_BV = CS.actuatorBus.LPT2_BV;
    actuatorBus.LPT2_BV = CS.actuatorBus.LPT2_BV;
    switch1.u1 = CS.actuatorBus.LPT2_BV;
    ED.actuatorBus.TBV = CS.actuatorBus.TBV;
    TBV.opening = CS.actuatorBus.TBV;
    actuatorBus.TBV = CS.actuatorBus.TBV;
    ED.actuatorBus.opening_BV = CS.actuatorBus.opening_BV;
    actuatorBus.opening_BV = CS.actuatorBus.opening_BV;
    ED.actuatorBus.opening_BV_TCV = CS.actuatorBus.opening_BV_TCV;
    actuatorBus.opening_BV_TCV = CS.actuatorBus.opening_BV_TCV;
    ED.actuatorBus.opening_TCV = CS.actuatorBus.opening_TCV;
    TCV.opening = CS.actuatorBus.opening_TCV;
    actuatorBus.opening_TCV = CS.actuatorBus.opening_TCV;
    ED.actuatorBus.opening_TDV = CS.actuatorBus.opening_TDV;
    actuatorBus.opening_TDV = CS.actuatorBus.opening_TDV;
    ED.sensorBus.Extract_flow = CS.sensorBus.Extract_flow;
    sensorBus.Extract_flow = CS.sensorBus.Extract_flow;
    sensor_m_flow.m_flow = CS.sensorBus.Extract_flow;
    ED.sensorBus.Feedwater_Temp = CS.sensorBus.Feedwater_Temp;
    Feed_T.T = CS.sensorBus.Feedwater_Temp;
    sensorBus.Feedwater_Temp = CS.sensorBus.Feedwater_Temp;
    ED.sensorBus.Q_balance = CS.sensorBus.Q_balance;
    Q_balance.y = CS.sensorBus.Q_balance;
    sensorBus.Q_balance = CS.sensorBus.Q_balance;
    ED.sensorBus.Steam_Pressure = CS.sensorBus.Steam_Pressure;
    sensorBus.Steam_Pressure = CS.sensorBus.Steam_Pressure;
    sensor_p.p = CS.sensorBus.Steam_Pressure;
    ED.sensorBus.Steam_Temperature = CS.sensorBus.Steam_Temperature;
    Steam_T.T = CS.sensorBus.Steam_Temperature;
    sensorBus.Steam_Temperature = CS.sensorBus.Steam_Temperature;
    ED.sensorBus.W_balance = CS.sensorBus.W_balance;
    W_balance.y = CS.sensorBus.W_balance;
    sensorBus.W_balance = CS.sensorBus.W_balance;
    ED.sensorBus.W_total = CS.sensorBus.W_total;
    sensorBus.W_total = CS.sensorBus.W_total;
    sensorW.W = CS.sensorBus.W_total;
    ED.sensorBus.W_totalSetpoint = CS.sensorBus.W_totalSetpoint;
    sensorBus.W_totalSetpoint = CS.sensorBus.W_totalSetpoint;
    ED.sensorBus.p_inlet_steamTurbine = CS.sensorBus.p_inlet_steamTurbine;
    sensorBus.p_inlet_steamTurbine = CS.sensorBus.p_inlet_steamTurbine;
    FWCP.port_a.m_flow+OFWH_2.port_a.m_flow = 0.0;
    OFWH_2.port_a.p = FWCP.port_a.p;
    port_b_feed.m_flow-(FWCP.port_b.m_flow+Feed_T.port.m_flow) = 0.0;
    Feed_T.port.p = FWCP.port_b.p;
    port_b_feed.p = FWCP.port_b.p;
    HPT.portHP.m_flow+TCV.port_b.m_flow+sensor_p1.port.m_flow = 0.0;
    TCV.port_b.p = HPT.portHP.p;
    sensor_p1.port.p = HPT.portHP.p;
    HPT.portLP.m_flow+LPT1_bypass.port_1.m_flow = 0.0;
    LPT1_bypass.port_1.p = HPT.portLP.p;
    LPT1.shaft_a.phi = HPT.shaft_b.phi;
    HPT.shaft_b.tau+LPT1.shaft_a.tau = 0.0;
    switch1.y = HPT_bypass_valve.opening;
    HPT_bypass_valve.port_a.m_flow+LPT1_bypass.port_3.m_flow = 0.0;
    LPT1_bypass.port_3.p = HPT_bypass_valve.port_a.p;
    HPT_bypass_valve.port_b.m_flow+delay2.port_a.m_flow = 0.0;
    delay2.port_a.p = HPT_bypass_valve.port_b.p;
    LPT1.portHP.m_flow+LPT1_bypass.port_2.m_flow = 0.0;
    LPT1_bypass.port_2.p = LPT1.portHP.p;
    LPT1.portLP.m_flow+moistureSeperator.port_a[1].m_flow = 0.0;
    moistureSeperator.port_a[1].p = LPT1.portLP.p;
    LPT2.shaft_a.phi = LPT1.shaft_b.phi;
    LPT1.shaft_b.tau+LPT2.shaft_a.tau = 0.0;
    port_a_steam.m_flow-(LPT1_bypass_valve.port_a.m_flow+Steam_T.port.m_flow+
      TBV.port_a.m_flow+TCV.port_a.m_flow)-sensor_p.port.m_flow = 0.0;
    Steam_T.port.p = LPT1_bypass_valve.port_a.p;
    TBV.port_a.p = LPT1_bypass_valve.port_a.p;
    TCV.port_a.p = LPT1_bypass_valve.port_a.p;
    port_a_steam.p = LPT1_bypass_valve.port_a.p;
    sensor_p.port.p = LPT1_bypass_valve.port_a.p;
    LPT1_bypass_valve.port_b.m_flow+sensor_m_flow.port_a.m_flow = 0.0;
    sensor_m_flow.port_a.p = LPT1_bypass_valve.port_b.p;
    LPT2.portHP.m_flow+moistureSeperator.port_b[1].m_flow = 0.0;
    moistureSeperator.port_b[1].p = LPT2.portHP.p;
    LPT2.portLP.m_flow+condenser.port_a.m_flow = 0.0;
    condenser.port_a.p = LPT2.portLP.p;
    generator.shaft.phi = LPT2.shaft_b.phi;
    LPT2.shaft_b.tau+generator.shaft.tau = 0.0;
    OFWH_1.port_a.m_flow+pump1.port_a.m_flow = 0.0;
    pump1.port_a.p = OFWH_1.port_a.p;
    OFWH_1.port_b.m_flow+moistureSeperator.port_Liquid.m_flow+pump.port_b.m_flow
       = 0.0;
    moistureSeperator.port_Liquid.p = OFWH_1.port_b.p;
    pump.port_b.p = OFWH_1.port_b.p;
    OFWH_2.port_b.m_flow+delay2.port_b.m_flow+pump1.port_b.m_flow = 0.0;
    delay2.port_b.p = OFWH_2.port_b.p;
    pump1.port_b.p = OFWH_2.port_b.p;
    TBV.port_b.m_flow+delay2_2.port_a.m_flow = 0.0;
    delay2_2.port_a.p = TBV.port_b.p;
    switch1.u2 = booleanStep1.y;
    port_a_cond.m_flow-condenser.port_b.m_flow-pump.port_a.m_flow = 0.0;
    port_a_cond.p = condenser.port_b.p;
    pump.port_a.p = condenser.port_b.p;
    prt_b_steamdump.m_flow-delay2_2.port_b.m_flow = 0.0;
    prt_b_steamdump.p = delay2_2.port_b.p;
    generator.port.W+sensorW.port_a.W = 0.0;
    sensorW.port_a.f = generator.port.f;
    port_a_elec.W-sensorW.port_b.W = 0.0;
    sensorW.port_b.f = port_a_elec.f;
    port_b_bypass.m_flow-sensor_m_flow.port_b.m_flow = 0.0;
    sensor_m_flow.port_b.p = port_b_bypass.p;
    switch1.u3 = realExpression.y;

// Fictive Equations for flow variables in top-level flow connectors: 
  port_a_steam.m_flow = function_of(port_a_steam.p, port_a_steam.h_outflow, 
    port_a_steam.Xi_outflow, port_a_steam.C_outflow, port_b_feed.p, 
    port_b_feed.h_outflow, port_b_feed.Xi_outflow, port_b_feed.C_outflow, 
    port_b_bypass.p, port_b_bypass.h_outflow, port_b_bypass.Xi_outflow, 
    port_b_bypass.C_outflow, prt_b_steamdump.p, prt_b_steamdump.h_outflow, 
    prt_b_steamdump.Xi_outflow, prt_b_steamdump.C_outflow, port_a_elec.f, 
    port_a_cond.p, port_a_cond.h_outflow, port_a_cond.Xi_outflow, 
    port_a_cond.C_outflow);
  port_b_feed.m_flow = function_of(port_a_steam.p, port_a_steam.h_outflow, 
    port_a_steam.Xi_outflow, port_a_steam.C_outflow, port_b_feed.p, 
    port_b_feed.h_outflow, port_b_feed.Xi_outflow, port_b_feed.C_outflow, 
    port_b_bypass.p, port_b_bypass.h_outflow, port_b_bypass.Xi_outflow, 
    port_b_bypass.C_outflow, prt_b_steamdump.p, prt_b_steamdump.h_outflow, 
    prt_b_steamdump.Xi_outflow, prt_b_steamdump.C_outflow, port_a_elec.f, 
    port_a_cond.p, port_a_cond.h_outflow, port_a_cond.Xi_outflow, 
    port_a_cond.C_outflow);
  port_b_bypass.m_flow = function_of(port_a_steam.p, port_a_steam.h_outflow, 
    port_a_steam.Xi_outflow, port_a_steam.C_outflow, port_b_feed.p, 
    port_b_feed.h_outflow, port_b_feed.Xi_outflow, port_b_feed.C_outflow, 
    port_b_bypass.p, port_b_bypass.h_outflow, port_b_bypass.Xi_outflow, 
    port_b_bypass.C_outflow, prt_b_steamdump.p, prt_b_steamdump.h_outflow, 
    prt_b_steamdump.Xi_outflow, prt_b_steamdump.C_outflow, port_a_elec.f, 
    port_a_cond.p, port_a_cond.h_outflow, port_a_cond.Xi_outflow, 
    port_a_cond.C_outflow);
  prt_b_steamdump.m_flow = function_of(port_a_steam.p, port_a_steam.h_outflow, 
    port_a_steam.Xi_outflow, port_a_steam.C_outflow, port_b_feed.p, 
    port_b_feed.h_outflow, port_b_feed.Xi_outflow, port_b_feed.C_outflow, 
    port_b_bypass.p, port_b_bypass.h_outflow, port_b_bypass.Xi_outflow, 
    port_b_bypass.C_outflow, prt_b_steamdump.p, prt_b_steamdump.h_outflow, 
    prt_b_steamdump.Xi_outflow, prt_b_steamdump.C_outflow, port_a_elec.f, 
    port_a_cond.p, port_a_cond.h_outflow, port_a_cond.Xi_outflow, 
    port_a_cond.C_outflow);
  port_a_elec.W = function_of(port_a_steam.p, port_a_steam.h_outflow, 
    port_a_steam.Xi_outflow, port_a_steam.C_outflow, port_b_feed.p, 
    port_b_feed.h_outflow, port_b_feed.Xi_outflow, port_b_feed.C_outflow, 
    port_b_bypass.p, port_b_bypass.h_outflow, port_b_bypass.Xi_outflow, 
    port_b_bypass.C_outflow, prt_b_steamdump.p, prt_b_steamdump.h_outflow, 
    prt_b_steamdump.Xi_outflow, prt_b_steamdump.C_outflow, port_a_elec.f, 
    port_a_cond.p, port_a_cond.h_outflow, port_a_cond.Xi_outflow, 
    port_a_cond.C_outflow);
  port_a_cond.m_flow = function_of(port_a_steam.p, port_a_steam.h_outflow, 
    port_a_steam.Xi_outflow, port_a_steam.C_outflow, port_b_feed.p, 
    port_b_feed.h_outflow, port_b_feed.Xi_outflow, port_b_feed.C_outflow, 
    port_b_bypass.p, port_b_bypass.h_outflow, port_b_bypass.Xi_outflow, 
    port_b_bypass.C_outflow, prt_b_steamdump.p, prt_b_steamdump.h_outflow, 
    prt_b_steamdump.Xi_outflow, prt_b_steamdump.C_outflow, port_a_elec.f, 
    port_a_cond.p, port_a_cond.h_outflow, port_a_cond.Xi_outflow, 
    port_a_cond.C_outflow);
            
// Initial equations and algorithms

  // Component CS.FeedPump_PID.I
  // class TRANSFORM.Blocks.IntegratorWithReset
  initial equation
    if (CS.FeedPump_PID.I.initType == Modelica.Blocks.Types.Init.SteadyState)
       then 
      der(CS.FeedPump_PID.I.y) = 0;
    elseif (CS.FeedPump_PID.I.initType == Modelica.Blocks.Types.Init.
      InitialState or CS.FeedPump_PID.I.initType == Modelica.Blocks.Types.Init.
      InitialOutput) then 
      CS.FeedPump_PID.I.y = CS.FeedPump_PID.I.y_start;
    end if;

  // Component CS.FeedPump_PID
  // class TRANSFORM.Controls.LimPID
  initial equation
    if (CS.FeedPump_PID.initType == Modelica.Blocks.Types.Init.InitialOutput)
       then 
      CS.FeedPump_PID.y = CS.FeedPump_PID.y_start;
    end if;

  // Component CS.TCV_PID.I
  // class TRANSFORM.Blocks.IntegratorWithReset
  initial equation
    if (CS.TCV_PID.I.initType == Modelica.Blocks.Types.Init.SteadyState) then 
      der(CS.TCV_PID.I.y) = 0;
    elseif (CS.TCV_PID.I.initType == Modelica.Blocks.Types.Init.InitialState or 
      CS.TCV_PID.I.initType == Modelica.Blocks.Types.Init.InitialOutput) then 
      CS.TCV_PID.I.y = CS.TCV_PID.I.y_start;
    end if;

  // Component CS.TCV_PID
  // class TRANSFORM.Controls.LimPID
  initial equation
    if (CS.TCV_PID.initType == Modelica.Blocks.Types.Init.InitialOutput) then 
      CS.TCV_PID.y = CS.TCV_PID.y_start;
    end if;

  // Component CS.LPT1_BV_PID.I
  // class TRANSFORM.Blocks.IntegratorWithReset
  initial equation
    if (CS.LPT1_BV_PID.I.initType == Modelica.Blocks.Types.Init.SteadyState)
       then 
      der(CS.LPT1_BV_PID.I.y) = 0;
    elseif (CS.LPT1_BV_PID.I.initType == Modelica.Blocks.Types.Init.InitialState
       or CS.LPT1_BV_PID.I.initType == Modelica.Blocks.Types.Init.InitialOutput)
       then 
      CS.LPT1_BV_PID.I.y = CS.LPT1_BV_PID.I.y_start;
    end if;

  // Component CS.LPT1_BV_PID
  // class TRANSFORM.Controls.LimPID
  initial equation
    if (CS.LPT1_BV_PID.initType == Modelica.Blocks.Types.Init.InitialOutput)
       then 
      CS.LPT1_BV_PID.y = CS.LPT1_BV_PID.y_start;
    end if;

  // Component CS.LPT2_BV_PID.I
  // class TRANSFORM.Blocks.IntegratorWithReset
  initial equation
    if (CS.LPT2_BV_PID.I.initType == Modelica.Blocks.Types.Init.SteadyState)
       then 
      der(CS.LPT2_BV_PID.I.y) = 0;
    elseif (CS.LPT2_BV_PID.I.initType == Modelica.Blocks.Types.Init.InitialState
       or CS.LPT2_BV_PID.I.initType == Modelica.Blocks.Types.Init.InitialOutput)
       then 
      CS.LPT2_BV_PID.I.y = CS.LPT2_BV_PID.I.y_start;
    end if;

  // Component CS.LPT2_BV_PID
  // class TRANSFORM.Controls.LimPID
  initial equation
    if (CS.LPT2_BV_PID.initType == Modelica.Blocks.Types.Init.InitialOutput)
       then 
      CS.LPT2_BV_PID.y = CS.LPT2_BV_PID.y_start;
    end if;

  // Component CS.hysteresis
  // class Modelica.Blocks.Logical.Hysteresis
  initial equation
    pre(CS.hysteresis.y) = CS.hysteresis.pre_y_start;

  // Component HPT
  // class TRANSFORM.Fluid.Machines.SteamTurbine
    // extends TRANSFORM.Fluid.Machines.BaseClasses.SteamTurbineBase
    initial equation
      if (HPT.energyDynamics == TRANSFORM.Types.Dynamics.FixedInitial) then 
        HPT.Q_units = HPT.Q_units_start;
      elseif (HPT.energyDynamics == TRANSFORM.Types.Dynamics.SteadyStateInitial)
         then 
        der(HPT.Q_units) = zeros(HPT.nUnits);
      end if;
    // end of extends 
  initial equation
    if (HPT.use_NominalInlet) then 
      if (HPT.use_T_nominal) then 
        HPT.Kt = HPT.m_flow_nominal/(sqrt(HPT.p_inlet_nominal*Modelica.Media.Water.WaterIF97_ph.density_Unique20
          (
          Modelica.Media.Water.WaterIF97_ph.setState_pTX_Unique3(
            HPT.p_inlet_nominal, HPT.T_nominal, {1.0}, 0, 0)))*Modelica.Fluid.Utilities.regRoot2
          (1-(HPT.p_outlet_nominal/HPT.p_inlet_nominal)^2, 0.01, 1, 1, false, 1));
      else
        HPT.Kt = HPT.m_flow_nominal/(sqrt(HPT.p_inlet_nominal*HPT.d_nominal)*
          Modelica.Fluid.Utilities.regRoot2(1-(HPT.p_outlet_nominal/
          HPT.p_inlet_nominal)^2, 0.01, 1, 1, false, 1));
      end if;
    else
      HPT.Kt = HPT.Kt_constant;
    end if;

  // Component LPT1
  // class TRANSFORM.Fluid.Machines.SteamTurbine
    // extends TRANSFORM.Fluid.Machines.BaseClasses.SteamTurbineBase
    initial equation
      if (LPT1.energyDynamics == TRANSFORM.Types.Dynamics.FixedInitial) then 
        LPT1.Q_units = LPT1.Q_units_start;
      elseif (LPT1.energyDynamics == TRANSFORM.Types.Dynamics.SteadyStateInitial)
         then 
        der(LPT1.Q_units) = zeros(LPT1.nUnits);
      end if;
    // end of extends 
  initial equation
    if (LPT1.use_NominalInlet) then 
      if (LPT1.use_T_nominal) then 
        LPT1.Kt = LPT1.m_flow_nominal/(sqrt(LPT1.p_inlet_nominal*
          Modelica.Media.Water.WaterIF97_ph.density_Unique20(
          Modelica.Media.Water.WaterIF97_ph.setState_pTX_Unique3(
            LPT1.p_inlet_nominal, LPT1.T_nominal, {1.0}, 0, 0)))*
          Modelica.Fluid.Utilities.regRoot2(1-(LPT1.p_outlet_nominal/
          LPT1.p_inlet_nominal)^2, 0.01, 1, 1, false, 1));
      else
        LPT1.Kt = LPT1.m_flow_nominal/(sqrt(LPT1.p_inlet_nominal*LPT1.d_nominal)
          *Modelica.Fluid.Utilities.regRoot2(1-(LPT1.p_outlet_nominal/
          LPT1.p_inlet_nominal)^2, 0.01, 1, 1, false, 1));
      end if;
    else
      LPT1.Kt = LPT1.Kt_constant;
    end if;

  // Component LPT2
  // class TRANSFORM.Fluid.Machines.SteamTurbine
    // extends TRANSFORM.Fluid.Machines.BaseClasses.SteamTurbineBase
    initial equation
      if (LPT2.energyDynamics == TRANSFORM.Types.Dynamics.FixedInitial) then 
        LPT2.Q_units = LPT2.Q_units_start;
      elseif (LPT2.energyDynamics == TRANSFORM.Types.Dynamics.SteadyStateInitial)
         then 
        der(LPT2.Q_units) = zeros(LPT2.nUnits);
      end if;
    // end of extends 
  initial equation
    if (LPT2.use_NominalInlet) then 
      if (LPT2.use_T_nominal) then 
        LPT2.Kt = LPT2.m_flow_nominal/(sqrt(LPT2.p_inlet_nominal*
          Modelica.Media.Water.WaterIF97_ph.density_Unique20(
          Modelica.Media.Water.WaterIF97_ph.setState_pTX_Unique3(
            LPT2.p_inlet_nominal, LPT2.T_nominal, {1.0}, 0, 0)))*
          Modelica.Fluid.Utilities.regRoot2(1-(LPT2.p_outlet_nominal/
          LPT2.p_inlet_nominal)^2, 0.01, 1, 1, false, 1));
      else
        LPT2.Kt = LPT2.m_flow_nominal/(sqrt(LPT2.p_inlet_nominal*LPT2.d_nominal)
          *Modelica.Fluid.Utilities.regRoot2(1-(LPT2.p_outlet_nominal/
          LPT2.p_inlet_nominal)^2, 0.01, 1, 1, false, 1));
      end if;
    else
      LPT2.Kt = LPT2.Kt_constant;
    end if;

  // Component moistureSeperator
  // class TRANSFORM.Fluid.Volumes.Separator
    // extends TRANSFORM.Fluid.Volumes.BaseClasses.PartialVolume
    initial equation
      if (moistureSeperator.massDynamics == Modelica.Fluid.Types.Dynamics.
        FixedInitial) then 
        if (moistureSeperator.initialize_p) then 
          moistureSeperator.medium.p = moistureSeperator.p_start;
        end if;
      elseif (moistureSeperator.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        if (moistureSeperator.initialize_p) then 
          der(moistureSeperator.medium.p) = 0;
        end if;
      end if;
      if (moistureSeperator.energyDynamics == Modelica.Fluid.Types.Dynamics.
        FixedInitial) then 
        moistureSeperator.medium.h = moistureSeperator.h_start;
      elseif (moistureSeperator.energyDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(moistureSeperator.medium.h) = 0;
      end if;
      if (moistureSeperator.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        FixedInitial) then 
        moistureSeperator.medium.Xi = moistureSeperator.X_start[1:0];
      elseif (moistureSeperator.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(moistureSeperator.medium.Xi) = zeros(0);
      end if;
      if (moistureSeperator.traceDynamics == Modelica.Fluid.Types.Dynamics.
        FixedInitial) then 
        moistureSeperator.C = moistureSeperator.C_start;
      elseif (moistureSeperator.traceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(moistureSeperator.mC) = zeros(0);
      end if;
    // end of extends 

  // Component LPT1_bypass
  // class TRANSFORM.Fluid.FittingsAndResistances.TeeJunctionVolume
    // extends TRANSFORM.Fluid.Volumes.BaseClasses.PartialVolume
    initial equation
      if (LPT1_bypass.massDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)
         then 
        if (LPT1_bypass.initialize_p) then 
          LPT1_bypass.medium.p = LPT1_bypass.p_start;
        end if;
      elseif (LPT1_bypass.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        if (LPT1_bypass.initialize_p) then 
          der(LPT1_bypass.medium.p) = 0;
        end if;
      end if;
      if (LPT1_bypass.energyDynamics == Modelica.Fluid.Types.Dynamics.
        FixedInitial) then 
        LPT1_bypass.medium.h = LPT1_bypass.h_start;
      elseif (LPT1_bypass.energyDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(LPT1_bypass.medium.h) = 0;
      end if;
      if (LPT1_bypass.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        FixedInitial) then 
        LPT1_bypass.medium.Xi = LPT1_bypass.X_start[1:0];
      elseif (LPT1_bypass.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(LPT1_bypass.medium.Xi) = zeros(0);
      end if;
      if (LPT1_bypass.traceDynamics == Modelica.Fluid.Types.Dynamics.
        FixedInitial) then 
        LPT1_bypass.C = LPT1_bypass.C_start;
      elseif (LPT1_bypass.traceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(LPT1_bypass.mC) = zeros(0);
      end if;
    // end of extends 

  // Component condenser
  // class TRANSFORM.Fluid.Volumes.IdealCondenser
  initial equation
    if (condenser.massDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)
       then 
      condenser.V_liquid = condenser.V_liquid_start;
    elseif (condenser.massDynamics == Modelica.Fluid.Types.Dynamics.
      SteadyStateInitial) then 
      condenser.V_liquid = condenser.V_liquid_start;
    end if;

  // Component generator
  // class TRANSFORM.Electrical.PowerConverters.Generator
  initial equation
    if (generator.momentumDynamics == Modelica.Fluid.Types.Dynamics.
      SteadyStateInitial) then 
      der(generator.omega_m) = 0;
    end if;

  // Component OFWH_1
  // class TRANSFORM.Fluid.Volumes.SimpleVolume
    // extends TRANSFORM.Fluid.Volumes.BaseClasses.PartialVolume
    initial equation
      if (OFWH_1.massDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)
         then 
        if (OFWH_1.initialize_p) then 
          OFWH_1.medium.p = OFWH_1.p_start;
        end if;
      elseif (OFWH_1.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        if (OFWH_1.initialize_p) then 
          der(OFWH_1.medium.p) = 0;
        end if;
      end if;
      if (OFWH_1.energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)
         then 
        OFWH_1.medium.h = OFWH_1.h_start;
      elseif (OFWH_1.energyDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(OFWH_1.medium.h) = 0;
      end if;
      if (OFWH_1.substanceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)
         then 
        OFWH_1.medium.Xi = OFWH_1.X_start[1:0];
      elseif (OFWH_1.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(OFWH_1.medium.Xi) = zeros(0);
      end if;
      if (OFWH_1.traceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)
         then 
        OFWH_1.C = OFWH_1.C_start;
      elseif (OFWH_1.traceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(OFWH_1.mC) = zeros(0);
      end if;
    // end of extends 

  // Component OFWH_2
  // class TRANSFORM.Fluid.Volumes.SimpleVolume
    // extends TRANSFORM.Fluid.Volumes.BaseClasses.PartialVolume
    initial equation
      if (OFWH_2.massDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)
         then 
        if (OFWH_2.initialize_p) then 
          OFWH_2.medium.p = OFWH_2.p_start;
        end if;
      elseif (OFWH_2.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        if (OFWH_2.initialize_p) then 
          der(OFWH_2.medium.p) = 0;
        end if;
      end if;
      if (OFWH_2.energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)
         then 
        OFWH_2.medium.h = OFWH_2.h_start;
      elseif (OFWH_2.energyDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(OFWH_2.medium.h) = 0;
      end if;
      if (OFWH_2.substanceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)
         then 
        OFWH_2.medium.Xi = OFWH_2.X_start[1:0];
      elseif (OFWH_2.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(OFWH_2.medium.Xi) = zeros(0);
      end if;
      if (OFWH_2.traceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)
         then 
        OFWH_2.C = OFWH_2.C_start;
      elseif (OFWH_2.traceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(OFWH_2.mC) = zeros(0);
      end if;
    // end of extends 

end SteamTurbine_L3_HPOFWHsimplified_sec_RealExpressionswitch_FWHExtractionLPT;
