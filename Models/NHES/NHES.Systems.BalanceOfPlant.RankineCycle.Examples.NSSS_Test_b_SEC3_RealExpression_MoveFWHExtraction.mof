model NSSS_Test_b_SEC3_RealExpression_MoveFWHExtraction
  parameter Real P_ext = 1.6;
  parameter Real P_demand = 1;
  parameter Modelica.Units.SI.Density d_ext = 1.004547784 "kg/m3";
  parameter Modelica.Units.SI.MassFlowRate m_ext = 0;
  parameter Real Boo = 1;
  parameter Modelica.Units.SI.AbsolutePressure stateSensor1.system.p_ambient = 101325
     "Default ambient pressure";
  parameter Modelica.Units.SI.Temperature stateSensor1.system.T_ambient = 293.15
     "Default ambient temperature";
  parameter Modelica.Units.SI.Acceleration stateSensor1.system.g = 9.80665 
    "Constant gravity acceleration";
  constant Boolean stateSensor1.system.allowFlowReversal = true "= false to restrict to design flow direction (port_a -> port_b)";
  parameter Modelica.Fluid.Types.Dynamics stateSensor1.system.energyDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics stateSensor1.system.massDynamics = 
    stateSensor1.system.energyDynamics "Default formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics stateSensor1.system.substanceDynamics
     = stateSensor1.system.massDynamics "Default formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics stateSensor1.system.traceDynamics = 
    stateSensor1.system.massDynamics "Default formulation of trace substance balances";
  parameter Modelica.Fluid.Types.Dynamics stateSensor1.system.momentumDynamics
     = Modelica.Fluid.Types.Dynamics.SteadyState "Default formulation of momentum balances, if options available";
  parameter Modelica.Units.SI.MassFlowRate stateSensor1.system.m_flow_start = 0 
    "Default start value for mass flow rates";
  parameter Modelica.Units.SI.AbsolutePressure stateSensor1.system.p_start = 
    stateSensor1.system.p_ambient "Default start value for pressures";
  parameter Modelica.Units.SI.Temperature stateSensor1.system.T_start = 
    stateSensor1.system.T_ambient "Default start value for temperatures";
  parameter Boolean stateSensor1.system.use_eps_Re = false "= true to determine turbulent region automatically using Reynolds number";
  parameter Modelica.Units.SI.MassFlowRate stateSensor1.system.m_flow_nominal = 
    (if stateSensor1.system.use_eps_Re then 1 else 100.0*stateSensor1.system.m_flow_small)
     "Default nominal mass flow rate";
  parameter Real stateSensor1.system.eps_m_flow(min = 0.0) = 0.0001 
    "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal";
  parameter Modelica.Units.SI.AbsolutePressure stateSensor1.system.dp_small = 1 
    "Default small pressure drop for regularization of laminar and zero flow";
  parameter Modelica.Units.SI.MassFlowRate stateSensor1.system.m_flow_small(
    min = 0.0) = 0.01 "Default small mass flow rate for regularization of laminar and zero flow";
  constant Boolean stateSensor1.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean stateSensor1.port_a_exposesState = false "= true if port_a exposes the state of a fluid volume";
  parameter Boolean stateSensor1.port_b_exposesState = false "= true if port_b.p exposes the state of a fluid volume";
  parameter Boolean stateSensor1.showDesignFlowDirection = false 
    "= false to hide the arrow in the model icon";
  parameter Boolean stateSensor1.use_Display = true "true to enable display panel";
  parameter Modelica.Units.SI.AbsolutePressure stateSensor1.massFlowRate.system.p_ambient
     = 101325 "Default ambient pressure";
  parameter Modelica.Units.SI.Temperature stateSensor1.massFlowRate.system.T_ambient
     = 293.15 "Default ambient temperature";
  parameter Modelica.Units.SI.Acceleration stateSensor1.massFlowRate.system.g = 
    9.80665 "Constant gravity acceleration";
  constant Boolean stateSensor1.massFlowRate.system.allowFlowReversal = true 
    "= false to restrict to design flow direction (port_a -> port_b)";
  parameter Modelica.Fluid.Types.Dynamics stateSensor1.massFlowRate.system.energyDynamics
     = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics stateSensor1.massFlowRate.system.massDynamics
     = stateSensor1.massFlowRate.system.energyDynamics "Default formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics stateSensor1.massFlowRate.system.substanceDynamics
     = stateSensor1.massFlowRate.system.massDynamics "Default formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics stateSensor1.massFlowRate.system.traceDynamics
     = stateSensor1.massFlowRate.system.massDynamics "Default formulation of trace substance balances";
  parameter Modelica.Fluid.Types.Dynamics stateSensor1.massFlowRate.system.momentumDynamics
     = Modelica.Fluid.Types.Dynamics.SteadyState "Default formulation of momentum balances, if options available";
  parameter Modelica.Units.SI.MassFlowRate stateSensor1.massFlowRate.system.m_flow_start
     = 0 "Default start value for mass flow rates";
  parameter Modelica.Units.SI.AbsolutePressure stateSensor1.massFlowRate.system.p_start
     = stateSensor1.massFlowRate.system.p_ambient "Default start value for pressures";
  parameter Modelica.Units.SI.Temperature stateSensor1.massFlowRate.system.T_start
     = stateSensor1.massFlowRate.system.T_ambient "Default start value for temperatures";
  parameter Boolean stateSensor1.massFlowRate.system.use_eps_Re = false 
    "= true to determine turbulent region automatically using Reynolds number";
  parameter Modelica.Units.SI.MassFlowRate stateSensor1.massFlowRate.system.m_flow_nominal
     = (if stateSensor1.massFlowRate.system.use_eps_Re then 1 else 100.0*
    stateSensor1.massFlowRate.system.m_flow_small) "Default nominal mass flow rate";
  parameter Real stateSensor1.massFlowRate.system.eps_m_flow(min = 0.0) = 0.0001
     "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal";
  parameter Modelica.Units.SI.AbsolutePressure stateSensor1.massFlowRate.system.dp_small
     = 1 "Default small pressure drop for regularization of laminar and zero flow";
  parameter Modelica.Units.SI.MassFlowRate stateSensor1.massFlowRate.system.m_flow_small
    (min = 0.0) = 0.01 "Default small mass flow rate for regularization of laminar and zero flow";
  constant Boolean stateSensor1.massFlowRate.allowFlowReversal = true 
    "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean stateSensor1.massFlowRate.port_a_exposesState = false 
    "= true if port_a exposes the state of a fluid volume";
  parameter Boolean stateSensor1.massFlowRate.port_b_exposesState = false 
    "= true if port_b.p exposes the state of a fluid volume";
  parameter Boolean stateSensor1.massFlowRate.showDesignFlowDirection = true 
    "= false to hide the arrow in the model icon";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    stateSensor1.massFlowRate.m_flow_nominal = stateSensor1.massFlowRate.system.m_flow_nominal
     "Nominal value of m_flow = port_a.m_flow";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    stateSensor1.massFlowRate.m_flow_small(min = 0.0) = (if stateSensor1.massFlowRate.system.use_eps_Re
     then stateSensor1.massFlowRate.system.eps_m_flow*stateSensor1.massFlowRate.m_flow_nominal
     else stateSensor1.massFlowRate.system.m_flow_small) "Regularization for bi-directional flow in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
  parameter Modelica.Units.SI.AbsolutePressure stateSensor2.system.p_ambient = 101325
     "Default ambient pressure";
  parameter Modelica.Units.SI.Temperature stateSensor2.system.T_ambient = 293.15
     "Default ambient temperature";
  parameter Modelica.Units.SI.Acceleration stateSensor2.system.g = 9.80665 
    "Constant gravity acceleration";
  constant Boolean stateSensor2.system.allowFlowReversal = true "= false to restrict to design flow direction (port_a -> port_b)";
  parameter Modelica.Fluid.Types.Dynamics stateSensor2.system.energyDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics stateSensor2.system.massDynamics = 
    stateSensor2.system.energyDynamics "Default formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics stateSensor2.system.substanceDynamics
     = stateSensor2.system.massDynamics "Default formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics stateSensor2.system.traceDynamics = 
    stateSensor2.system.massDynamics "Default formulation of trace substance balances";
  parameter Modelica.Fluid.Types.Dynamics stateSensor2.system.momentumDynamics
     = Modelica.Fluid.Types.Dynamics.SteadyState "Default formulation of momentum balances, if options available";
  parameter Modelica.Units.SI.MassFlowRate stateSensor2.system.m_flow_start = 0 
    "Default start value for mass flow rates";
  parameter Modelica.Units.SI.AbsolutePressure stateSensor2.system.p_start = 
    stateSensor2.system.p_ambient "Default start value for pressures";
  parameter Modelica.Units.SI.Temperature stateSensor2.system.T_start = 
    stateSensor2.system.T_ambient "Default start value for temperatures";
  parameter Boolean stateSensor2.system.use_eps_Re = false "= true to determine turbulent region automatically using Reynolds number";
  parameter Modelica.Units.SI.MassFlowRate stateSensor2.system.m_flow_nominal = 
    (if stateSensor2.system.use_eps_Re then 1 else 100.0*stateSensor2.system.m_flow_small)
     "Default nominal mass flow rate";
  parameter Real stateSensor2.system.eps_m_flow(min = 0.0) = 0.0001 
    "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal";
  parameter Modelica.Units.SI.AbsolutePressure stateSensor2.system.dp_small = 1 
    "Default small pressure drop for regularization of laminar and zero flow";
  parameter Modelica.Units.SI.MassFlowRate stateSensor2.system.m_flow_small(
    min = 0.0) = 0.01 "Default small mass flow rate for regularization of laminar and zero flow";
  constant Boolean stateSensor2.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean stateSensor2.port_a_exposesState = false "= true if port_a exposes the state of a fluid volume";
  parameter Boolean stateSensor2.port_b_exposesState = false "= true if port_b.p exposes the state of a fluid volume";
  parameter Boolean stateSensor2.showDesignFlowDirection = false 
    "= false to hide the arrow in the model icon";
  parameter Boolean stateSensor2.use_Display = true "true to enable display panel";
  parameter Modelica.Units.SI.AbsolutePressure stateSensor2.massFlowRate.system.p_ambient
     = 101325 "Default ambient pressure";
  parameter Modelica.Units.SI.Temperature stateSensor2.massFlowRate.system.T_ambient
     = 293.15 "Default ambient temperature";
  parameter Modelica.Units.SI.Acceleration stateSensor2.massFlowRate.system.g = 
    9.80665 "Constant gravity acceleration";
  constant Boolean stateSensor2.massFlowRate.system.allowFlowReversal = true 
    "= false to restrict to design flow direction (port_a -> port_b)";
  parameter Modelica.Fluid.Types.Dynamics stateSensor2.massFlowRate.system.energyDynamics
     = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics stateSensor2.massFlowRate.system.massDynamics
     = stateSensor2.massFlowRate.system.energyDynamics "Default formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics stateSensor2.massFlowRate.system.substanceDynamics
     = stateSensor2.massFlowRate.system.massDynamics "Default formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics stateSensor2.massFlowRate.system.traceDynamics
     = stateSensor2.massFlowRate.system.massDynamics "Default formulation of trace substance balances";
  parameter Modelica.Fluid.Types.Dynamics stateSensor2.massFlowRate.system.momentumDynamics
     = Modelica.Fluid.Types.Dynamics.SteadyState "Default formulation of momentum balances, if options available";
  parameter Modelica.Units.SI.MassFlowRate stateSensor2.massFlowRate.system.m_flow_start
     = 0 "Default start value for mass flow rates";
  parameter Modelica.Units.SI.AbsolutePressure stateSensor2.massFlowRate.system.p_start
     = stateSensor2.massFlowRate.system.p_ambient "Default start value for pressures";
  parameter Modelica.Units.SI.Temperature stateSensor2.massFlowRate.system.T_start
     = stateSensor2.massFlowRate.system.T_ambient "Default start value for temperatures";
  parameter Boolean stateSensor2.massFlowRate.system.use_eps_Re = false 
    "= true to determine turbulent region automatically using Reynolds number";
  parameter Modelica.Units.SI.MassFlowRate stateSensor2.massFlowRate.system.m_flow_nominal
     = (if stateSensor2.massFlowRate.system.use_eps_Re then 1 else 100.0*
    stateSensor2.massFlowRate.system.m_flow_small) "Default nominal mass flow rate";
  parameter Real stateSensor2.massFlowRate.system.eps_m_flow(min = 0.0) = 0.0001
     "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal";
  parameter Modelica.Units.SI.AbsolutePressure stateSensor2.massFlowRate.system.dp_small
     = 1 "Default small pressure drop for regularization of laminar and zero flow";
  parameter Modelica.Units.SI.MassFlowRate stateSensor2.massFlowRate.system.m_flow_small
    (min = 0.0) = 0.01 "Default small mass flow rate for regularization of laminar and zero flow";
  constant Boolean stateSensor2.massFlowRate.allowFlowReversal = true 
    "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean stateSensor2.massFlowRate.port_a_exposesState = false 
    "= true if port_a exposes the state of a fluid volume";
  parameter Boolean stateSensor2.massFlowRate.port_b_exposesState = false 
    "= true if port_b.p exposes the state of a fluid volume";
  parameter Boolean stateSensor2.massFlowRate.showDesignFlowDirection = true 
    "= false to hide the arrow in the model icon";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    stateSensor2.massFlowRate.m_flow_nominal = stateSensor2.massFlowRate.system.m_flow_nominal
     "Nominal value of m_flow = port_a.m_flow";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    stateSensor2.massFlowRate.m_flow_small(min = 0.0) = (if stateSensor2.massFlowRate.system.use_eps_Re
     then stateSensor2.massFlowRate.system.eps_m_flow*stateSensor2.massFlowRate.m_flow_nominal
     else stateSensor2.massFlowRate.system.m_flow_small) "Regularization for bi-directional flow in the region |m_flow| < m_flow_small (m_flow_small > 0 required)";
  parameter Integer stateDisplay2.precision_p = 2 "Number of significant digits - pressure";
  parameter Integer stateDisplay2.precision_h = 1 "Number of significant digits - specific enthalpy";
  parameter Integer stateDisplay2.precision_T = 1 "Number of significant digits - temperature";
  parameter Integer stateDisplay2.precision_m_flow = 1 "Number of significant digits - mass flow";
  parameter Boolean stateDisplay2.displayUnits = false "If true the actual units are displayed";
  parameter Integer stateDisplay1.precision_p = 2 "Number of significant digits - pressure";
  parameter Integer stateDisplay1.precision_h = 1 "Number of significant digits - specific enthalpy";
  parameter Integer stateDisplay1.precision_T = 1 "Number of significant digits - temperature";
  parameter Integer stateDisplay1.precision_m_flow = 1 "Number of significant digits - mass flow";
  parameter Boolean stateDisplay1.displayUnits = false "If true the actual units are displayed";
  parameter NHES.Systems.BalanceOfPlant.RankineCycle.Data.BOP_Type 
    BOP.CS.data.FH_type = NHES.Systems.BalanceOfPlant.RankineCycle.Data.BOP_Type.
    OFWH "Type of Feed Heating";
  parameter Modelica.Units.SI.Pressure BOP.CS.data.HPT_p_in = data.HPT_p_in 
    "High Pressure Turbine Inlet Pressure";
  parameter Modelica.Units.SI.Pressure BOP.CS.data.p_dump = data.p_dump 
    "Overpressure Set Pressure  ";
  parameter Modelica.Units.SI.Power BOP.CS.data.Power_nom = data.Power_nom 
    "Electrical Power Nominal";
  parameter Modelica.Units.SI.Pressure BOP.CS.data.p_i1 = data.p_i1 
    "Set Pressure Between High Pressure Turbine and Low Pressure Turbine 1";
  parameter Modelica.Units.SI.Pressure BOP.CS.data.p_i2 = data.p_i2 
    "Set Pressure Between Low Pressure Turbine 1 and Low Pressure Turbine 2";
  parameter Modelica.Units.SI.Pressure BOP.CS.data.cond_p = data.cond_p 
    "Condenser Pressure";
  parameter Modelica.Units.SI.Temperature BOP.CS.data.Tin = data.Tin 
    "Inlet Steam Temperature";
  parameter Modelica.Units.SI.Temperature BOP.CS.data.Tfeed = data.Tfeed 
    "Target Feed Water Temperature";
  parameter Modelica.Units.SI.Density BOP.CS.data.d_HPT_in(displayUnit = "kg/m3")
     = data.d_HPT_in "HPT inlet density";
  parameter Modelica.Units.SI.Density BOP.CS.data.d_LPT1_in = data.d_LPT1_in 
    "LPT1 inlet density";
  parameter Modelica.Units.SI.Density BOP.CS.data.d_LPT2_in(displayUnit = 
    "kg/m3") = data.d_LPT2_in "LPT2 inlet density";
  parameter Modelica.Units.SI.Pressure BOP.CS.data.HPT_p_out = BOP.CS.data.p_i1;
  parameter Modelica.Units.SI.Pressure BOP.CS.data.LPT1_p_in = BOP.CS.data.p_i1;
  parameter Modelica.Units.SI.Pressure BOP.CS.data.LPT1_p_out = BOP.CS.data.p_i2;
  parameter Modelica.Units.SI.Pressure BOP.CS.data.LPT2_p_in = BOP.CS.data.p_i2;
  parameter Modelica.Units.SI.Pressure BOP.CS.data.LPT2_p_out = BOP.CS.data.cond_p;
  parameter Modelica.Units.SI.MassFlowRate BOP.CS.data.mdot_total = 
    data.mdot_total "Nominal Total Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate BOP.CS.data.mdot_fh = data.mdot_fh 
    "Nominal Controlled Feed Heating Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate BOP.CS.data.mdpt_HPFH = 
    data.mdpt_HPFH "Set High pressure feedwater heating flow (used in models with both LP and HP feed heating";
  parameter Modelica.Units.SI.MassFlowRate BOP.CS.data.mdot_hpt = data.mdot_hpt 
    "Nominal Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate BOP.CS.data.mdot_lpt1 = 
    data.mdot_lpt1 "Nominal Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate BOP.CS.data.mdot_lpt2 = 
    data.mdot_lpt2 "Nominal Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate BOP.CS.data.m_ext = data.m_ext;
  parameter Modelica.Units.SI.AbsolutePressure BOP.CS.data.p_use = 100000.0;
  parameter Real BOP.CS.data.eta_t = data.eta_t "Isentropic Efficiency of the Turbines";
  parameter Real BOP.CS.data.eta_mech = data.eta_mech "Mechincal Effieiency of the Turbines";
  parameter Real BOP.CS.data.eta_p = data.eta_p "Isentropic Efficiency of the Pumps";
  parameter Real BOP.CS.data.BypassFeedHeater_NTU = 20 "NTU of bypass feedwater heater";
  parameter Real BOP.CS.data.BypassFeedHeater_K_tube(unit = "1/m4") = 17000 
    "K value of tube in bypass feedwater heater";
  parameter Real BOP.CS.data.BypassFeedHeater_K_shell(unit = "1/m4") = 500 
    "K value of shell in bypass feedwater heater";
  parameter Modelica.Units.SI.Volume BOP.CS.data.BypassFeedHeater_V_tube = 5 
    "Tube side volume in bypass feedwater heater";
  parameter Modelica.Units.SI.Volume BOP.CS.data.BypassFeedHeater_V_shell = 5 
    "Shell side volume in bypass feedwater heater";
  parameter Modelica.Units.SI.Volume BOP.CS.data.V_condensor_liquid_start = 1.2 
    "Condensor volume";
  parameter Modelica.Units.SI.Pressure BOP.CS.data.BypassFeedHeater_tube_p_start
     = 5500000.0 "Initial Tube pressure of bypass feedwater heater";
  parameter Modelica.Units.SI.Pressure BOP.CS.data.BypassFeedHeater_shell_p_start
     = 1000000.0 "Initial Shell pressure of bypass feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy BOP.CS.data.BypassFeedHeater_h_start_tube_inlet
     = 1000000.0 "Initial Tube inlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy BOP.CS.data.BypassFeedHeater_h_start_tube_outlet
     = 1050000.0 "Initial Tube outlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy BOP.CS.data.BypassFeedHeater_h_start_shell_inlet
     = 3000000.0 "Initial Shell inlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy BOP.CS.data.BypassFeedHeater_h_start_shell_outlet
     = 2900000.0 "Initial Shell outlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.Temperature BOP.CS.data.BypassFeedHeater_tube_T_start_inlet
     = 318 "Initial Tube inlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Temperature BOP.CS.data.BypassFeedHeater_tube_T_start_outlet
     = 473 "Initial Tube outlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Temperature BOP.CS.data.BypassFeedHeater_shell_T_start_inlet
     = 643 "Initial Tube inlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Temperature BOP.CS.data.BypassFeedHeater_shell_T_start_outlet
     = 523 "Initial Tube outlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Pressure BOP.CS.data.BypassFeedHeater_dp_init_tube
     = 0 "Initial Tube pressure drop of bypass feedwater heater";
  parameter Modelica.Units.SI.Pressure BOP.CS.data.BypassFeedHeater_dp_init_shell
     = 100000 "Initial Shell pressure drop of bypass feedwater heater";
  parameter Modelica.Units.SI.MassFlowRate BOP.CS.data.BypassFeedHeater_m_start_tube
     = 72 "Initial tube mass flow rate in bypass feedwater heater";
  parameter Modelica.Units.SI.MassFlowRate BOP.CS.data.BypassFeedHeater_m_start_shell
     = 10 "Initial shell mass flow rate in main feedwater heater";
  parameter Modelica.Units.SI.Power BOP.CS.data.BypassFeedHeater_Q_init = 
    1000000.0 "Initial Heat Flow in main feedwater heater";
  constant Modelica.Blocks.Types.SimpleController BOP.CS.FeedPump_PID.controllerType
     = Modelica.Blocks.Types.SimpleController.PI "Type of controller";
  constant Boolean BOP.CS.FeedPump_PID.with_FF = false "enable feed-forward input signal";
  parameter Boolean BOP.CS.FeedPump_PID.derMeas = true "=true avoid derivative kick";
  parameter Real BOP.CS.FeedPump_PID.k = -0.0001 "Controller gain: +/- for direct/reverse acting";
  parameter Modelica.Units.SI.Time BOP.CS.FeedPump_PID.Ti(min = 1E-60) = 360 
    "Time constant of Integrator block";
  parameter Modelica.Units.SI.Time BOP.CS.FeedPump_PID.Td(min = 0.0) = 0.1 
    "Time constant of Derivative block";
  parameter Real BOP.CS.FeedPump_PID.yb = 0 "Output bias. May improve simulation";
  parameter Real BOP.CS.FeedPump_PID.k_s = 1 "Setpoint input scaling: k_s*u_s. May improve simulation";
  parameter Real BOP.CS.FeedPump_PID.k_m = 1 "Measurement input scaling: k_m*u_m. May improve simulation";
  parameter Real BOP.CS.FeedPump_PID.k_ff = 1 "Measurement input scaling: k_ff*u_ff. May improve simulation";
  parameter Real BOP.CS.FeedPump_PID.yMax(start = 1) = 2*BOP.CS.data.mdot_total 
    "Upper limit of output";
  parameter Real BOP.CS.FeedPump_PID.yMin = BOP.CS.data.mdot_total*0.5 
    "Lower limit of output";
  parameter Real BOP.CS.FeedPump_PID.wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
  parameter Real BOP.CS.FeedPump_PID.wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
  parameter Real BOP.CS.FeedPump_PID.Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
  parameter Real BOP.CS.FeedPump_PID.Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
  parameter Modelica.Blocks.Types.Init BOP.CS.FeedPump_PID.initType = 
    Modelica.Blocks.Types.Init.NoInit "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
  parameter Real BOP.CS.FeedPump_PID.xi_start = 0 "Initial or guess value value for integrator output (= integrator state)";
  parameter Real BOP.CS.FeedPump_PID.xd_start = 0 "Initial or guess value for state of derivative block";
  parameter Real BOP.CS.FeedPump_PID.y_start = 0 "Initial value of output";
  parameter Boolean BOP.CS.FeedPump_PID.strict = false "= true, if strict limits with noEvent(..)";
  constant TRANSFORM.Types.Reset BOP.CS.FeedPump_PID.reset = TRANSFORM.Types.Reset.
    Disabled "Type of controller output reset";
  parameter Real BOP.CS.FeedPump_PID.y_reset = BOP.CS.FeedPump_PID.xi_start 
    "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == TRANSFORM.Types.Reset.Parameter";
  parameter Real BOP.CS.FeedPump_PID.addP.k1 = BOP.CS.FeedPump_PID.wp 
    "Gain of input signal 1";
  parameter Real BOP.CS.FeedPump_PID.addP.k2 = -1 "Gain of input signal 2";
  parameter Real BOP.CS.FeedPump_PID.P.k(start = 1, unit = "1") = 1 
    "Gain value multiplied with input signal";
  parameter Real BOP.CS.FeedPump_PID.gainPID.k(start = 1, unit = "1") = 
    BOP.CS.FeedPump_PID.k "Gain value multiplied with input signal";
  parameter Real BOP.CS.FeedPump_PID.addPID.k1 = 1 "Gain of input signal 1";
  parameter Real BOP.CS.FeedPump_PID.addPID.k2 = 1 "Gain of input signal 2";
  parameter Real BOP.CS.FeedPump_PID.addPID.k3 = 1 "Gain of input signal 3";
  parameter Real BOP.CS.FeedPump_PID.limiter.uMax(start = 1) = BOP.CS.FeedPump_PID.yMax
     "Upper limits of input signals";
  parameter Real BOP.CS.FeedPump_PID.limiter.uMin = BOP.CS.FeedPump_PID.yMin 
    "Lower limits of input signals";
  parameter Boolean BOP.CS.FeedPump_PID.limiter.strict = BOP.CS.FeedPump_PID.strict
     "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy BOP.CS.FeedPump_PID.limiter.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Real BOP.CS.FeedPump_PID.Fzero.k(start = 1) = 0 "Constant output value";
  parameter Real BOP.CS.FeedPump_PID.addFF.k1 = 1 "Gain of input signal 1";
  parameter Real BOP.CS.FeedPump_PID.addFF.k2 = 1 "Gain of input signal 2";
  parameter Real BOP.CS.FeedPump_PID.addFF.k3 = 1 "Gain of input signal 3";
  parameter Real BOP.CS.FeedPump_PID.gain_u_s.k(start = 1, unit = "1") = 
    BOP.CS.FeedPump_PID.k_s "Gain value multiplied with input signal";
  parameter Real BOP.CS.FeedPump_PID.gain_u_m.k(start = 1, unit = "1") = 
    BOP.CS.FeedPump_PID.k_m "Gain value multiplied with input signal";
  parameter Real BOP.CS.FeedPump_PID.null_bias.k(start = 1) = BOP.CS.FeedPump_PID.yb
     "Constant output value";
  constant Modelica.Units.SI.Time BOP.CS.FeedPump_PID.unitTime = 1;
  constant Boolean BOP.CS.FeedPump_PID.with_I = true;
  constant Boolean BOP.CS.FeedPump_PID.with_D = false;
  parameter Real BOP.CS.FeedPump_PID.I.k(unit = "1") = BOP.CS.FeedPump_PID.unitTime
    /BOP.CS.FeedPump_PID.Ti "Integrator gain";
  parameter Modelica.Blocks.Types.Init BOP.CS.FeedPump_PID.I.initType = (if 
    BOP.CS.FeedPump_PID.initType == Modelica.Blocks.Types.Init.SteadyState then 
    Modelica.Blocks.Types.Init.SteadyState else (if BOP.CS.FeedPump_PID.initType
     == Modelica.Blocks.Types.Init.InitialState or BOP.CS.FeedPump_PID.initType
     == Modelica.Blocks.Types.Init.InitialState then Modelica.Blocks.Types.Init.
    InitialState else Modelica.Blocks.Types.Init.NoInit)) "Type of initialization (1: no init, 2: steady state, 3,4: initial output)";
  parameter Real BOP.CS.FeedPump_PID.I.y_start = BOP.CS.FeedPump_PID.xi_start 
    "Initial or guess value of output (= state)";
  constant TRANSFORM.Types.Reset BOP.CS.FeedPump_PID.I.reset = TRANSFORM.Types.Reset.
    Disabled "Type of integrator reset";
  parameter Real BOP.CS.FeedPump_PID.I.y_reset = BOP.CS.FeedPump_PID.y_reset 
    "Value to which integrator is reset, used if reset = TRANSFORM.Types.Reset.Parameter";
  parameter Real BOP.CS.FeedPump_PID.addI.k1 = 1 "Gain of input signal 1";
  parameter Real BOP.CS.FeedPump_PID.addI.k2 = -1 "Gain of input signal 2";
  parameter Real BOP.CS.FeedPump_PID.addI.k3 = 1 "Gain of input signal 3";
  parameter Real BOP.CS.FeedPump_PID.addSat.k1 = 1 "Gain of input signal 1";
  parameter Real BOP.CS.FeedPump_PID.addSat.k2 = -1 "Gain of input signal 2";
  parameter Real BOP.CS.FeedPump_PID.gainTrack.k(start = 1, unit = "1") = 1/(
    BOP.CS.FeedPump_PID.k*BOP.CS.FeedPump_PID.Ni) "Gain value multiplied with input signal";
  parameter Real BOP.CS.FeedPump_PID.Dzero.k(start = 1) = 0 "Constant output value";
  constant Modelica.Blocks.Types.SimpleController BOP.CS.TCV_PID.controllerType
     = Modelica.Blocks.Types.SimpleController.PI "Type of controller";
  constant Boolean BOP.CS.TCV_PID.with_FF = false "enable feed-forward input signal";
  parameter Boolean BOP.CS.TCV_PID.derMeas = true "=true avoid derivative kick";
  parameter Real BOP.CS.TCV_PID.k = -5E-07 "Controller gain: +/- for direct/reverse acting";
  parameter Modelica.Units.SI.Time BOP.CS.TCV_PID.Ti(min = 1E-60) = 250 
    "Time constant of Integrator block";
  parameter Modelica.Units.SI.Time BOP.CS.TCV_PID.Td(min = 0.0) = 0.1 
    "Time constant of Derivative block";
  parameter Real BOP.CS.TCV_PID.yb = 0 "Output bias. May improve simulation";
  parameter Real BOP.CS.TCV_PID.k_s = 1 "Setpoint input scaling: k_s*u_s. May improve simulation";
  parameter Real BOP.CS.TCV_PID.k_m = 1 "Measurement input scaling: k_m*u_m. May improve simulation";
  parameter Real BOP.CS.TCV_PID.k_ff = 1 "Measurement input scaling: k_ff*u_ff. May improve simulation";
  parameter Real BOP.CS.TCV_PID.yMax(start = 1) = 1 "Upper limit of output";
  parameter Real BOP.CS.TCV_PID.yMin = 0 "Lower limit of output";
  parameter Real BOP.CS.TCV_PID.wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
  parameter Real BOP.CS.TCV_PID.wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
  parameter Real BOP.CS.TCV_PID.Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
  parameter Real BOP.CS.TCV_PID.Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
  parameter Modelica.Blocks.Types.Init BOP.CS.TCV_PID.initType = 
    Modelica.Blocks.Types.Init.NoInit "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
  parameter Real BOP.CS.TCV_PID.xi_start = 0.8 "Initial or guess value value for integrator output (= integrator state)";
  parameter Real BOP.CS.TCV_PID.xd_start = 0 "Initial or guess value for state of derivative block";
  parameter Real BOP.CS.TCV_PID.y_start = 0 "Initial value of output";
  parameter Boolean BOP.CS.TCV_PID.strict = false "= true, if strict limits with noEvent(..)";
  constant TRANSFORM.Types.Reset BOP.CS.TCV_PID.reset = TRANSFORM.Types.Reset.
    Disabled "Type of controller output reset";
  parameter Real BOP.CS.TCV_PID.y_reset = BOP.CS.TCV_PID.xi_start 
    "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == TRANSFORM.Types.Reset.Parameter";
  parameter Real BOP.CS.TCV_PID.addP.k1 = BOP.CS.TCV_PID.wp "Gain of input signal 1";
  parameter Real BOP.CS.TCV_PID.addP.k2 = -1 "Gain of input signal 2";
  parameter Real BOP.CS.TCV_PID.P.k(start = 1, unit = "1") = 1 "Gain value multiplied with input signal";
  parameter Real BOP.CS.TCV_PID.gainPID.k(start = 1, unit = "1") = 
    BOP.CS.TCV_PID.k "Gain value multiplied with input signal";
  parameter Real BOP.CS.TCV_PID.addPID.k1 = 1 "Gain of input signal 1";
  parameter Real BOP.CS.TCV_PID.addPID.k2 = 1 "Gain of input signal 2";
  parameter Real BOP.CS.TCV_PID.addPID.k3 = 1 "Gain of input signal 3";
  parameter Real BOP.CS.TCV_PID.limiter.uMax(start = 1) = BOP.CS.TCV_PID.yMax 
    "Upper limits of input signals";
  parameter Real BOP.CS.TCV_PID.limiter.uMin = BOP.CS.TCV_PID.yMin 
    "Lower limits of input signals";
  parameter Boolean BOP.CS.TCV_PID.limiter.strict = BOP.CS.TCV_PID.strict 
    "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy BOP.CS.TCV_PID.limiter.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Real BOP.CS.TCV_PID.Fzero.k(start = 1) = 0 "Constant output value";
  parameter Real BOP.CS.TCV_PID.addFF.k1 = 1 "Gain of input signal 1";
  parameter Real BOP.CS.TCV_PID.addFF.k2 = 1 "Gain of input signal 2";
  parameter Real BOP.CS.TCV_PID.addFF.k3 = 1 "Gain of input signal 3";
  parameter Real BOP.CS.TCV_PID.gain_u_s.k(start = 1, unit = "1") = 
    BOP.CS.TCV_PID.k_s "Gain value multiplied with input signal";
  parameter Real BOP.CS.TCV_PID.gain_u_m.k(start = 1, unit = "1") = 
    BOP.CS.TCV_PID.k_m "Gain value multiplied with input signal";
  parameter Real BOP.CS.TCV_PID.null_bias.k(start = 1) = BOP.CS.TCV_PID.yb 
    "Constant output value";
  constant Modelica.Units.SI.Time BOP.CS.TCV_PID.unitTime = 1;
  constant Boolean BOP.CS.TCV_PID.with_I = true;
  constant Boolean BOP.CS.TCV_PID.with_D = false;
  parameter Real BOP.CS.TCV_PID.I.k(unit = "1") = BOP.CS.TCV_PID.unitTime/
    BOP.CS.TCV_PID.Ti "Integrator gain";
  parameter Modelica.Blocks.Types.Init BOP.CS.TCV_PID.I.initType = (if 
    BOP.CS.TCV_PID.initType == Modelica.Blocks.Types.Init.SteadyState then 
    Modelica.Blocks.Types.Init.SteadyState else (if BOP.CS.TCV_PID.initType == 
    Modelica.Blocks.Types.Init.InitialState or BOP.CS.TCV_PID.initType == 
    Modelica.Blocks.Types.Init.InitialState then Modelica.Blocks.Types.Init.
    InitialState else Modelica.Blocks.Types.Init.NoInit)) "Type of initialization (1: no init, 2: steady state, 3,4: initial output)";
  parameter Real BOP.CS.TCV_PID.I.y_start = BOP.CS.TCV_PID.xi_start 
    "Initial or guess value of output (= state)";
  constant TRANSFORM.Types.Reset BOP.CS.TCV_PID.I.reset = TRANSFORM.Types.Reset.
    Disabled "Type of integrator reset";
  parameter Real BOP.CS.TCV_PID.I.y_reset = BOP.CS.TCV_PID.y_reset 
    "Value to which integrator is reset, used if reset = TRANSFORM.Types.Reset.Parameter";
  parameter Real BOP.CS.TCV_PID.addI.k1 = 1 "Gain of input signal 1";
  parameter Real BOP.CS.TCV_PID.addI.k2 = -1 "Gain of input signal 2";
  parameter Real BOP.CS.TCV_PID.addI.k3 = 1 "Gain of input signal 3";
  parameter Real BOP.CS.TCV_PID.addSat.k1 = 1 "Gain of input signal 1";
  parameter Real BOP.CS.TCV_PID.addSat.k2 = -1 "Gain of input signal 2";
  parameter Real BOP.CS.TCV_PID.gainTrack.k(start = 1, unit = "1") = 1/(
    BOP.CS.TCV_PID.k*BOP.CS.TCV_PID.Ni) "Gain value multiplied with input signal";
  parameter Real BOP.CS.TCV_PID.Dzero.k(start = 1) = 0 "Constant output value";
  constant Modelica.Blocks.Types.SimpleController BOP.CS.LPT1_BV_PID.controllerType
     = Modelica.Blocks.Types.SimpleController.PI "Type of controller";
  constant Boolean BOP.CS.LPT1_BV_PID.with_FF = false "enable feed-forward input signal";
  parameter Boolean BOP.CS.LPT1_BV_PID.derMeas = true "=true avoid derivative kick";
  parameter Real BOP.CS.LPT1_BV_PID.k = 5E-09 "Controller gain: +/- for direct/reverse acting";
  parameter Modelica.Units.SI.Time BOP.CS.LPT1_BV_PID.Ti(min = 1E-60) = 300 
    "Time constant of Integrator block";
  parameter Modelica.Units.SI.Time BOP.CS.LPT1_BV_PID.Td(min = 0.0) = 0.1 
    "Time constant of Derivative block";
  parameter Real BOP.CS.LPT1_BV_PID.yb = 0 "Output bias. May improve simulation";
  parameter Real BOP.CS.LPT1_BV_PID.k_s = 1 "Setpoint input scaling: k_s*u_s. May improve simulation";
  parameter Real BOP.CS.LPT1_BV_PID.k_m = 1 "Measurement input scaling: k_m*u_m. May improve simulation";
  parameter Real BOP.CS.LPT1_BV_PID.k_ff = 1 "Measurement input scaling: k_ff*u_ff. May improve simulation";
  parameter Real BOP.CS.LPT1_BV_PID.yMax(start = 1) = 1 "Upper limit of output";
  parameter Real BOP.CS.LPT1_BV_PID.yMin = 0 "Lower limit of output";
  parameter Real BOP.CS.LPT1_BV_PID.wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
  parameter Real BOP.CS.LPT1_BV_PID.wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
  parameter Real BOP.CS.LPT1_BV_PID.Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
  parameter Real BOP.CS.LPT1_BV_PID.Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
  parameter Modelica.Blocks.Types.Init BOP.CS.LPT1_BV_PID.initType = 
    Modelica.Blocks.Types.Init.NoInit "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
  parameter Real BOP.CS.LPT1_BV_PID.xi_start = 0 "Initial or guess value value for integrator output (= integrator state)";
  parameter Real BOP.CS.LPT1_BV_PID.xd_start = 0 "Initial or guess value for state of derivative block";
  parameter Real BOP.CS.LPT1_BV_PID.y_start = 0 "Initial value of output";
  parameter Boolean BOP.CS.LPT1_BV_PID.strict = false "= true, if strict limits with noEvent(..)";
  constant TRANSFORM.Types.Reset BOP.CS.LPT1_BV_PID.reset = TRANSFORM.Types.Reset.
    Disabled "Type of controller output reset";
  parameter Real BOP.CS.LPT1_BV_PID.y_reset = BOP.CS.LPT1_BV_PID.xi_start 
    "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == TRANSFORM.Types.Reset.Parameter";
  parameter Real BOP.CS.LPT1_BV_PID.addP.k1 = BOP.CS.LPT1_BV_PID.wp 
    "Gain of input signal 1";
  parameter Real BOP.CS.LPT1_BV_PID.addP.k2 = -1 "Gain of input signal 2";
  parameter Real BOP.CS.LPT1_BV_PID.P.k(start = 1, unit = "1") = 1 
    "Gain value multiplied with input signal";
  parameter Real BOP.CS.LPT1_BV_PID.gainPID.k(start = 1, unit = "1") = 
    BOP.CS.LPT1_BV_PID.k "Gain value multiplied with input signal";
  parameter Real BOP.CS.LPT1_BV_PID.addPID.k1 = 1 "Gain of input signal 1";
  parameter Real BOP.CS.LPT1_BV_PID.addPID.k2 = 1 "Gain of input signal 2";
  parameter Real BOP.CS.LPT1_BV_PID.addPID.k3 = 1 "Gain of input signal 3";
  parameter Real BOP.CS.LPT1_BV_PID.limiter.uMax(start = 1) = BOP.CS.LPT1_BV_PID.yMax
     "Upper limits of input signals";
  parameter Real BOP.CS.LPT1_BV_PID.limiter.uMin = BOP.CS.LPT1_BV_PID.yMin 
    "Lower limits of input signals";
  parameter Boolean BOP.CS.LPT1_BV_PID.limiter.strict = BOP.CS.LPT1_BV_PID.strict
     "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy BOP.CS.LPT1_BV_PID.limiter.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Real BOP.CS.LPT1_BV_PID.Fzero.k(start = 1) = 0 "Constant output value";
  parameter Real BOP.CS.LPT1_BV_PID.addFF.k1 = 1 "Gain of input signal 1";
  parameter Real BOP.CS.LPT1_BV_PID.addFF.k2 = 1 "Gain of input signal 2";
  parameter Real BOP.CS.LPT1_BV_PID.addFF.k3 = 1 "Gain of input signal 3";
  parameter Real BOP.CS.LPT1_BV_PID.gain_u_s.k(start = 1, unit = "1") = 
    BOP.CS.LPT1_BV_PID.k_s "Gain value multiplied with input signal";
  parameter Real BOP.CS.LPT1_BV_PID.gain_u_m.k(start = 1, unit = "1") = 
    BOP.CS.LPT1_BV_PID.k_m "Gain value multiplied with input signal";
  parameter Real BOP.CS.LPT1_BV_PID.null_bias.k(start = 1) = BOP.CS.LPT1_BV_PID.yb
     "Constant output value";
  constant Modelica.Units.SI.Time BOP.CS.LPT1_BV_PID.unitTime = 1;
  constant Boolean BOP.CS.LPT1_BV_PID.with_I = true;
  constant Boolean BOP.CS.LPT1_BV_PID.with_D = false;
  parameter Real BOP.CS.LPT1_BV_PID.I.k(unit = "1") = BOP.CS.LPT1_BV_PID.unitTime
    /BOP.CS.LPT1_BV_PID.Ti "Integrator gain";
  parameter Modelica.Blocks.Types.Init BOP.CS.LPT1_BV_PID.I.initType = (if 
    BOP.CS.LPT1_BV_PID.initType == Modelica.Blocks.Types.Init.SteadyState then 
    Modelica.Blocks.Types.Init.SteadyState else (if BOP.CS.LPT1_BV_PID.initType
     == Modelica.Blocks.Types.Init.InitialState or BOP.CS.LPT1_BV_PID.initType
     == Modelica.Blocks.Types.Init.InitialState then Modelica.Blocks.Types.Init.
    InitialState else Modelica.Blocks.Types.Init.NoInit)) "Type of initialization (1: no init, 2: steady state, 3,4: initial output)";
  parameter Real BOP.CS.LPT1_BV_PID.I.y_start = BOP.CS.LPT1_BV_PID.xi_start 
    "Initial or guess value of output (= state)";
  constant TRANSFORM.Types.Reset BOP.CS.LPT1_BV_PID.I.reset = TRANSFORM.Types.Reset.
    Disabled "Type of integrator reset";
  parameter Real BOP.CS.LPT1_BV_PID.I.y_reset = BOP.CS.LPT1_BV_PID.y_reset 
    "Value to which integrator is reset, used if reset = TRANSFORM.Types.Reset.Parameter";
  parameter Real BOP.CS.LPT1_BV_PID.addI.k1 = 1 "Gain of input signal 1";
  parameter Real BOP.CS.LPT1_BV_PID.addI.k2 = -1 "Gain of input signal 2";
  parameter Real BOP.CS.LPT1_BV_PID.addI.k3 = 1 "Gain of input signal 3";
  parameter Real BOP.CS.LPT1_BV_PID.addSat.k1 = 1 "Gain of input signal 1";
  parameter Real BOP.CS.LPT1_BV_PID.addSat.k2 = -1 "Gain of input signal 2";
  parameter Real BOP.CS.LPT1_BV_PID.gainTrack.k(start = 1, unit = "1") = 1/(
    BOP.CS.LPT1_BV_PID.k*BOP.CS.LPT1_BV_PID.Ni) "Gain value multiplied with input signal";
  parameter Real BOP.CS.LPT1_BV_PID.Dzero.k(start = 1) = 0 "Constant output value";
  constant Modelica.Blocks.Types.SimpleController BOP.CS.LPT2_BV_PID.controllerType
     = Modelica.Blocks.Types.SimpleController.PI "Type of controller";
  constant Boolean BOP.CS.LPT2_BV_PID.with_FF = false "enable feed-forward input signal";
  parameter Boolean BOP.CS.LPT2_BV_PID.derMeas = true "=true avoid derivative kick";
  parameter Real BOP.CS.LPT2_BV_PID.k = 1 "Controller gain: +/- for direct/reverse acting";
  parameter Modelica.Units.SI.Time BOP.CS.LPT2_BV_PID.Ti(min = 1E-60) = 20 
    "Time constant of Integrator block";
  parameter Modelica.Units.SI.Time BOP.CS.LPT2_BV_PID.Td(min = 0.0) = 0.1 
    "Time constant of Derivative block";
  parameter Real BOP.CS.LPT2_BV_PID.yb = 0 "Output bias. May improve simulation";
  parameter Real BOP.CS.LPT2_BV_PID.k_s = 1 "Setpoint input scaling: k_s*u_s. May improve simulation";
  parameter Real BOP.CS.LPT2_BV_PID.k_m = 1 "Measurement input scaling: k_m*u_m. May improve simulation";
  parameter Real BOP.CS.LPT2_BV_PID.k_ff = 1 "Measurement input scaling: k_ff*u_ff. May improve simulation";
  parameter Real BOP.CS.LPT2_BV_PID.yMax(start = 1) = 1 "Upper limit of output";
  parameter Real BOP.CS.LPT2_BV_PID.yMin = 0 "Lower limit of output";
  parameter Real BOP.CS.LPT2_BV_PID.wp(min = 0.0) = 1 "Set-point weight for Proportional block (0..1)";
  parameter Real BOP.CS.LPT2_BV_PID.wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
  parameter Real BOP.CS.LPT2_BV_PID.Ni(min = 1E-13) = 0.9 "Ni*Ti is time constant of anti-windup compensation";
  parameter Real BOP.CS.LPT2_BV_PID.Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
  parameter Modelica.Blocks.Types.Init BOP.CS.LPT2_BV_PID.initType = 
    Modelica.Blocks.Types.Init.NoInit "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
  parameter Real BOP.CS.LPT2_BV_PID.xi_start = 0 "Initial or guess value value for integrator output (= integrator state)";
  parameter Real BOP.CS.LPT2_BV_PID.xd_start = 0 "Initial or guess value for state of derivative block";
  parameter Real BOP.CS.LPT2_BV_PID.y_start = 0 "Initial value of output";
  parameter Boolean BOP.CS.LPT2_BV_PID.strict = false "= true, if strict limits with noEvent(..)";
  constant TRANSFORM.Types.Reset BOP.CS.LPT2_BV_PID.reset = TRANSFORM.Types.Reset.
    Disabled "Type of controller output reset";
  parameter Real BOP.CS.LPT2_BV_PID.y_reset = BOP.CS.LPT2_BV_PID.xi_start 
    "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == TRANSFORM.Types.Reset.Parameter";
  parameter Real BOP.CS.LPT2_BV_PID.addP.k1 = BOP.CS.LPT2_BV_PID.wp 
    "Gain of input signal 1";
  parameter Real BOP.CS.LPT2_BV_PID.addP.k2 = -1 "Gain of input signal 2";
  parameter Real BOP.CS.LPT2_BV_PID.P.k(start = 1, unit = "1") = 1 
    "Gain value multiplied with input signal";
  parameter Real BOP.CS.LPT2_BV_PID.gainPID.k(start = 1, unit = "1") = 
    BOP.CS.LPT2_BV_PID.k "Gain value multiplied with input signal";
  parameter Real BOP.CS.LPT2_BV_PID.addPID.k1 = 1 "Gain of input signal 1";
  parameter Real BOP.CS.LPT2_BV_PID.addPID.k2 = 1 "Gain of input signal 2";
  parameter Real BOP.CS.LPT2_BV_PID.addPID.k3 = 1 "Gain of input signal 3";
  parameter Real BOP.CS.LPT2_BV_PID.limiter.uMax(start = 1) = BOP.CS.LPT2_BV_PID.yMax
     "Upper limits of input signals";
  parameter Real BOP.CS.LPT2_BV_PID.limiter.uMin = BOP.CS.LPT2_BV_PID.yMin 
    "Lower limits of input signals";
  parameter Boolean BOP.CS.LPT2_BV_PID.limiter.strict = BOP.CS.LPT2_BV_PID.strict
     "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy BOP.CS.LPT2_BV_PID.limiter.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Real BOP.CS.LPT2_BV_PID.Fzero.k(start = 1) = 0 "Constant output value";
  parameter Real BOP.CS.LPT2_BV_PID.addFF.k1 = 1 "Gain of input signal 1";
  parameter Real BOP.CS.LPT2_BV_PID.addFF.k2 = 1 "Gain of input signal 2";
  parameter Real BOP.CS.LPT2_BV_PID.addFF.k3 = 1 "Gain of input signal 3";
  parameter Real BOP.CS.LPT2_BV_PID.gain_u_s.k(start = 1, unit = "1") = 
    BOP.CS.LPT2_BV_PID.k_s "Gain value multiplied with input signal";
  parameter Real BOP.CS.LPT2_BV_PID.gain_u_m.k(start = 1, unit = "1") = 
    BOP.CS.LPT2_BV_PID.k_m "Gain value multiplied with input signal";
  parameter Real BOP.CS.LPT2_BV_PID.null_bias.k(start = 1) = BOP.CS.LPT2_BV_PID.yb
     "Constant output value";
  constant Modelica.Units.SI.Time BOP.CS.LPT2_BV_PID.unitTime = 1;
  constant Boolean BOP.CS.LPT2_BV_PID.with_I = true;
  constant Boolean BOP.CS.LPT2_BV_PID.with_D = false;
  parameter Real BOP.CS.LPT2_BV_PID.I.k(unit = "1") = BOP.CS.LPT2_BV_PID.unitTime
    /BOP.CS.LPT2_BV_PID.Ti "Integrator gain";
  parameter Modelica.Blocks.Types.Init BOP.CS.LPT2_BV_PID.I.initType = (if 
    BOP.CS.LPT2_BV_PID.initType == Modelica.Blocks.Types.Init.SteadyState then 
    Modelica.Blocks.Types.Init.SteadyState else (if BOP.CS.LPT2_BV_PID.initType
     == Modelica.Blocks.Types.Init.InitialState or BOP.CS.LPT2_BV_PID.initType
     == Modelica.Blocks.Types.Init.InitialState then Modelica.Blocks.Types.Init.
    InitialState else Modelica.Blocks.Types.Init.NoInit)) "Type of initialization (1: no init, 2: steady state, 3,4: initial output)";
  parameter Real BOP.CS.LPT2_BV_PID.I.y_start = BOP.CS.LPT2_BV_PID.xi_start 
    "Initial or guess value of output (= state)";
  constant TRANSFORM.Types.Reset BOP.CS.LPT2_BV_PID.I.reset = TRANSFORM.Types.Reset.
    Disabled "Type of integrator reset";
  parameter Real BOP.CS.LPT2_BV_PID.I.y_reset = BOP.CS.LPT2_BV_PID.y_reset 
    "Value to which integrator is reset, used if reset = TRANSFORM.Types.Reset.Parameter";
  parameter Real BOP.CS.LPT2_BV_PID.addI.k1 = 1 "Gain of input signal 1";
  parameter Real BOP.CS.LPT2_BV_PID.addI.k2 = -1 "Gain of input signal 2";
  parameter Real BOP.CS.LPT2_BV_PID.addI.k3 = 1 "Gain of input signal 3";
  parameter Real BOP.CS.LPT2_BV_PID.addSat.k1 = 1 "Gain of input signal 1";
  parameter Real BOP.CS.LPT2_BV_PID.addSat.k2 = -1 "Gain of input signal 2";
  parameter Real BOP.CS.LPT2_BV_PID.gainTrack.k(start = 1, unit = "1") = 1/(
    BOP.CS.LPT2_BV_PID.k*BOP.CS.LPT2_BV_PID.Ni) "Gain value multiplied with input signal";
  parameter Real BOP.CS.LPT2_BV_PID.Dzero.k(start = 1) = 0 "Constant output value";
  parameter Real BOP.CS.hysteresis.uLow(start = 0) = BOP.CS.data.HPT_p_in 
    "If y=true and u<uLow, switch to y=false";
  parameter Real BOP.CS.hysteresis.uHigh(start = 1) = BOP.CS.data.p_dump 
    "If y=false and u>uHigh, switch to y=true";
  parameter Boolean BOP.CS.hysteresis.pre_y_start = false "Value of pre(y) at initial time";
  parameter Real BOP.CS.ramp.height = -1 "Height of ramps";
  parameter Modelica.Units.SI.Time BOP.CS.ramp.duration(start = 2, min = 0.0) = 3000
     "Duration of ramp (= 0.0 gives a Step)";
  parameter Real BOP.CS.ramp.offset = 1 "Offset of output signal y";
  parameter Modelica.Units.SI.Time BOP.CS.ramp.startTime = 8000 "Output y = offset for time < startTime";
  parameter Modelica.Units.SI.Time BOP.CS.booleanStep.startTime = 1500 
    "Time instant of step start";
  parameter Boolean BOP.CS.booleanStep.startValue = false "Output before startTime";
  parameter Modelica.Units.SI.Time BOP.CS.booleanStep1.startTime = 1200 
    "Time instant of step start";
  parameter Boolean BOP.CS.booleanStep1.startValue = false "Output before startTime";
  parameter Modelica.Units.SI.Time BOP.CS.booleanStep2.startTime = 2000 
    "Time instant of step start";
  parameter Boolean BOP.CS.booleanStep2.startValue = false "Output before startTime";
  parameter Real BOP.CS.ext_pos_start.height = 0 "Height of ramps";
  parameter Modelica.Units.SI.Time BOP.CS.ext_pos_start.duration(start = 2, 
    min = 0.0) = 1000 "Duration of ramp (= 0.0 gives a Step)";
  parameter Real BOP.CS.ext_pos_start.offset = 0 "Offset of output signal y";
  parameter Modelica.Units.SI.Time BOP.CS.ext_pos_start.startTime = 2000 
    "Output y = offset for time < startTime";
  parameter NHES.Systems.BalanceOfPlant.RankineCycle.Data.BOP_Type 
    BOP.data.FH_type = NHES.Systems.BalanceOfPlant.RankineCycle.Data.BOP_Type.
    OFWH "Type of Feed Heating";
  parameter Modelica.Units.SI.Pressure BOP.data.HPT_p_in = data.HPT_p_in 
    "High Pressure Turbine Inlet Pressure";
  parameter Modelica.Units.SI.Pressure BOP.data.p_dump = data.p_dump 
    "Overpressure Set Pressure  ";
  parameter Modelica.Units.SI.Power BOP.data.Power_nom = data.Power_nom 
    "Electrical Power Nominal";
  parameter Modelica.Units.SI.Pressure BOP.data.p_i1 = data.p_i1 
    "Set Pressure Between High Pressure Turbine and Low Pressure Turbine 1";
  parameter Modelica.Units.SI.Pressure BOP.data.p_i2 = data.p_i2 
    "Set Pressure Between Low Pressure Turbine 1 and Low Pressure Turbine 2";
  parameter Modelica.Units.SI.Pressure BOP.data.cond_p = data.cond_p 
    "Condenser Pressure";
  parameter Modelica.Units.SI.Temperature BOP.data.Tin = data.Tin 
    "Inlet Steam Temperature";
  parameter Modelica.Units.SI.Temperature BOP.data.Tfeed = data.Tfeed 
    "Target Feed Water Temperature";
  parameter Modelica.Units.SI.Density BOP.data.d_HPT_in(displayUnit = "kg/m3")
     = data.d_HPT_in "HPT inlet density";
  parameter Modelica.Units.SI.Density BOP.data.d_LPT1_in = data.d_LPT1_in 
    "LPT1 inlet density";
  parameter Modelica.Units.SI.Density BOP.data.d_LPT2_in(displayUnit = "kg/m3")
     = data.d_LPT2_in "LPT2 inlet density";
  parameter Modelica.Units.SI.Pressure BOP.data.HPT_p_out = BOP.data.p_i1;
  parameter Modelica.Units.SI.Pressure BOP.data.LPT1_p_in = BOP.data.p_i1;
  parameter Modelica.Units.SI.Pressure BOP.data.LPT1_p_out = BOP.data.p_i2;
  parameter Modelica.Units.SI.Pressure BOP.data.LPT2_p_in = BOP.data.p_i2;
  parameter Modelica.Units.SI.Pressure BOP.data.LPT2_p_out = BOP.data.cond_p;
  parameter Modelica.Units.SI.MassFlowRate BOP.data.mdot_total = data.mdot_total
     "Nominal Total Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate BOP.data.mdot_fh = data.mdot_fh 
    "Nominal Controlled Feed Heating Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate BOP.data.mdpt_HPFH = data.mdpt_HPFH 
    "Set High pressure feedwater heating flow (used in models with both LP and HP feed heating";
  parameter Modelica.Units.SI.MassFlowRate BOP.data.mdot_hpt = data.mdot_hpt 
    "Nominal Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate BOP.data.mdot_lpt1 = data.mdot_lpt1 
    "Nominal Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate BOP.data.mdot_lpt2 = data.mdot_lpt2 
    "Nominal Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate BOP.data.m_ext = data.m_ext;
  parameter Modelica.Units.SI.AbsolutePressure BOP.data.p_use = 100000.0;
  parameter Real BOP.data.eta_t = data.eta_t "Isentropic Efficiency of the Turbines";
  parameter Real BOP.data.eta_mech = data.eta_mech "Mechincal Effieiency of the Turbines";
  parameter Real BOP.data.eta_p = data.eta_p "Isentropic Efficiency of the Pumps";
  parameter Real BOP.data.BypassFeedHeater_NTU = 20 "NTU of bypass feedwater heater";
  parameter Real BOP.data.BypassFeedHeater_K_tube(unit = "1/m4") = 17000 
    "K value of tube in bypass feedwater heater";
  parameter Real BOP.data.BypassFeedHeater_K_shell(unit = "1/m4") = 500 
    "K value of shell in bypass feedwater heater";
  parameter Modelica.Units.SI.Volume BOP.data.BypassFeedHeater_V_tube = 5 
    "Tube side volume in bypass feedwater heater";
  parameter Modelica.Units.SI.Volume BOP.data.BypassFeedHeater_V_shell = 5 
    "Shell side volume in bypass feedwater heater";
  parameter Modelica.Units.SI.Volume BOP.data.V_condensor_liquid_start = 1.2 
    "Condensor volume";
  parameter Modelica.Units.SI.Pressure BOP.data.BypassFeedHeater_tube_p_start = 
    5500000.0 "Initial Tube pressure of bypass feedwater heater";
  parameter Modelica.Units.SI.Pressure BOP.data.BypassFeedHeater_shell_p_start
     = 1000000.0 "Initial Shell pressure of bypass feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy BOP.data.BypassFeedHeater_h_start_tube_inlet
     = 1000000.0 "Initial Tube inlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy BOP.data.BypassFeedHeater_h_start_tube_outlet
     = 1050000.0 "Initial Tube outlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy BOP.data.BypassFeedHeater_h_start_shell_inlet
     = 3000000.0 "Initial Shell inlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy BOP.data.BypassFeedHeater_h_start_shell_outlet
     = 2900000.0 "Initial Shell outlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.Temperature BOP.data.BypassFeedHeater_tube_T_start_inlet
     = 318 "Initial Tube inlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Temperature BOP.data.BypassFeedHeater_tube_T_start_outlet
     = 473 "Initial Tube outlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Temperature BOP.data.BypassFeedHeater_shell_T_start_inlet
     = 643 "Initial Tube inlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Temperature BOP.data.BypassFeedHeater_shell_T_start_outlet
     = 523 "Initial Tube outlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Pressure BOP.data.BypassFeedHeater_dp_init_tube = 0
     "Initial Tube pressure drop of bypass feedwater heater";
  parameter Modelica.Units.SI.Pressure BOP.data.BypassFeedHeater_dp_init_shell
     = 100000 "Initial Shell pressure drop of bypass feedwater heater";
  parameter Modelica.Units.SI.MassFlowRate BOP.data.BypassFeedHeater_m_start_tube
     = 72 "Initial tube mass flow rate in bypass feedwater heater";
  parameter Modelica.Units.SI.MassFlowRate BOP.data.BypassFeedHeater_m_start_shell
     = 10 "Initial shell mass flow rate in main feedwater heater";
  parameter Modelica.Units.SI.Power BOP.data.BypassFeedHeater_Q_init = 1000000.0
     "Initial Heat Flow in main feedwater heater";
  parameter Modelica.Units.SI.AbsolutePressure BOP.HPT.system.p_ambient = 101325
     "Default ambient pressure";
  parameter Modelica.Units.SI.Temperature BOP.HPT.system.T_ambient = 293.15 
    "Default ambient temperature";
  parameter Modelica.Units.SI.Acceleration BOP.HPT.system.g = 9.80665 
    "Constant gravity acceleration";
  constant Boolean BOP.HPT.system.allowFlowReversal = true "= false to restrict to design flow direction (port_a -> port_b)";
  parameter Modelica.Fluid.Types.Dynamics BOP.HPT.system.energyDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.HPT.system.massDynamics = 
    BOP.HPT.system.energyDynamics "Default formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.HPT.system.substanceDynamics = 
    BOP.HPT.system.massDynamics "Default formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.HPT.system.traceDynamics = 
    BOP.HPT.system.massDynamics "Default formulation of trace substance balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.HPT.system.momentumDynamics = 
    Modelica.Fluid.Types.Dynamics.SteadyState "Default formulation of momentum balances, if options available";
  parameter Modelica.Units.SI.MassFlowRate BOP.HPT.system.m_flow_start = 0 
    "Default start value for mass flow rates";
  parameter Modelica.Units.SI.AbsolutePressure BOP.HPT.system.p_start = 
    BOP.HPT.system.p_ambient "Default start value for pressures";
  parameter Modelica.Units.SI.Temperature BOP.HPT.system.T_start = 
    BOP.HPT.system.T_ambient "Default start value for temperatures";
  parameter Boolean BOP.HPT.system.use_eps_Re = false "= true to determine turbulent region automatically using Reynolds number";
  parameter Modelica.Units.SI.MassFlowRate BOP.HPT.system.m_flow_nominal = (if 
    BOP.HPT.system.use_eps_Re then 1 else 100.0*BOP.HPT.system.m_flow_small) 
    "Default nominal mass flow rate";
  parameter Real BOP.HPT.system.eps_m_flow(min = 0.0) = 0.0001 "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal";
  parameter Modelica.Units.SI.AbsolutePressure BOP.HPT.system.dp_small = 1 
    "Default small pressure drop for regularization of laminar and zero flow";
  parameter Modelica.Units.SI.MassFlowRate BOP.HPT.system.m_flow_small(min = 0.0)
     = 0.01 "Default small mass flow rate for regularization of laminar and zero flow";
  constant Boolean BOP.HPT.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction";
  parameter Integer BOP.HPT.nUnits = 1 "Number of turbine units, e.g., high pressure and low pressure";
  parameter TRANSFORM.Types.Dynamics BOP.HPT.energyDynamics = TRANSFORM.Types.Dynamics.
    SteadyState "=true to use turbine dynamics";
  parameter Modelica.Units.SI.Time BOP.HPT.taus[BOP.HPT.nUnits] = fill(1, 
    BOP.HPT.nUnits) "Characteristic time constant of each unit";
  parameter TRANSFORM.Units.NonDim BOP.HPT.Q_fracs[BOP.HPT.nUnits] = fill(1/
    BOP.HPT.nUnits, BOP.HPT.nUnits) "Fraction of power provided per unit";
  parameter Modelica.Units.SI.Power BOP.HPT.Q_units_start[BOP.HPT.nUnits] = fill
    (BOP.HPT.m_flow_start*(BOP.HPT.h_a_start-BOP.HPT.h_b_start)/BOP.HPT.nUnits, 
    BOP.HPT.nUnits) "Initial power output per unit";
  parameter Real BOP.HPT.eta_mech = BOP.data.eta_mech "Mechanical efficiency";
  parameter Modelica.Units.SI.Efficiency BOP.HPT.eta_wetSteam.eta_nominal = 
    BOP.data.eta_t "Nominal efficiency due to wetness";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure BOP.HPT.p_a_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = BOP.data.HPT_p_in 
    "Pressure at port a";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure BOP.HPT.p_b_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = BOP.data.HPT_p_out 
    "Pressure at port b";
  parameter Boolean BOP.HPT.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Media.Interfaces.Types.Temperature BOP.HPT.T_a_start(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = BOP.data.Tin 
    "Temperature at port a";
  parameter Modelica.Media.Interfaces.Types.Temperature BOP.HPT.T_b_start(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = 452.55 
    "Temperature at port b";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.HPT.h_a_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11
    (BOP.HPT.p_a_start, BOP.HPT.T_a_start, BOP.HPT.X_start, 0) "Specific enthalpy at port a";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.HPT.h_b_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.isentropicEnthalpy_Unique17
    (
    BOP.HPT.p_b_start, 
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(BOP.HPT.p_a_start, 
      BOP.HPT.h_a_start, BOP.HPT.X_start, 0, 0)) "Specific enthalpy at port b";
  parameter Modelica.Media.Interfaces.Types.MassFraction BOP.HPT.X_start[1] = {
    1.0} "Mass fractions m_i/m";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty BOP.HPT.C_start[0](
    start = fill(1.0, size(BOP.HPT.C_start, 1))) = fill(0, 0) "Trace substances";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.HPT.m_flow_start = BOP.data.mdot_hpt "Mass flow rate";
  constant Modelica.Units.SI.Pressure BOP.HPT.p_crit = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
    .criticalPressure "Medium critical pressure";
  parameter Real BOP.HPT.partialArc_nominal = 1 "Nominal partial arc";
  parameter Modelica.Units.SI.MassFlowRate BOP.HPT.m_flow_nominal = 
    BOP.data.mdot_hpt "Nominal mass flowrate";
  parameter Boolean BOP.HPT.use_Stodola = true "=true to use Stodola's law, i.e., infinite stages per unit";
  parameter Modelica.Units.SI.Area BOP.HPT.Kt_constant = 0.01 "Constant coefficient of Stodola's law";
  parameter Boolean BOP.HPT.use_NominalInlet = true "=true then Kt is calculated from nominal inlet conditions";
  parameter Modelica.Units.SI.Pressure BOP.HPT.p_inlet_nominal = 
    BOP.data.HPT_p_in "Nominal inlet pressure";
  parameter Modelica.Units.SI.Pressure BOP.HPT.p_outlet_nominal = 
    BOP.data.HPT_p_out "Nominal outlet pressure";
  parameter Boolean BOP.HPT.use_T_nominal = false "=true then use temperature for Kt else density";
  parameter Modelica.Units.SI.Temperature BOP.HPT.T_nominal = BOP.data.Tin 
    "Nominal inlet temperature";
  parameter Modelica.Units.SI.Density BOP.HPT.d_nominal = BOP.data.d_HPT_in 
    "Nominal inlet density";
  parameter Modelica.Units.SI.Area BOP.HPT.Kt(fixed = false) "Flow area coefficient";
  parameter Modelica.Units.SI.AbsolutePressure BOP.LPT1.system.p_ambient = 101325
     "Default ambient pressure";
  parameter Modelica.Units.SI.Temperature BOP.LPT1.system.T_ambient = 293.15 
    "Default ambient temperature";
  parameter Modelica.Units.SI.Acceleration BOP.LPT1.system.g = 9.80665 
    "Constant gravity acceleration";
  constant Boolean BOP.LPT1.system.allowFlowReversal = true "= false to restrict to design flow direction (port_a -> port_b)";
  parameter Modelica.Fluid.Types.Dynamics BOP.LPT1.system.energyDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.LPT1.system.massDynamics = 
    BOP.LPT1.system.energyDynamics "Default formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.LPT1.system.substanceDynamics = 
    BOP.LPT1.system.massDynamics "Default formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.LPT1.system.traceDynamics = 
    BOP.LPT1.system.massDynamics "Default formulation of trace substance balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.LPT1.system.momentumDynamics = 
    Modelica.Fluid.Types.Dynamics.SteadyState "Default formulation of momentum balances, if options available";
  parameter Modelica.Units.SI.MassFlowRate BOP.LPT1.system.m_flow_start = 0 
    "Default start value for mass flow rates";
  parameter Modelica.Units.SI.AbsolutePressure BOP.LPT1.system.p_start = 
    BOP.LPT1.system.p_ambient "Default start value for pressures";
  parameter Modelica.Units.SI.Temperature BOP.LPT1.system.T_start = 
    BOP.LPT1.system.T_ambient "Default start value for temperatures";
  parameter Boolean BOP.LPT1.system.use_eps_Re = false "= true to determine turbulent region automatically using Reynolds number";
  parameter Modelica.Units.SI.MassFlowRate BOP.LPT1.system.m_flow_nominal = (if 
    BOP.LPT1.system.use_eps_Re then 1 else 100.0*BOP.LPT1.system.m_flow_small) 
    "Default nominal mass flow rate";
  parameter Real BOP.LPT1.system.eps_m_flow(min = 0.0) = 0.0001 "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal";
  parameter Modelica.Units.SI.AbsolutePressure BOP.LPT1.system.dp_small = 1 
    "Default small pressure drop for regularization of laminar and zero flow";
  parameter Modelica.Units.SI.MassFlowRate BOP.LPT1.system.m_flow_small(min = 
    0.0) = 0.01 "Default small mass flow rate for regularization of laminar and zero flow";
  constant Boolean BOP.LPT1.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction";
  parameter Integer BOP.LPT1.nUnits = 1 "Number of turbine units, e.g., high pressure and low pressure";
  parameter TRANSFORM.Types.Dynamics BOP.LPT1.energyDynamics = TRANSFORM.Types.Dynamics.
    SteadyState "=true to use turbine dynamics";
  parameter Modelica.Units.SI.Time BOP.LPT1.taus[BOP.LPT1.nUnits] = fill(1, 
    BOP.LPT1.nUnits) "Characteristic time constant of each unit";
  parameter TRANSFORM.Units.NonDim BOP.LPT1.Q_fracs[BOP.LPT1.nUnits] = fill(1/
    BOP.LPT1.nUnits, BOP.LPT1.nUnits) "Fraction of power provided per unit";
  parameter Modelica.Units.SI.Power BOP.LPT1.Q_units_start[BOP.LPT1.nUnits] = 
    fill(BOP.LPT1.m_flow_start*(BOP.LPT1.h_a_start-BOP.LPT1.h_b_start)/
    BOP.LPT1.nUnits, BOP.LPT1.nUnits) "Initial power output per unit";
  parameter Real BOP.LPT1.eta_mech = BOP.data.eta_mech "Mechanical efficiency";
  parameter Modelica.Units.SI.Efficiency BOP.LPT1.eta_wetSteam.eta_nominal = 
    BOP.data.eta_t "Nominal efficiency due to wetness";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1.p_a_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = BOP.data.LPT1_p_in 
    "Pressure at port a";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1.p_b_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = BOP.data.LPT1_p_out
     "Pressure at port b";
  parameter Boolean BOP.LPT1.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Media.Interfaces.Types.Temperature BOP.LPT1.T_a_start(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = 452.55 
    "Temperature at port a";
  parameter Modelica.Media.Interfaces.Types.Temperature BOP.LPT1.T_b_start(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = 433.35 
    "Temperature at port b";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1.h_a_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11
    (BOP.LPT1.p_a_start, BOP.LPT1.T_a_start, BOP.LPT1.X_start, 0) 
    "Specific enthalpy at port a";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1.h_b_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.isentropicEnthalpy_Unique17
    (
    BOP.LPT1.p_b_start, 
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(BOP.LPT1.p_a_start, 
      BOP.LPT1.h_a_start, BOP.LPT1.X_start, 0, 0)) "Specific enthalpy at port b";
  parameter Modelica.Media.Interfaces.Types.MassFraction BOP.LPT1.X_start[1] = {
    1.0} "Mass fractions m_i/m";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty BOP.LPT1.C_start[0](
    start = fill(1.0, size(BOP.LPT1.C_start, 1))) = fill(0, 0) "Trace substances";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.LPT1.m_flow_start = BOP.data.mdot_lpt1 "Mass flow rate";
  constant Modelica.Units.SI.Pressure BOP.LPT1.p_crit = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
    .criticalPressure "Medium critical pressure";
  parameter Real BOP.LPT1.partialArc_nominal = 1 "Nominal partial arc";
  parameter Modelica.Units.SI.MassFlowRate BOP.LPT1.m_flow_nominal = 
    BOP.data.mdot_lpt1 "Nominal mass flowrate";
  parameter Boolean BOP.LPT1.use_Stodola = true "=true to use Stodola's law, i.e., infinite stages per unit";
  parameter Modelica.Units.SI.Area BOP.LPT1.Kt_constant = 0.01 "Constant coefficient of Stodola's law";
  parameter Boolean BOP.LPT1.use_NominalInlet = true "=true then Kt is calculated from nominal inlet conditions";
  parameter Modelica.Units.SI.Pressure BOP.LPT1.p_inlet_nominal = 
    BOP.data.LPT1_p_in "Nominal inlet pressure";
  parameter Modelica.Units.SI.Pressure BOP.LPT1.p_outlet_nominal = 
    BOP.data.LPT1_p_out "Nominal outlet pressure";
  parameter Boolean BOP.LPT1.use_T_nominal = false "=true then use temperature for Kt else density";
  parameter Modelica.Units.SI.Temperature BOP.LPT1.T_nominal = BOP.LPT1.T_a_start
     "Nominal inlet temperature";
  parameter Modelica.Units.SI.Density BOP.LPT1.d_nominal = BOP.data.d_LPT1_in 
    "Nominal inlet density";
  parameter Modelica.Units.SI.Area BOP.LPT1.Kt(fixed = false) "Flow area coefficient";
  parameter Modelica.Units.SI.AbsolutePressure BOP.LPT2.system.p_ambient = 101325
     "Default ambient pressure";
  parameter Modelica.Units.SI.Temperature BOP.LPT2.system.T_ambient = 293.15 
    "Default ambient temperature";
  parameter Modelica.Units.SI.Acceleration BOP.LPT2.system.g = 9.80665 
    "Constant gravity acceleration";
  constant Boolean BOP.LPT2.system.allowFlowReversal = true "= false to restrict to design flow direction (port_a -> port_b)";
  parameter Modelica.Fluid.Types.Dynamics BOP.LPT2.system.energyDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.LPT2.system.massDynamics = 
    BOP.LPT2.system.energyDynamics "Default formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.LPT2.system.substanceDynamics = 
    BOP.LPT2.system.massDynamics "Default formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.LPT2.system.traceDynamics = 
    BOP.LPT2.system.massDynamics "Default formulation of trace substance balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.LPT2.system.momentumDynamics = 
    Modelica.Fluid.Types.Dynamics.SteadyState "Default formulation of momentum balances, if options available";
  parameter Modelica.Units.SI.MassFlowRate BOP.LPT2.system.m_flow_start = 0 
    "Default start value for mass flow rates";
  parameter Modelica.Units.SI.AbsolutePressure BOP.LPT2.system.p_start = 
    BOP.LPT2.system.p_ambient "Default start value for pressures";
  parameter Modelica.Units.SI.Temperature BOP.LPT2.system.T_start = 
    BOP.LPT2.system.T_ambient "Default start value for temperatures";
  parameter Boolean BOP.LPT2.system.use_eps_Re = false "= true to determine turbulent region automatically using Reynolds number";
  parameter Modelica.Units.SI.MassFlowRate BOP.LPT2.system.m_flow_nominal = (if 
    BOP.LPT2.system.use_eps_Re then 1 else 100.0*BOP.LPT2.system.m_flow_small) 
    "Default nominal mass flow rate";
  parameter Real BOP.LPT2.system.eps_m_flow(min = 0.0) = 0.0001 "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal";
  parameter Modelica.Units.SI.AbsolutePressure BOP.LPT2.system.dp_small = 1 
    "Default small pressure drop for regularization of laminar and zero flow";
  parameter Modelica.Units.SI.MassFlowRate BOP.LPT2.system.m_flow_small(min = 
    0.0) = 0.01 "Default small mass flow rate for regularization of laminar and zero flow";
  constant Boolean BOP.LPT2.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction";
  parameter Integer BOP.LPT2.nUnits = 1 "Number of turbine units, e.g., high pressure and low pressure";
  parameter TRANSFORM.Types.Dynamics BOP.LPT2.energyDynamics = TRANSFORM.Types.Dynamics.
    SteadyState "=true to use turbine dynamics";
  parameter Modelica.Units.SI.Time BOP.LPT2.taus[BOP.LPT2.nUnits] = fill(1, 
    BOP.LPT2.nUnits) "Characteristic time constant of each unit";
  parameter TRANSFORM.Units.NonDim BOP.LPT2.Q_fracs[BOP.LPT2.nUnits] = fill(1/
    BOP.LPT2.nUnits, BOP.LPT2.nUnits) "Fraction of power provided per unit";
  parameter Modelica.Units.SI.Power BOP.LPT2.Q_units_start[BOP.LPT2.nUnits] = 
    fill(BOP.LPT2.m_flow_start*(BOP.LPT2.h_a_start-BOP.LPT2.h_b_start)/
    BOP.LPT2.nUnits, BOP.LPT2.nUnits) "Initial power output per unit";
  parameter Real BOP.LPT2.eta_mech = BOP.data.eta_mech "Mechanical efficiency";
  parameter Modelica.Units.SI.Efficiency BOP.LPT2.eta_wetSteam.eta_nominal = 
    BOP.data.eta_t "Nominal efficiency due to wetness";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT2.p_a_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = BOP.data.LPT2_p_in 
    "Pressure at port a";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT2.p_b_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = BOP.data.LPT2_p_out
     "Pressure at port b";
  parameter Boolean BOP.LPT2.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Media.Interfaces.Types.Temperature BOP.LPT2.T_a_start(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = 433.35 
    "Temperature at port a";
  parameter Modelica.Media.Interfaces.Types.Temperature BOP.LPT2.T_b_start(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = 321.27 
    "Temperature at port b";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT2.h_a_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11
    (BOP.LPT2.p_a_start, BOP.LPT2.T_a_start, BOP.LPT2.X_start, 0) 
    "Specific enthalpy at port a";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT2.h_b_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.isentropicEnthalpy_Unique17
    (
    BOP.LPT2.p_b_start, 
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(BOP.LPT2.p_a_start, 
      BOP.LPT2.h_a_start, BOP.LPT2.X_start, 0, 0)) "Specific enthalpy at port b";
  parameter Modelica.Media.Interfaces.Types.MassFraction BOP.LPT2.X_start[1] = {
    1.0} "Mass fractions m_i/m";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty BOP.LPT2.C_start[0](
    start = fill(1.0, size(BOP.LPT2.C_start, 1))) = fill(0, 0) "Trace substances";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.LPT2.m_flow_start = BOP.data.mdot_lpt2 "Mass flow rate";
  constant Modelica.Units.SI.Pressure BOP.LPT2.p_crit = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
    .criticalPressure "Medium critical pressure";
  parameter Real BOP.LPT2.partialArc_nominal = 1 "Nominal partial arc";
  parameter Modelica.Units.SI.MassFlowRate BOP.LPT2.m_flow_nominal = 
    BOP.data.mdot_lpt2 "Nominal mass flowrate";
  parameter Boolean BOP.LPT2.use_Stodola = true "=true to use Stodola's law, i.e., infinite stages per unit";
  parameter Modelica.Units.SI.Area BOP.LPT2.Kt_constant = 0.01 "Constant coefficient of Stodola's law";
  parameter Boolean BOP.LPT2.use_NominalInlet = true "=true then Kt is calculated from nominal inlet conditions";
  parameter Modelica.Units.SI.Pressure BOP.LPT2.p_inlet_nominal = 
    BOP.data.LPT2_p_in "Nominal inlet pressure";
  parameter Modelica.Units.SI.Pressure BOP.LPT2.p_outlet_nominal = 
    BOP.data.LPT2_p_out "Nominal outlet pressure";
  parameter Boolean BOP.LPT2.use_T_nominal = false "=true then use temperature for Kt else density";
  parameter Modelica.Units.SI.Temperature BOP.LPT2.T_nominal = 384.45 
    "Nominal inlet temperature";
  parameter Modelica.Units.SI.Density BOP.LPT2.d_nominal = BOP.data.d_LPT2_in 
    "Nominal inlet density";
  parameter Modelica.Units.SI.Area BOP.LPT2.Kt(fixed = false) "Flow area coefficient";
  constant Integer BOP.moistureSeperator.nPorts_a = 1 "Number of port_a connections";
  constant Integer BOP.moistureSeperator.nPorts_b = 1 "Number of port_b connections";
  parameter Modelica.Fluid.Types.Dynamics BOP.moistureSeperator.energyDynamics
     = Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.moistureSeperator.massDynamics = 
    BOP.moistureSeperator.energyDynamics "Formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.moistureSeperator.substanceDynamics
     = BOP.moistureSeperator.massDynamics "Formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.moistureSeperator.traceDynamics = 
    BOP.moistureSeperator.massDynamics "Formulation of trace substance balances";
  parameter Modelica.Units.SI.AbsolutePressure BOP.moistureSeperator.p_start = 150000
     "Pressure";
  parameter Boolean BOP.moistureSeperator.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Units.SI.Temperature BOP.moistureSeperator.T_start = 384.15
     "Temperature";
  parameter Modelica.Units.SI.SpecificEnthalpy BOP.moistureSeperator.h_start = 
    Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11(
    BOP.moistureSeperator.p_start, BOP.moistureSeperator.T_start, 
    BOP.moistureSeperator.X_start, 0) "Specific enthalpy";
  parameter Modelica.Units.SI.MassFraction BOP.moistureSeperator.X_start[1] = {
    1.0} "Mass fraction";
  parameter TRANSFORM.Units.ExtraProperty BOP.moistureSeperator.C_start[0] = 
    fill(0, 0) "Mass-Specific value";
  constant Boolean BOP.moistureSeperator.medium.preferredMediumStates = true 
    "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean BOP.moistureSeperator.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  parameter Boolean BOP.moistureSeperator.initialize_p = true "= true to set up initial equations for pressure";
  constant Boolean BOP.moistureSeperator.use_HeatPort = false "=true to toggle heat port";
  constant Boolean BOP.moistureSeperator.use_TraceMassPort = false 
    "=true to toggle trace mass port";
  parameter Real BOP.moistureSeperator.MMs[0] = fill(1, 0) "Conversion from fluid mass-specific value to moles (e.g., molar mass [kg/mol] or Avogadro's number [atoms/mol])";
  parameter Boolean BOP.moistureSeperator.showName = true;
  parameter Boolean BOP.moistureSeperator.portMixed = false "=true to assume entering and exit streams mix before entering the volume";
  parameter Modelica.Fluid.Types.Dynamics BOP.LPT1_bypass.energyDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.LPT1_bypass.massDynamics = 
    BOP.LPT1_bypass.energyDynamics "Formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.LPT1_bypass.substanceDynamics = 
    BOP.LPT1_bypass.massDynamics "Formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.LPT1_bypass.traceDynamics = 
    BOP.LPT1_bypass.massDynamics "Formulation of trace substance balances";
  parameter Modelica.Units.SI.AbsolutePressure BOP.LPT1_bypass.p_start = 
    BOP.data.HPT_p_out "Pressure";
  parameter Boolean BOP.LPT1_bypass.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Units.SI.Temperature BOP.LPT1_bypass.T_start = 452.55 
    "Temperature";
  parameter Modelica.Units.SI.SpecificEnthalpy BOP.LPT1_bypass.h_start = 
    Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11(
    BOP.LPT1_bypass.p_start, BOP.LPT1_bypass.T_start, BOP.LPT1_bypass.X_start, 0)
     "Specific enthalpy";
  parameter Modelica.Units.SI.MassFraction BOP.LPT1_bypass.X_start[1] = {1.0} 
    "Mass fraction";
  parameter TRANSFORM.Units.ExtraProperty BOP.LPT1_bypass.C_start[0] = fill(0, 0)
     "Mass-Specific value";
  constant Boolean BOP.LPT1_bypass.medium.preferredMediumStates = true 
    "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean BOP.LPT1_bypass.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  parameter Boolean BOP.LPT1_bypass.initialize_p = true "= true to set up initial equations for pressure";
  constant Boolean BOP.LPT1_bypass_valve.allowFlowReversal = true 
    "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean BOP.LPT1_bypass_valve.showDesignFlowDirection = true 
    "= false to hide the flow direction arrow";
  parameter Boolean BOP.LPT1_bypass_valve.showName = true "= false to hide component name";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1_bypass_valve.dp_start
    (start = 5000000.0, nominal = 1000000.0, min = -1E+60) = 1E-05 
    "Guess value of dp = port_a.p - port_b.p";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.LPT1_bypass_valve.m_flow_start = 0 "Guess value of m_flow = port_a.m_flow";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.LPT1_bypass_valve.m_flow_small = 0.01 "Small mass flow rate for regularization of zero flow";
  constant Boolean BOP.LPT1_bypass_valve.show_T = true "= true, if temperatures at port_a and port_b are computed";
  constant Boolean BOP.LPT1_bypass_valve.show_V_flow = true "= true, if volume flow rate at inflowing port is computed";
  parameter Modelica.Units.SI.AbsolutePressure BOP.LPT1_bypass_valve.dp_nominal(
    displayUnit = "Pa") = 1 "Nominal pressure drop at full opening";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.LPT1_bypass_valve.m_flow_nominal = 10*m_ext "Nominal mass flowrate at full opening";
  parameter Modelica.Fluid.Types.HydraulicConductance BOP.LPT1_bypass_valve.k = 
    BOP.LPT1_bypass_valve.m_flow_nominal/BOP.LPT1_bypass_valve.dp_nominal 
    "Hydraulic conductance at full opening";
  constant Boolean BOP.TBV.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean BOP.TBV.showDesignFlowDirection = true "= false to hide the flow direction arrow";
  parameter Boolean BOP.TBV.showName = true "= false to hide component name";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure BOP.TBV.dp_start(
    start = 5000000.0, nominal = 1000000.0, min = -1E+60) = 1E-05 
    "Guess value of dp = port_a.p - port_b.p";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.TBV.m_flow_start = 0 "Guess value of m_flow = port_a.m_flow";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.TBV.m_flow_small = 0.01 "Small mass flow rate for regularization of zero flow";
  constant Boolean BOP.TBV.show_T = true "= true, if temperatures at port_a and port_b are computed";
  constant Boolean BOP.TBV.show_V_flow = true "= true, if volume flow rate at inflowing port is computed";
  parameter Modelica.Units.SI.AbsolutePressure BOP.TBV.dp_nominal = 200000 
    "Nominal pressure drop at full opening";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.TBV.m_flow_nominal = 0 "Nominal mass flowrate at full opening";
  parameter Modelica.Fluid.Types.HydraulicConductance BOP.TBV.k = 
    BOP.TBV.m_flow_nominal/BOP.TBV.dp_nominal "Hydraulic conductance at full opening";
  parameter Boolean BOP.condenser.showName = true;
  parameter Modelica.Units.SI.AbsolutePressure BOP.condenser.system.p_ambient = 101325
     "Default ambient pressure";
  parameter Modelica.Units.SI.Temperature BOP.condenser.system.T_ambient = 
    293.15 "Default ambient temperature";
  parameter Modelica.Units.SI.Acceleration BOP.condenser.system.g = 9.80665 
    "Constant gravity acceleration";
  parameter Boolean BOP.condenser.system.allowFlowReversal = true 
    "= false to restrict to design flow direction (port_a -> port_b)";
  parameter Modelica.Fluid.Types.Dynamics BOP.condenser.system.energyDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.condenser.system.massDynamics = 
    BOP.condenser.system.energyDynamics "Default formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.condenser.system.substanceDynamics
     = BOP.condenser.system.massDynamics "Default formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.condenser.system.traceDynamics = 
    BOP.condenser.system.massDynamics "Default formulation of trace substance balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.condenser.system.momentumDynamics
     = Modelica.Fluid.Types.Dynamics.SteadyState "Default formulation of momentum balances, if options available";
  parameter Modelica.Units.SI.MassFlowRate BOP.condenser.system.m_flow_start = 0
     "Default start value for mass flow rates";
  parameter Modelica.Units.SI.AbsolutePressure BOP.condenser.system.p_start = 
    BOP.condenser.system.p_ambient "Default start value for pressures";
  parameter Modelica.Units.SI.Temperature BOP.condenser.system.T_start = 
    BOP.condenser.system.T_ambient "Default start value for temperatures";
  parameter Boolean BOP.condenser.system.use_eps_Re = false "= true to determine turbulent region automatically using Reynolds number";
  parameter Modelica.Units.SI.MassFlowRate BOP.condenser.system.m_flow_nominal
     = (if BOP.condenser.system.use_eps_Re then 1 else 100.0*BOP.condenser.system.m_flow_small)
     "Default nominal mass flow rate";
  parameter Real BOP.condenser.system.eps_m_flow(min = 0.0) = 0.0001 
    "Regularization of zero flow for |m_flow| < eps_m_flow*m_flow_nominal";
  parameter Modelica.Units.SI.AbsolutePressure BOP.condenser.system.dp_small = 1
     "Default small pressure drop for regularization of laminar and zero flow";
  parameter Modelica.Units.SI.MassFlowRate BOP.condenser.system.m_flow_small(
    min = 0.0) = 0.01 "Default small mass flow rate for regularization of laminar and zero flow";
  parameter Modelica.Units.SI.Pressure BOP.condenser.p = BOP.data.cond_p 
    "Condenser operating pressure";
  parameter Modelica.Units.SI.Volume BOP.condenser.V_total = 3500.0 
    "Total volume (liquid + vapor)";
  parameter Modelica.Fluid.Types.Dynamics BOP.condenser.massDynamics = 
    BOP.condenser.system.massDynamics "Formulation of mass balance";
  parameter Modelica.Units.SI.Volume BOP.condenser.V_liquid_start = 0.15*
    BOP.condenser.V_total "Start value of the liquid volume";
  parameter Boolean BOP.condenser.set_m_flow = false "=true to set port_b.m_flow = -port_a.m_flow";
  parameter Modelica.Units.SI.Efficiency BOP.generator.eta = 1.0 
    "Mechanical to electric power conversion efficiency";
  parameter Modelica.Units.SI.MomentOfInertia BOP.generator.J = 0 
    "Moment of inertia";
  parameter Integer BOP.generator.nPoles = 2 "Number of electrical poles";
  parameter Modelica.Units.SI.Frequency BOP.generator.f_start = 60 
    "Start value of the electrical frequency";
  parameter Modelica.Fluid.Types.Dynamics BOP.generator.momentumDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Default formulation of momentum balances";
  parameter Real BOP.pump.nParallel = 1 "# of parallel components";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure BOP.pump.p_a_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = 101325 
    "Pressure at port a";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure BOP.pump.p_b_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = BOP.pump.p_a_start 
    "Pressure at port b";
  parameter Boolean BOP.pump.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Media.Interfaces.Types.Temperature BOP.pump.T_a_start(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = 293.15 
    "Temperature at port a";
  parameter Modelica.Media.Interfaces.Types.Temperature BOP.pump.T_b_start(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = 
    BOP.pump.T_a_start "Temperature at port b";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.pump.h_a_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11
    (BOP.pump.p_a_start, BOP.pump.T_a_start, BOP.pump.X_start, 0) 
    "Specific enthalpy at port a";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.pump.h_b_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.isentropicEnthalpy_Unique17
    (
    BOP.pump.p_b_start, 
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(BOP.pump.p_a_start, 
      BOP.pump.h_a_start, BOP.pump.X_start, 0, 0)) "Specific enthalpy at port b";
  parameter Modelica.Media.Interfaces.Types.MassFraction BOP.pump.X_start[1] = {
    1.0} "Mass fractions m_i/m";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty BOP.pump.C_start[0](
    start = fill(1.0, size(BOP.pump.C_start, 1))) = fill(0, 0) "Trace substances";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.pump.m_flow_start = 0 "Mass flow rate";
  constant Boolean BOP.pump.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  constant Boolean BOP.pump.use_input = false "Use connector input for outlet pressure";
  parameter Modelica.Units.SI.Pressure BOP.pump.p_nominal = BOP.data.p_i2 
    "Nominal outlet pressure (port_b.p)";
  parameter Real BOP.pump.eta = BOP.data.eta_p "Thermodynamic Efficiency of the pump";
  parameter Real BOP.pump1.nParallel = 1 "# of parallel components";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure BOP.pump1.p_a_start
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) = 101325 
    "Pressure at port a";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure BOP.pump1.p_b_start
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) = BOP.pump1.p_a_start
     "Pressure at port b";
  parameter Boolean BOP.pump1.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Media.Interfaces.Types.Temperature BOP.pump1.T_a_start(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = 293.15 
    "Temperature at port a";
  parameter Modelica.Media.Interfaces.Types.Temperature BOP.pump1.T_b_start(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = 
    BOP.pump1.T_a_start "Temperature at port b";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.pump1.h_a_start
    (start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11
    (BOP.pump1.p_a_start, BOP.pump1.T_a_start, BOP.pump1.X_start, 0) 
    "Specific enthalpy at port a";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.pump1.h_b_start
    (start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.isentropicEnthalpy_Unique17
    (
    BOP.pump1.p_b_start, 
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(BOP.pump1.p_a_start,
       BOP.pump1.h_a_start, BOP.pump1.X_start, 0, 0)) "Specific enthalpy at port b";
  parameter Modelica.Media.Interfaces.Types.MassFraction BOP.pump1.X_start[1] = 
    {1.0} "Mass fractions m_i/m";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty BOP.pump1.C_start[0](
    start = fill(1.0, size(BOP.pump1.C_start, 1))) = fill(0, 0) "Trace substances";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.pump1.m_flow_start = 0 "Mass flow rate";
  constant Boolean BOP.pump1.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  constant Boolean BOP.pump1.use_input = false "Use connector input for outlet pressure";
  parameter Modelica.Units.SI.Pressure BOP.pump1.p_nominal = 2800000 
    "Nominal outlet pressure (port_b.p)";
  parameter Real BOP.pump1.eta = BOP.data.eta_p "Thermodynamic Efficiency of the pump";
  parameter Modelica.Fluid.Types.Dynamics BOP.OFWH_1.energyDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.OFWH_1.massDynamics = 
    BOP.OFWH_1.energyDynamics "Formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.OFWH_1.substanceDynamics = 
    BOP.OFWH_1.massDynamics "Formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.OFWH_1.traceDynamics = 
    BOP.OFWH_1.massDynamics "Formulation of trace substance balances";
  parameter Modelica.Units.SI.AbsolutePressure BOP.OFWH_1.p_start = 
    BOP.data.LPT2_p_in "Pressure";
  parameter Boolean BOP.OFWH_1.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Units.SI.Temperature BOP.OFWH_1.T_start = 333.15 
    "Temperature";
  parameter Modelica.Units.SI.SpecificEnthalpy BOP.OFWH_1.h_start = 
    Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11(
    BOP.OFWH_1.p_start, BOP.OFWH_1.T_start, BOP.OFWH_1.X_start, 0) 
    "Specific enthalpy";
  parameter Modelica.Units.SI.MassFraction BOP.OFWH_1.X_start[1] = {1.0} 
    "Mass fraction";
  parameter TRANSFORM.Units.ExtraProperty BOP.OFWH_1.C_start[0] = fill(0, 0) 
    "Mass-Specific value";
  constant Boolean BOP.OFWH_1.medium.preferredMediumStates = true 
    "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean BOP.OFWH_1.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  parameter Boolean BOP.OFWH_1.initialize_p = true "= true to set up initial equations for pressure";
  constant Boolean BOP.OFWH_1.use_HeatPort = false "=true to toggle heat port";
  constant Boolean BOP.OFWH_1.use_TraceMassPort = false "=true to toggle trace mass port";
  parameter Real BOP.OFWH_1.MMs[0] = fill(1, 0) "Conversion from fluid mass-specific value to moles (e.g., molar mass [kg/mol] or Avogadro's number [atoms/mol])";
  parameter Boolean BOP.OFWH_1.showName = true;
  constant Boolean BOP.HPT_bypass_valve.allowFlowReversal = true 
    "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean BOP.HPT_bypass_valve.showDesignFlowDirection = true 
    "= false to hide the flow direction arrow";
  parameter Boolean BOP.HPT_bypass_valve.showName = true "= false to hide component name";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure BOP.HPT_bypass_valve.dp_start
    (start = 5000000.0, nominal = 1000000.0, min = -1E+60) = 1E-05 
    "Guess value of dp = port_a.p - port_b.p";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.HPT_bypass_valve.m_flow_start = BOP.data.mdot_fh "Guess value of m_flow = port_a.m_flow";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.HPT_bypass_valve.m_flow_small = 0.01 "Small mass flow rate for regularization of zero flow";
  constant Boolean BOP.HPT_bypass_valve.show_T = true "= true, if temperatures at port_a and port_b are computed";
  constant Boolean BOP.HPT_bypass_valve.show_V_flow = true "= true, if volume flow rate at inflowing port is computed";
  parameter Modelica.Units.SI.AbsolutePressure BOP.HPT_bypass_valve.dp_nominal
     = 30000 "Nominal pressure drop at full opening";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.HPT_bypass_valve.m_flow_nominal = 500 "Nominal mass flowrate at full opening";
  parameter Modelica.Fluid.Types.HydraulicConductance BOP.HPT_bypass_valve.k = 
    BOP.HPT_bypass_valve.m_flow_nominal/BOP.HPT_bypass_valve.dp_nominal 
    "Hydraulic conductance at full opening";
  parameter Modelica.Fluid.Types.Dynamics BOP.OFWH_2.energyDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.OFWH_2.massDynamics = 
    BOP.OFWH_2.energyDynamics "Formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.OFWH_2.substanceDynamics = 
    BOP.OFWH_2.massDynamics "Formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics BOP.OFWH_2.traceDynamics = 
    BOP.OFWH_2.massDynamics "Formulation of trace substance balances";
  parameter Modelica.Units.SI.AbsolutePressure BOP.OFWH_2.p_start = 
    BOP.data.HPT_p_in-50000.0 "Pressure";
  parameter Boolean BOP.OFWH_2.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Units.SI.Temperature BOP.OFWH_2.T_start = 353.15 
    "Temperature";
  parameter Modelica.Units.SI.SpecificEnthalpy BOP.OFWH_2.h_start = 
    Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11(
    BOP.OFWH_2.p_start, BOP.OFWH_2.T_start, BOP.OFWH_2.X_start, 0) 
    "Specific enthalpy";
  parameter Modelica.Units.SI.MassFraction BOP.OFWH_2.X_start[1] = {1.0} 
    "Mass fraction";
  parameter TRANSFORM.Units.ExtraProperty BOP.OFWH_2.C_start[0] = fill(0, 0) 
    "Mass-Specific value";
  constant Boolean BOP.OFWH_2.medium.preferredMediumStates = true 
    "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean BOP.OFWH_2.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  parameter Boolean BOP.OFWH_2.initialize_p = true "= true to set up initial equations for pressure";
  constant Boolean BOP.OFWH_2.use_HeatPort = false "=true to toggle heat port";
  constant Boolean BOP.OFWH_2.use_TraceMassPort = false "=true to toggle trace mass port";
  parameter Real BOP.OFWH_2.MMs[0] = fill(1, 0) "Conversion from fluid mass-specific value to moles (e.g., molar mass [kg/mol] or Avogadro's number [atoms/mol])";
  parameter Boolean BOP.OFWH_2.showName = true;
  parameter Real BOP.FWCP.nParallel = 1 "# of parallel components";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure BOP.FWCP.p_a_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = 101325 
    "Pressure at port a";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure BOP.FWCP.p_b_start(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = BOP.FWCP.p_a_start 
    "Pressure at port b";
  parameter Boolean BOP.FWCP.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Media.Interfaces.Types.Temperature BOP.FWCP.T_a_start(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = 293.15 
    "Temperature at port a";
  parameter Modelica.Media.Interfaces.Types.Temperature BOP.FWCP.T_b_start(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = 
    BOP.FWCP.T_a_start "Temperature at port b";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.FWCP.h_a_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11
    (BOP.FWCP.p_a_start, BOP.FWCP.T_a_start, BOP.FWCP.X_start, 0) 
    "Specific enthalpy at port a";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.FWCP.h_b_start(
    start = 100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.isentropicEnthalpy_Unique17
    (
    BOP.FWCP.p_b_start, 
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(BOP.FWCP.p_a_start, 
      BOP.FWCP.h_a_start, BOP.FWCP.X_start, 0, 0)) "Specific enthalpy at port b";
  parameter Modelica.Media.Interfaces.Types.MassFraction BOP.FWCP.X_start[1] = {
    1.0} "Mass fractions m_i/m";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty BOP.FWCP.C_start[0](
    start = fill(1.0, size(BOP.FWCP.C_start, 1))) = fill(0, 0) "Trace substances";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.FWCP.m_flow_start = 0 "Mass flow rate";
  constant Boolean BOP.FWCP.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  constant Boolean BOP.FWCP.use_input = false "Use connector input for the mass flow";
  parameter Modelica.Units.SI.MassFlowRate BOP.FWCP.m_flow_nominal = 
    data.mdot_total "Nominal mass flowrate";
  parameter Real BOP.FWCP.eta = BOP.data.eta_p "Thermodynamic Efficiency of the pump";
  constant Boolean BOP.TCV.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean BOP.TCV.showDesignFlowDirection = true "= false to hide the flow direction arrow";
  parameter Boolean BOP.TCV.showName = true "= false to hide component name";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure BOP.TCV.dp_start(
    start = 5000000.0, nominal = 1000000.0, min = -1E+60) = 1E-05 
    "Guess value of dp = port_a.p - port_b.p";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.TCV.m_flow_start = BOP.data.mdot_total "Guess value of m_flow = port_a.m_flow";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.TCV.m_flow_small = 0.01 "Small mass flow rate for regularization of zero flow";
  constant Boolean BOP.TCV.show_T = true "= true, if temperatures at port_a and port_b are computed";
  constant Boolean BOP.TCV.show_V_flow = true "= true, if volume flow rate at inflowing port is computed";
  parameter Modelica.Units.SI.AbsolutePressure BOP.TCV.dp_nominal = 1 
    "Nominal pressure drop at full opening";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.TCV.m_flow_nominal = BOP.data.mdot_total "Nominal mass flowrate at full opening";
  parameter Modelica.Fluid.Types.HydraulicConductance BOP.TCV.k = 
    BOP.TCV.m_flow_nominal/BOP.TCV.dp_nominal "Hydraulic conductance at full opening";
  constant Boolean BOP.Feed_T.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean BOP.Feed_T.showName = true "= false to hide component name";
  parameter Integer BOP.Feed_T.precision(min = 0.0) = 0 "Number of decimals displayed";
  constant Boolean BOP.Steam_T.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean BOP.Steam_T.showName = true "= false to hide component name";
  parameter Integer BOP.Steam_T.precision(min = 0.0) = 0 "Number of decimals displayed";
  constant Boolean BOP.sensor_p.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean BOP.sensor_p.showName = true "= false to hide component name";
  parameter Integer BOP.sensor_p.precision(min = 0.0) = 0 "Number of decimals displayed";
  parameter Integer BOP.sensorW.precision(min = 0.0) = 0 "Number of decimals displayed";
  constant Boolean BOP.delay2.sensor_p.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean BOP.delay2.sensor_p.showName = true "= false to hide component name";
  parameter Integer BOP.delay2.sensor_p.precision(min = 0.0) = 0 
    "Number of decimals displayed";
  constant Boolean BOP.delay2.sensor_m_flow.allowFlowReversal = true 
    "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean BOP.delay2.sensor_m_flow.showName = true "= false to hide component name";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.delay2.sensor_m_flow.m_flow_small(min = 0.0) = 0.0001 "Regularization for zero flow:|m_flow| < m_flow_small";
  parameter Modelica.Units.SI.AbsolutePressure BOP.delay2.sensor_m_flow.p_start
     = 101325 "Pressure";
  parameter Boolean BOP.delay2.sensor_m_flow.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Units.SI.Temperature BOP.delay2.sensor_m_flow.T_start = 
    293.15 "Temperature";
  parameter Modelica.Units.SI.SpecificEnthalpy BOP.delay2.sensor_m_flow.h_start
     = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11(
    BOP.delay2.sensor_m_flow.p_start, BOP.delay2.sensor_m_flow.T_start, 
    BOP.delay2.sensor_m_flow.X_start, 0) "Specific enthalpy";
  parameter Modelica.Units.SI.MassFraction BOP.delay2.sensor_m_flow.X_start[1]
     = {1.0} "Mass fraction";
  parameter Integer BOP.delay2.sensor_m_flow.precision(min = 0.0) = 0 
    "Number of decimals displayed";
  constant Boolean BOP.delay2.sensor_h.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean BOP.delay2.sensor_h.showName = true "= false to hide component name";
  parameter Integer BOP.delay2.sensor_h.precision(min = 0.0) = 0 
    "Number of decimals displayed";
  parameter Boolean BOP.delay2.boundary.showName = true;
  constant Integer BOP.delay2.boundary.nPorts = 1 "Number of ports";
  constant Boolean BOP.delay2.boundary.medium.preferredMediumStates = false 
    "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean BOP.delay2.boundary.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  constant Modelica.Fluid.Types.PortFlowDirection BOP.delay2.boundary.flowDirection
     = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction";
  constant Boolean BOP.delay2.boundary.use_p_in = true "Get the pressure from the input connector";
  constant Boolean BOP.delay2.boundary.use_h_in = false "Get the specific enthalpy from the input connector";
  constant Boolean BOP.delay2.boundary.use_X_in = false "Get the composition from the input connector";
  constant Boolean BOP.delay2.boundary.use_C_in = false "Get the trace substances from the input connector";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2.boundary.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) = 101325 
    "Fixed value of pressure";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2.boundary.h
    (start = 100000.0, nominal = 500000.0) = 84013.0581525969 "Fixed value of specific enthalpy";
  parameter Modelica.Media.Interfaces.Types.MassFraction BOP.delay2.boundary.X[1]
     = {1.0} "Fixed value of composition";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2.boundary.C[0]
    (start = fill(1.0, size(BOP.delay2.boundary.C, 1))) = fill(0, 0) 
    "Fixed values of trace substances";
  parameter Boolean BOP.delay2.boundary1.showName = true;
  constant Integer BOP.delay2.boundary1.nPorts = 1 "Number of ports";
  constant Boolean BOP.delay2.boundary1.medium.preferredMediumStates = false 
    "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean BOP.delay2.boundary1.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  constant Modelica.Fluid.Types.PortFlowDirection BOP.delay2.boundary1.flowDirection
     = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction";
  constant Boolean BOP.delay2.boundary1.use_m_flow_in = true "Get the mass flow rate from the input connector";
  constant Boolean BOP.delay2.boundary1.use_h_in = true "Get the specific enthalpy from the input connector";
  constant Boolean BOP.delay2.boundary1.use_X_in = false "Get the composition from the input connector";
  constant Boolean BOP.delay2.boundary1.use_C_in = false "Get the trace substances from the input connector";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.delay2.boundary1.m_flow = 0 "Fixed mass flow rate going out of the fluid port";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2.boundary1.h
    (start = 100000.0, nominal = 500000.0) = 84013.0581525969 "Fixed value of specific enthalpy";
  parameter Modelica.Media.Interfaces.Types.MassFraction BOP.delay2.boundary1.X[1]
     = {1.0} "Fixed value of composition";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2.boundary1.C
    [0](start = fill(1.0, size(BOP.delay2.boundary1.C, 1))) = fill(0, 0) 
    "Fixed values of trace substances";
  parameter Real BOP.delay2.limiter1.uMax(start = 1) = 1E+60 "Upper limits of input signals";
  parameter Real BOP.delay2.limiter1.uMin =  -BOP.delay2.limiter1.uMax 
    "Lower limits of input signals";
  parameter Boolean BOP.delay2.limiter1.strict = false "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy BOP.delay2.limiter1.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Real BOP.delay2.limiter2.uMax(start = 1) = 1E+60 "Upper limits of input signals";
  parameter Real BOP.delay2.limiter2.uMin =  -BOP.delay2.limiter2.uMax 
    "Lower limits of input signals";
  parameter Boolean BOP.delay2.limiter2.strict = false "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy BOP.delay2.limiter2.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Real BOP.delay2.limiter.uMax(start = 1) = 1E+60 "Upper limits of input signals";
  parameter Real BOP.delay2.limiter.uMin =  -BOP.delay2.limiter.uMax 
    "Lower limits of input signals";
  parameter Boolean BOP.delay2.limiter.strict = false "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy BOP.delay2.limiter.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  constant Boolean BOP.delay2_2.sensor_p.allowFlowReversal = true 
    "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean BOP.delay2_2.sensor_p.showName = true "= false to hide component name";
  parameter Integer BOP.delay2_2.sensor_p.precision(min = 0.0) = 0 
    "Number of decimals displayed";
  constant Boolean BOP.delay2_2.sensor_m_flow.allowFlowReversal = true 
    "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean BOP.delay2_2.sensor_m_flow.showName = true "= false to hide component name";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.delay2_2.sensor_m_flow.m_flow_small(min = 0.0) = 0.0001 "Regularization for zero flow:|m_flow| < m_flow_small";
  parameter Modelica.Units.SI.AbsolutePressure BOP.delay2_2.sensor_m_flow.p_start
     = 101325 "Pressure";
  parameter Boolean BOP.delay2_2.sensor_m_flow.use_T_start = true 
    "Use T_start if true, otherwise h_start";
  parameter Modelica.Units.SI.Temperature BOP.delay2_2.sensor_m_flow.T_start = 
    293.15 "Temperature";
  parameter Modelica.Units.SI.SpecificEnthalpy BOP.delay2_2.sensor_m_flow.h_start
     = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11(
    BOP.delay2_2.sensor_m_flow.p_start, BOP.delay2_2.sensor_m_flow.T_start, 
    BOP.delay2_2.sensor_m_flow.X_start, 0) "Specific enthalpy";
  parameter Modelica.Units.SI.MassFraction BOP.delay2_2.sensor_m_flow.X_start[1]
     = {1.0} "Mass fraction";
  parameter Integer BOP.delay2_2.sensor_m_flow.precision(min = 0.0) = 0 
    "Number of decimals displayed";
  constant Boolean BOP.delay2_2.sensor_h.allowFlowReversal = true 
    "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean BOP.delay2_2.sensor_h.showName = true "= false to hide component name";
  parameter Integer BOP.delay2_2.sensor_h.precision(min = 0.0) = 0 
    "Number of decimals displayed";
  parameter Boolean BOP.delay2_2.boundary.showName = true;
  constant Integer BOP.delay2_2.boundary.nPorts = 1 "Number of ports";
  constant Boolean BOP.delay2_2.boundary.medium.preferredMediumStates = false 
    "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean BOP.delay2_2.boundary.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  constant Modelica.Fluid.Types.PortFlowDirection BOP.delay2_2.boundary.flowDirection
     = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction";
  constant Boolean BOP.delay2_2.boundary.use_p_in = true "Get the pressure from the input connector";
  constant Boolean BOP.delay2_2.boundary.use_h_in = false "Get the specific enthalpy from the input connector";
  constant Boolean BOP.delay2_2.boundary.use_X_in = false "Get the composition from the input connector";
  constant Boolean BOP.delay2_2.boundary.use_C_in = false "Get the trace substances from the input connector";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2_2.boundary.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) = 101325 
    "Fixed value of pressure";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2_2.boundary.h
    (start = 100000.0, nominal = 500000.0) = 84013.0581525969 "Fixed value of specific enthalpy";
  parameter Modelica.Media.Interfaces.Types.MassFraction BOP.delay2_2.boundary.X
    [1] = {1.0} "Fixed value of composition";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2_2.boundary.C
    [0](start = fill(1.0, size(BOP.delay2_2.boundary.C, 1))) = fill(0, 0) 
    "Fixed values of trace substances";
  parameter Boolean BOP.delay2_2.boundary1.showName = true;
  constant Integer BOP.delay2_2.boundary1.nPorts = 1 "Number of ports";
  constant Boolean BOP.delay2_2.boundary1.medium.preferredMediumStates = false 
    "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean BOP.delay2_2.boundary1.medium.standardOrderComponents = true
     "If true, and reducedX = true, the last element of X will be computed from the other ones";
  constant Modelica.Fluid.Types.PortFlowDirection BOP.delay2_2.boundary1.flowDirection
     = Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction";
  constant Boolean BOP.delay2_2.boundary1.use_m_flow_in = true "Get the mass flow rate from the input connector";
  constant Boolean BOP.delay2_2.boundary1.use_h_in = true "Get the specific enthalpy from the input connector";
  constant Boolean BOP.delay2_2.boundary1.use_X_in = false "Get the composition from the input connector";
  constant Boolean BOP.delay2_2.boundary1.use_C_in = false "Get the trace substances from the input connector";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.delay2_2.boundary1.m_flow = 0 "Fixed mass flow rate going out of the fluid port";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2_2.boundary1.h
    (start = 100000.0, nominal = 500000.0) = 84013.0581525969 "Fixed value of specific enthalpy";
  parameter Modelica.Media.Interfaces.Types.MassFraction BOP.delay2_2.boundary1.X
    [1] = {1.0} "Fixed value of composition";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2_2.boundary1.C
    [0](start = fill(1.0, size(BOP.delay2_2.boundary1.C, 1))) = fill(0, 0) 
    "Fixed values of trace substances";
  parameter Real BOP.delay2_2.limiter1.uMax(start = 1) = 1E+60 "Upper limits of input signals";
  parameter Real BOP.delay2_2.limiter1.uMin =  -BOP.delay2_2.limiter1.uMax 
    "Lower limits of input signals";
  parameter Boolean BOP.delay2_2.limiter1.strict = false "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy BOP.delay2_2.limiter1.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Real BOP.delay2_2.limiter2.uMax(start = 1) = 1E+60 "Upper limits of input signals";
  parameter Real BOP.delay2_2.limiter2.uMin =  -BOP.delay2_2.limiter2.uMax 
    "Lower limits of input signals";
  parameter Boolean BOP.delay2_2.limiter2.strict = false "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy BOP.delay2_2.limiter2.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Real BOP.delay2_2.limiter.uMax(start = 1) = 1E+60 "Upper limits of input signals";
  parameter Real BOP.delay2_2.limiter.uMin =  -BOP.delay2_2.limiter.uMax 
    "Lower limits of input signals";
  parameter Boolean BOP.delay2_2.limiter.strict = false "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy BOP.delay2_2.limiter.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  constant Boolean BOP.sensor_m_flow.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean BOP.sensor_m_flow.showName = true "= false to hide component name";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    BOP.sensor_m_flow.m_flow_small(min = 0.0) = 0.0001 "Regularization for zero flow:|m_flow| < m_flow_small";
  parameter Modelica.Units.SI.AbsolutePressure BOP.sensor_m_flow.p_start = 101325
     "Pressure";
  parameter Boolean BOP.sensor_m_flow.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Units.SI.Temperature BOP.sensor_m_flow.T_start = 293.15 
    "Temperature";
  parameter Modelica.Units.SI.SpecificEnthalpy BOP.sensor_m_flow.h_start = 
    Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11(
    BOP.sensor_m_flow.p_start, BOP.sensor_m_flow.T_start, BOP.sensor_m_flow.X_start,
     0) "Specific enthalpy";
  parameter Modelica.Units.SI.MassFraction BOP.sensor_m_flow.X_start[1] = {1.0} 
    "Mass fraction";
  parameter Integer BOP.sensor_m_flow.precision(min = 0.0) = 0 "Number of decimals displayed";
  parameter Modelica.Units.SI.Time BOP.booleanStep1.startTime = 2000 
    "Time instant of step start";
  parameter Boolean BOP.booleanStep1.startValue = true "Output before startTime";
  parameter Boolean bypassdump.showName = true;
  constant Integer bypassdump.nPorts = 1 "Number of ports";
  constant Boolean bypassdump.medium.preferredMediumStates = false 
    "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean bypassdump.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  constant Modelica.Fluid.Types.PortFlowDirection bypassdump.flowDirection = 
    Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction";
  constant Boolean bypassdump.use_p_in = true "Get the pressure from the input connector";
  constant Boolean bypassdump.use_T_in = false "Get the temperature from the input connector";
  constant Boolean bypassdump.use_X_in = false "Get the composition from the input connector";
  constant Boolean bypassdump.use_C_in = false "Get the trace substances from the input connector";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure bypassdump.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = 101325 
    "Fixed value of pressure";
  parameter Modelica.Media.Interfaces.Types.Temperature bypassdump.T(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) = 293.15 "Fixed value of temperature";
  parameter Modelica.Media.Interfaces.Types.MassFraction bypassdump.X[1] = {1.0}
     "Fixed value of composition";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty bypassdump.C[0](
    start = fill(1.0, size(bypassdump.C, 1))) = fill(0, 0) "Fixed values of trace substances";
  parameter Boolean steamdump.showName = true;
  constant Integer steamdump.nPorts = 1 "Number of ports";
  constant Boolean steamdump.medium.preferredMediumStates = false 
    "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean steamdump.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  constant Modelica.Fluid.Types.PortFlowDirection steamdump.flowDirection = 
    Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction";
  constant Boolean steamdump.use_p_in = false "Get the pressure from the input connector";
  constant Boolean steamdump.use_T_in = false "Get the temperature from the input connector";
  constant Boolean steamdump.use_X_in = false "Get the composition from the input connector";
  constant Boolean steamdump.use_C_in = false "Get the trace substances from the input connector";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure steamdump.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = 1000000 
    "Fixed value of pressure";
  parameter Modelica.Media.Interfaces.Types.Temperature steamdump.T(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) = 293.15 "Fixed value of temperature";
  parameter Modelica.Media.Interfaces.Types.MassFraction steamdump.X[1] = {1.0} 
    "Fixed value of composition";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty steamdump.C[0](
    start = fill(1.0, size(steamdump.C, 1))) = fill(0, 0) "Fixed values of trace substances";
  constant Boolean boundary.use_port = false "= true to use input signal";
  parameter Modelica.Units.SI.Frequency boundary.f = 60 "Frequency";
  parameter NHES.Systems.BalanceOfPlant.RankineCycle.Data.BOP_Type data.FH_type
     = NHES.Systems.BalanceOfPlant.RankineCycle.Data.BOP_Type.OFWH 
    "Type of Feed Heating";
  parameter Modelica.Units.SI.Pressure data.HPT_p_in = 6190000 "High Pressure Turbine Inlet Pressure";
  parameter Modelica.Units.SI.Pressure data.p_dump = 15500000 "Overpressure Set Pressure  ";
  parameter Modelica.Units.SI.Power data.Power_nom = 3651000000.0 
    "Electrical Power Nominal";
  parameter Modelica.Units.SI.Pressure data.p_i1 = 3000000 "Set Pressure Between High Pressure Turbine and Low Pressure Turbine 1";
  parameter Modelica.Units.SI.Pressure data.p_i2 = 1210000 "Set Pressure Between Low Pressure Turbine 1 and Low Pressure Turbine 2";
  parameter Modelica.Units.SI.Pressure data.cond_p = 10000.0 "Condenser Pressure";
  parameter Modelica.Units.SI.Temperature data.Tin = 550.15 "Inlet Steam Temperature";
  parameter Modelica.Units.SI.Temperature data.Tfeed = 500.15 "Target Feed Water Temperature";
  parameter Modelica.Units.SI.Density data.d_HPT_in(displayUnit = "kg/m3") = 
    31.80297734 "HPT inlet density";
  parameter Modelica.Units.SI.Density data.d_LPT1_in(displayUnit = "kg/m3") = 
    16.26108896 "LPT1 inlet density";
  parameter Modelica.Units.SI.Density data.d_LPT2_in(displayUnit = "kg/m3") = 
    6.174594994 "LPT2 inlet density";
  parameter Modelica.Units.SI.Pressure data.HPT_p_out = data.p_i1;
  parameter Modelica.Units.SI.Pressure data.LPT1_p_in = data.p_i1;
  parameter Modelica.Units.SI.Pressure data.LPT1_p_out = data.p_i2;
  parameter Modelica.Units.SI.Pressure data.LPT2_p_in = data.p_i2;
  parameter Modelica.Units.SI.Pressure data.LPT2_p_out = data.cond_p;
  parameter Modelica.Units.SI.MassFlowRate data.mdot_total = 2019.662582 
    "Nominal Total Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate data.mdot_fh = 544.6001198 
    "Nominal Controlled Feed Heating Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate data.mdpt_HPFH = 280 "Set High pressure feedwater heating flow (used in models with both LP and HP feed heating";
  parameter Modelica.Units.SI.MassFlowRate data.mdot_hpt = 2019.662582 
    "Nominal Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate data.mdot_lpt1 = 1475.062462 
    "Nominal Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate data.mdot_lpt2 = 1276.797982 
    "Nominal Mass Flow Rate";
  parameter Modelica.Units.SI.MassFlowRate data.m_ext = m_ext;
  parameter Modelica.Units.SI.AbsolutePressure data.p_use = 100000.0;
  parameter Real data.eta_t = 0.9 "Isentropic Efficiency of the Turbines";
  parameter Real data.eta_mech = 1 "Mechincal Effieiency of the Turbines";
  parameter Real data.eta_p = 0.8 "Isentropic Efficiency of the Pumps";
  parameter Real data.BypassFeedHeater_NTU = 20 "NTU of bypass feedwater heater";
  parameter Real data.BypassFeedHeater_K_tube(unit = "1/m4") = 17000 
    "K value of tube in bypass feedwater heater";
  parameter Real data.BypassFeedHeater_K_shell(unit = "1/m4") = 500 
    "K value of shell in bypass feedwater heater";
  parameter Modelica.Units.SI.Volume data.BypassFeedHeater_V_tube = 5 
    "Tube side volume in bypass feedwater heater";
  parameter Modelica.Units.SI.Volume data.BypassFeedHeater_V_shell = 5 
    "Shell side volume in bypass feedwater heater";
  parameter Modelica.Units.SI.Volume data.V_condensor_liquid_start = 1.2 
    "Condensor volume";
  parameter Modelica.Units.SI.Pressure data.BypassFeedHeater_tube_p_start = 
    5500000.0 "Initial Tube pressure of bypass feedwater heater";
  parameter Modelica.Units.SI.Pressure data.BypassFeedHeater_shell_p_start = 
    1000000.0 "Initial Shell pressure of bypass feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy data.BypassFeedHeater_h_start_tube_inlet
     = 1000000.0 "Initial Tube inlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy data.BypassFeedHeater_h_start_tube_outlet
     = 1050000.0 "Initial Tube outlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy data.BypassFeedHeater_h_start_shell_inlet
     = 3000000.0 "Initial Shell inlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.SpecificEnthalpy data.BypassFeedHeater_h_start_shell_outlet
     = 2900000.0 "Initial Shell outlet specific enthalpy of main feedwater heater";
  parameter Modelica.Units.SI.Temperature data.BypassFeedHeater_tube_T_start_inlet
     = 318 "Initial Tube inlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Temperature data.BypassFeedHeater_tube_T_start_outlet
     = 473 "Initial Tube outlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Temperature data.BypassFeedHeater_shell_T_start_inlet
     = 643 "Initial Tube inlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Temperature data.BypassFeedHeater_shell_T_start_outlet
     = 523 "Initial Tube outlet temperature of bypass feedwater heater";
  parameter Modelica.Units.SI.Pressure data.BypassFeedHeater_dp_init_tube = 0 
    "Initial Tube pressure drop of bypass feedwater heater";
  parameter Modelica.Units.SI.Pressure data.BypassFeedHeater_dp_init_shell = 100000
     "Initial Shell pressure drop of bypass feedwater heater";
  parameter Modelica.Units.SI.MassFlowRate data.BypassFeedHeater_m_start_tube = 72
     "Initial tube mass flow rate in bypass feedwater heater";
  parameter Modelica.Units.SI.MassFlowRate data.BypassFeedHeater_m_start_shell
     = 10 "Initial shell mass flow rate in main feedwater heater";
  parameter Modelica.Units.SI.Power data.BypassFeedHeater_Q_init = 1000000.0 
    "Initial Heat Flow in main feedwater heater";
  parameter Boolean bypassdump1.showName = true;
  constant Integer bypassdump1.nPorts = 1 "Number of ports";
  constant Boolean bypassdump1.medium.preferredMediumStates = false 
    "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean bypassdump1.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  constant Modelica.Fluid.Types.PortFlowDirection bypassdump1.flowDirection = 
    Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction";
  constant Boolean bypassdump1.use_m_flow_in = true "Get the mass flow rate from the input connector";
  constant Boolean bypassdump1.use_h_in = false "Get the specific enthalpy from the input connector";
  constant Boolean bypassdump1.use_X_in = false "Get the composition from the input connector";
  constant Boolean bypassdump1.use_C_in = false "Get the trace substances from the input connector";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    bypassdump1.m_flow = 4 "Fixed mass flow rate going out of the fluid port";
  parameter Modelica.Media.Interfaces.Types.SpecificEnthalpy bypassdump1.h(
    start = 100000.0, nominal = 500000.0) = 192000.0 "Fixed value of specific enthalpy";
  parameter Modelica.Media.Interfaces.Types.MassFraction bypassdump1.X[1] = {1.0}
     "Fixed value of composition";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty bypassdump1.C[0](
    start = fill(1.0, size(bypassdump1.C, 1))) = fill(0, 0) "Fixed values of trace substances";
  constant Boolean sensor_m_flow.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean sensor_m_flow.showName = true "= false to hide component name";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    sensor_m_flow.m_flow_small(min = 0.0) = 0.0001 "Regularization for zero flow:|m_flow| < m_flow_small";
  parameter Modelica.Units.SI.AbsolutePressure sensor_m_flow.p_start = 101325 
    "Pressure";
  parameter Boolean sensor_m_flow.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Units.SI.Temperature sensor_m_flow.T_start = 293.15 
    "Temperature";
  parameter Modelica.Units.SI.SpecificEnthalpy sensor_m_flow.h_start = 
    Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11(
    sensor_m_flow.p_start, sensor_m_flow.T_start, sensor_m_flow.X_start, 0) 
    "Specific enthalpy";
  parameter Modelica.Units.SI.MassFraction sensor_m_flow.X_start[1] = {1.0} 
    "Mass fraction";
  parameter Integer sensor_m_flow.precision(min = 0.0) = 0 "Number of decimals displayed";
  parameter Real integrator.k(unit = "1") = 1 "Integrator gain";
  constant Boolean integrator.use_reset = false "= true, if reset port enabled";
  constant Boolean integrator.use_set = false "= true, if set port enabled and used as reinitialization value when reset";
  parameter Modelica.Blocks.Types.Init integrator.initType = Modelica.Blocks.Types.Init.
    InitialState "Type of initialization (1: no init, 2: steady state, 3,4: initial output)";
  parameter Real integrator.y_start = 0 "Initial or guess value of output (= state)";
  parameter Modelica.Fluid.Types.Dynamics volume.energyDynamics = 
    Modelica.Fluid.Types.Dynamics.DynamicFreeInitial "Formulation of energy balances";
  parameter Modelica.Fluid.Types.Dynamics volume.massDynamics = volume.energyDynamics
     "Formulation of mass balances";
  parameter Modelica.Fluid.Types.Dynamics volume.substanceDynamics = 
    volume.massDynamics "Formulation of substance balances";
  parameter Modelica.Fluid.Types.Dynamics volume.traceDynamics = 
    volume.massDynamics "Formulation of trace substance balances";
  parameter Modelica.Units.SI.AbsolutePressure volume.p_start = 7340000 
    "Pressure";
  parameter Boolean volume.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Units.SI.Temperature volume.T_start = 565.15 "Temperature";
  parameter Modelica.Units.SI.SpecificEnthalpy volume.h_start = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11
    (volume.p_start, volume.T_start, volume.X_start, 0) "Specific enthalpy";
  parameter Modelica.Units.SI.MassFraction volume.X_start[1] = {1.0} 
    "Mass fraction";
  parameter TRANSFORM.Units.ExtraProperty volume.C_start[0] = fill(0, 0) 
    "Mass-Specific value";
  constant Boolean volume.medium.preferredMediumStates = true "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean volume.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  parameter Boolean volume.initialize_p = true "= true to set up initial equations for pressure";
  constant Boolean volume.use_HeatPort = true "=true to toggle heat port";
  constant Boolean volume.use_TraceMassPort = false "=true to toggle trace mass port";
  parameter Real volume.MMs[0] = fill(1, 0) "Conversion from fluid mass-specific value to moles (e.g., molar mass [kg/mol] or Avogadro's number [atoms/mol])";
  parameter Boolean volume.showName = true;
  parameter Boolean resistance.showName = true;
  parameter Boolean resistance.showDP = true;
  parameter Integer resistance.precision(min = 0.0) = 3 "Number of decimals displayed";
  constant Boolean boundary1.use_port = false "=true then use input port";
  parameter Modelica.Units.SI.HeatFlowRate boundary1.Q_flow = 3651000000.0 
    "Heat flow rate at port";
  parameter Boolean boundary1.showName = true;
  constant Boolean flowCV.Use_input = false "Constant output value";
  parameter Modelica.Units.SI.MassFlowRate flowCV.FlowRate_target = 400 
    "Target Mass Flow Rate";
  parameter Modelica.Blocks.Interfaces.RealOutput flowCV.ValvePos_start = 0.1 
    "Initail Valve Position";
  parameter Modelica.Units.SI.Time flowCV.init_time = 0 "Time instant of step start";
  parameter Real flowCV.PID_k = 0.01 "Controller gain: +/- for direct/reverse acting";
  parameter Modelica.Units.SI.Time flowCV.PID_Ti = 0.5 "Time constant of Integrator block";
  parameter Real flowCV.PID_wp = 1 "Set-point weight for Proportional block (0..1)";
  parameter Real flowCV.PID_Ni = 0.9 "Ni*Ti is time constant of anti-windup compensation";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    flowCV.m_flow_nominal = flowCV.FlowRate_target "Nominal mass flowrate at full opening";
  parameter Modelica.Units.SI.AbsolutePressure flowCV.dp_nominal = 100000.0 
    "Nominal pressure drop at full opening";
  constant Boolean flowCV.valveLinear.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean flowCV.valveLinear.showDesignFlowDirection = true 
    "= false to hide the flow direction arrow";
  parameter Boolean flowCV.valveLinear.showName = true "= false to hide component name";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure flowCV.valveLinear.dp_start
    (start = 5000000.0, nominal = 1000000.0, min = -1E+60) = 1E-05 
    "Guess value of dp = port_a.p - port_b.p";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    flowCV.valveLinear.m_flow_start = 0 "Guess value of m_flow = port_a.m_flow";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    flowCV.valveLinear.m_flow_small = 0.01 "Small mass flow rate for regularization of zero flow";
  constant Boolean flowCV.valveLinear.show_T = true "= true, if temperatures at port_a and port_b are computed";
  constant Boolean flowCV.valveLinear.show_V_flow = true "= true, if volume flow rate at inflowing port is computed";
  parameter Modelica.Units.SI.AbsolutePressure flowCV.valveLinear.dp_nominal = 
    flowCV.dp_nominal "Nominal pressure drop at full opening";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    flowCV.valveLinear.m_flow_nominal = flowCV.m_flow_nominal "Nominal mass flowrate at full opening";
  parameter Modelica.Fluid.Types.HydraulicConductance flowCV.valveLinear.k = 
    flowCV.valveLinear.m_flow_nominal/flowCV.valveLinear.dp_nominal 
    "Hydraulic conductance at full opening";
  constant Boolean flowCV.sensor_m_flow.allowFlowReversal = true 
    "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean flowCV.sensor_m_flow.showName = true "= false to hide component name";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    flowCV.sensor_m_flow.m_flow_small(min = 0.0) = 0.0001 "Regularization for zero flow:|m_flow| < m_flow_small";
  parameter Modelica.Units.SI.AbsolutePressure flowCV.sensor_m_flow.p_start = 101325
     "Pressure";
  parameter Boolean flowCV.sensor_m_flow.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Units.SI.Temperature flowCV.sensor_m_flow.T_start = 293.15 
    "Temperature";
  parameter Modelica.Units.SI.SpecificEnthalpy flowCV.sensor_m_flow.h_start = 
    Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11(
    flowCV.sensor_m_flow.p_start, flowCV.sensor_m_flow.T_start, flowCV.sensor_m_flow.X_start,
     0) "Specific enthalpy";
  parameter Modelica.Units.SI.MassFraction flowCV.sensor_m_flow.X_start[1] = {
    1.0} "Mass fraction";
  parameter Integer flowCV.sensor_m_flow.precision(min = 0.0) = 0 
    "Number of decimals displayed";
  constant Modelica.Blocks.Types.SimpleController flowCV.PID.controllerType = 
    Modelica.Blocks.Types.SimpleController.PI "Type of controller";
  constant Boolean flowCV.PID.with_FF = false "enable feed-forward input signal";
  parameter Boolean flowCV.PID.derMeas = true "=true avoid derivative kick";
  parameter Real flowCV.PID.k = flowCV.PID_k "Controller gain: +/- for direct/reverse acting";
  parameter Modelica.Units.SI.Time flowCV.PID.Ti(min = 1E-60) = flowCV.PID_Ti 
    "Time constant of Integrator block";
  parameter Modelica.Units.SI.Time flowCV.PID.Td(min = 0.0) = 0.1 
    "Time constant of Derivative block";
  parameter Real flowCV.PID.yb = 0 "Output bias. May improve simulation";
  parameter Real flowCV.PID.k_s = 1 "Setpoint input scaling: k_s*u_s. May improve simulation";
  parameter Real flowCV.PID.k_m = 1 "Measurement input scaling: k_m*u_m. May improve simulation";
  parameter Real flowCV.PID.k_ff = 1 "Measurement input scaling: k_ff*u_ff. May improve simulation";
  parameter Real flowCV.PID.yMax(start = 1) = 1 "Upper limit of output";
  parameter Real flowCV.PID.yMin = 0 "Lower limit of output";
  parameter Real flowCV.PID.wp(min = 0.0) = flowCV.PID_wp "Set-point weight for Proportional block (0..1)";
  parameter Real flowCV.PID.wd(min = 0.0) = 0 "Set-point weight for Derivative block (0..1)";
  parameter Real flowCV.PID.Ni(min = 1E-13) = flowCV.PID_Ni "Ni*Ti is time constant of anti-windup compensation";
  parameter Real flowCV.PID.Nd(min = 1E-13) = 10 "The higher Nd, the more ideal the derivative block";
  parameter Modelica.Blocks.Types.Init flowCV.PID.initType = Modelica.Blocks.Types.Init.
    NoInit "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)";
  parameter Real flowCV.PID.xi_start = 0 "Initial or guess value value for integrator output (= integrator state)";
  parameter Real flowCV.PID.xd_start = 0 "Initial or guess value for state of derivative block";
  parameter Real flowCV.PID.y_start = 0 "Initial value of output";
  parameter Boolean flowCV.PID.strict = false "= true, if strict limits with noEvent(..)";
  constant TRANSFORM.Types.Reset flowCV.PID.reset = TRANSFORM.Types.Reset.
    Disabled "Type of controller output reset";
  parameter Real flowCV.PID.y_reset = flowCV.PID.xi_start "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == TRANSFORM.Types.Reset.Parameter";
  parameter Real flowCV.PID.addP.k1 = flowCV.PID.wp "Gain of input signal 1";
  parameter Real flowCV.PID.addP.k2 = -1 "Gain of input signal 2";
  parameter Real flowCV.PID.P.k(start = 1, unit = "1") = 1 "Gain value multiplied with input signal";
  parameter Real flowCV.PID.gainPID.k(start = 1, unit = "1") = flowCV.PID.k 
    "Gain value multiplied with input signal";
  parameter Real flowCV.PID.addPID.k1 = 1 "Gain of input signal 1";
  parameter Real flowCV.PID.addPID.k2 = 1 "Gain of input signal 2";
  parameter Real flowCV.PID.addPID.k3 = 1 "Gain of input signal 3";
  parameter Real flowCV.PID.limiter.uMax(start = 1) = flowCV.PID.yMax-
    flowCV.PID.offset "Upper limits of input signals";
  parameter Real flowCV.PID.limiter.uMin = flowCV.PID.yMin-flowCV.PID.offset 
    "Lower limits of input signals";
  parameter Boolean flowCV.PID.limiter.strict = flowCV.PID.strict 
    "= true, if strict limits with noEvent(..)";
  parameter Modelica.Blocks.Types.LimiterHomotopy flowCV.PID.limiter.homotopyType
     = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization";
  parameter Real flowCV.PID.Fzero.k(start = 1) = 0 "Constant output value";
  parameter Real flowCV.PID.addFF.k1 = 1 "Gain of input signal 1";
  parameter Real flowCV.PID.addFF.k2 = 1 "Gain of input signal 2";
  parameter Real flowCV.PID.addFF.k3 = 1 "Gain of input signal 3";
  parameter Real flowCV.PID.gain_u_s.k(start = 1, unit = "1") = flowCV.PID.k_s 
    "Gain value multiplied with input signal";
  parameter Real flowCV.PID.gain_u_m.k(start = 1, unit = "1") = flowCV.PID.k_m 
    "Gain value multiplied with input signal";
  parameter Real flowCV.PID.null_bias.k(start = 1) = flowCV.PID.yb 
    "Constant output value";
  constant Modelica.Units.SI.Time flowCV.PID.unitTime = 1;
  constant Boolean flowCV.PID.with_I = true;
  constant Boolean flowCV.PID.with_D = false;
  parameter Modelica.Blocks.Interfaces.RealOutput flowCV.PID.offset = 
    flowCV.ValvePos_start "Value of Real output";
  parameter Modelica.Units.SI.Time flowCV.PID.delay_boolean.startTime = 
    flowCV.PID.delayTime "Time instant of step start";
  parameter Boolean flowCV.PID.delay_boolean.startValue = false "Output before startTime";
  parameter Modelica.Units.SI.Time flowCV.PID.delayTime = flowCV.init_time 
    "Time instant of step start";
  parameter Modelica.Blocks.Interfaces.RealOutput flowCV.PID.init_output = 
    flowCV.ValvePos_start "Value of Real output";
  parameter Real flowCV.PID.add_offset.k1 = 1 "Gain of input signal 1";
  parameter Real flowCV.PID.add_offset.k2 = 1 "Gain of input signal 2";
  parameter Real flowCV.PID.I.k(unit = "1") = flowCV.PID.unitTime/flowCV.PID.Ti 
    "Integrator gain";
  parameter Modelica.Blocks.Types.Init flowCV.PID.I.initType = (if 
    flowCV.PID.initType == Modelica.Blocks.Types.Init.SteadyState then 
    Modelica.Blocks.Types.Init.SteadyState else (if flowCV.PID.initType == 
    Modelica.Blocks.Types.Init.InitialState or flowCV.PID.initType == 
    Modelica.Blocks.Types.Init.InitialState then Modelica.Blocks.Types.Init.
    InitialState else Modelica.Blocks.Types.Init.NoInit)) "Type of initialization (1: no init, 2: steady state, 3,4: initial output)";
  parameter Real flowCV.PID.I.y_start = flowCV.PID.xi_start "Initial or guess value of output (= state)";
  constant TRANSFORM.Types.Reset flowCV.PID.I.reset = TRANSFORM.Types.Reset.
    Disabled "Type of integrator reset";
  parameter Real flowCV.PID.I.y_reset = flowCV.PID.y_reset "Value to which integrator is reset, used if reset = TRANSFORM.Types.Reset.Parameter";
  parameter Real flowCV.PID.addI.k1 = 1 "Gain of input signal 1";
  parameter Real flowCV.PID.addI.k2 = -1 "Gain of input signal 2";
  parameter Real flowCV.PID.addI.k3 = 1 "Gain of input signal 3";
  parameter Real flowCV.PID.addSat.k1 = 1 "Gain of input signal 1";
  parameter Real flowCV.PID.addSat.k2 = -1 "Gain of input signal 2";
  parameter Real flowCV.PID.gainTrack.k(start = 1, unit = "1") = 1/(flowCV.PID.k
    *flowCV.PID.Ni) "Gain value multiplied with input signal";
  parameter Real flowCV.PID.Dzero.k(start = 1) = 0 "Constant output value";
  parameter Boolean flowCV.booleanConstant.k = flowCV.Use_input "Constant output value";
  parameter Boolean bypassdump2.showName = true;
  constant Integer bypassdump2.nPorts = 1 "Number of ports";
  constant Boolean bypassdump2.medium.preferredMediumStates = false 
    "= true if StateSelect.prefer shall be used for the independent property variables of the medium";
  parameter Boolean bypassdump2.medium.standardOrderComponents = true 
    "If true, and reducedX = true, the last element of X will be computed from the other ones";
  constant Modelica.Fluid.Types.PortFlowDirection bypassdump2.flowDirection = 
    Modelica.Fluid.Types.PortFlowDirection.Bidirectional "Allowed flow direction";
  constant Boolean bypassdump2.use_p_in = true "Get the pressure from the input connector";
  constant Boolean bypassdump2.use_T_in = false "Get the temperature from the input connector";
  constant Boolean bypassdump2.use_X_in = false "Get the composition from the input connector";
  constant Boolean bypassdump2.use_C_in = false "Get the trace substances from the input connector";
  parameter Modelica.Media.Interfaces.Types.AbsolutePressure bypassdump2.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) = 101325 
    "Fixed value of pressure";
  parameter Modelica.Media.Interfaces.Types.Temperature bypassdump2.T(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) = 293.15 "Fixed value of temperature";
  parameter Modelica.Media.Interfaces.Types.MassFraction bypassdump2.X[1] = {1.0}
     "Fixed value of composition";
  parameter Modelica.Media.Interfaces.Types.ExtraProperty bypassdump2.C[0](
    start = fill(1.0, size(bypassdump2.C, 1))) = fill(0, 0) "Fixed values of trace substances";
  constant Boolean sensor_m_flow1.allowFlowReversal = true "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)";
  parameter Boolean sensor_m_flow1.showName = true "= false to hide component name";
  parameter Modelica.Media.Interfaces.PartialMedium.MassFlowRate 
    sensor_m_flow1.m_flow_small(min = 0.0) = 0.0001 "Regularization for zero flow:|m_flow| < m_flow_small";
  parameter Modelica.Units.SI.AbsolutePressure sensor_m_flow1.p_start = 101325 
    "Pressure";
  parameter Boolean sensor_m_flow1.use_T_start = true "Use T_start if true, otherwise h_start";
  parameter Modelica.Units.SI.Temperature sensor_m_flow1.T_start = 293.15 
    "Temperature";
  parameter Modelica.Units.SI.SpecificEnthalpy sensor_m_flow1.h_start = 
    Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11(
    sensor_m_flow1.p_start, sensor_m_flow1.T_start, sensor_m_flow1.X_start, 0) 
    "Specific enthalpy";
  parameter Modelica.Units.SI.MassFraction sensor_m_flow1.X_start[1] = {1.0} 
    "Mass fraction";
  parameter Integer sensor_m_flow1.precision(min = 0.0) = 0 "Number of decimals displayed";
  constant String _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].iupacName
     "Complete IUPAC name (or common name, if non-existent)";
  constant String _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].casRegistryNumber
     "Chemical abstracts sequencing number (if it exists)";
  constant String _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].chemicalFormula
     "Chemical formula, (brutto, nomenclature according to Hill";
  constant String _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].structureFormula
     "Chemical structure formula";
  constant Modelica.Media.Interfaces.Types.MolarMass _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].molarMass
     "Molar mass";
  constant Modelica.Media.Interfaces.Types.Temperature _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].criticalTemperature
     = 288.15 "Critical temperature";
  constant Modelica.Media.Interfaces.Types.AbsolutePressure _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].criticalPressure
     = 100000.0 "Critical pressure";
  constant Modelica.Media.Interfaces.Types.MolarVolume _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].criticalMolarVolume
     "Critical molar Volume";
  constant Real _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].acentricFactor
     "Pitzer acentric factor";
  constant Modelica.Media.Interfaces.Types.Temperature _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].triplePointTemperature
     = 288.15 "Triple point temperature";
  constant Modelica.Media.Interfaces.Types.AbsolutePressure _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].triplePointPressure
     = 100000.0 "Triple point pressure";
  constant Modelica.Media.Interfaces.Types.Temperature _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].meltingPoint
     = 288.15 "Melting point at 101325 Pa";
  constant Modelica.Media.Interfaces.Types.Temperature _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].normalBoilingPoint
     = 288.15 "Normal boiling point (at 101325 Pa)";
  constant Modelica.Media.Interfaces.Types.DipoleMoment _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].dipoleMoment
     "Dipole moment of molecule in Debye (1 debye = 3.33564e10-30 C.m)";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasIdealGasHeatCapacity
     "True if ideal gas heat capacity is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasCriticalData
     "True if critical data are known";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasDipoleMoment
     "True if a dipole moment known";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasFundamentalEquation
     "True if a fundamental equation";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasLiquidHeatCapacity
     "True if liquid heat capacity is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasSolidHeatCapacity
     "True if solid heat capacity is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasAccurateViscosityData
     "True if accurate data for a viscosity function is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasAccurateConductivityData
     "True if accurate data for thermal conductivity is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasVapourPressureCurve
     "True if vapour pressure data, e.g., Antoine coefficients are known";
  constant Boolean _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].hasAcentricFactor
     "True if Pitzer acentric factor is known";
  constant Modelica.Media.Interfaces.Types.SpecificEnthalpy _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].HCRIT0
     "Critical specific enthalpy of the fundamental equation";
  constant Modelica.Media.Interfaces.Types.SpecificEntropy _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].SCRIT0
     "Critical specific entropy of the fundamental equation";
  constant Modelica.Media.Interfaces.Types.SpecificEnthalpy _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].deltah
     "Difference between specific enthalpy model (h_m) and f.eq. (h_f) (h_m - h_f)";
  constant Modelica.Media.Interfaces.Types.SpecificEntropy _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].deltas
     "Difference between specific enthalpy model (s_m) and f.eq. (s_f) (s_m - s_f)";
  constant String _GlobalScope.Modelica.Media.Water.waterConstants[1].iupacName
     = "oxidane" "Complete IUPAC name (or common name, if non-existent)";
  constant String _GlobalScope.Modelica.Media.Water.waterConstants[1].casRegistryNumber
     = "7732-18-5" "Chemical abstracts sequencing number (if it exists)";
  constant String _GlobalScope.Modelica.Media.Water.waterConstants[1].chemicalFormula
     = "H2O" "Chemical formula, (brutto, nomenclature according to Hill";
  constant String _GlobalScope.Modelica.Media.Water.waterConstants[1].structureFormula
     = "H2O" "Chemical structure formula";
  constant Modelica.Media.Interfaces.Types.MolarMass _GlobalScope.Modelica.Media.Water.waterConstants[1].molarMass
     = 0.018015268 "Molar mass";
  constant Modelica.Media.Interfaces.Types.Temperature _GlobalScope.Modelica.Media.Water.waterConstants[1].criticalTemperature
     = 647.096 "Critical temperature";
  constant Modelica.Media.Interfaces.Types.AbsolutePressure _GlobalScope.Modelica.Media.Water.waterConstants[1].criticalPressure
     = 22064000.0 "Critical pressure";
  constant Modelica.Media.Interfaces.Types.MolarVolume _GlobalScope.Modelica.Media.Water.waterConstants[1].criticalMolarVolume
     = 5.5948037267080745E-05 "Critical molar Volume";
  constant Real _GlobalScope.Modelica.Media.Water.waterConstants[1].acentricFactor
     = 0.344 "Pitzer acentric factor";
  constant Modelica.Media.Interfaces.Types.Temperature _GlobalScope.Modelica.Media.Water.waterConstants[1].triplePointTemperature
     = 273.16 "Triple point temperature";
  constant Modelica.Media.Interfaces.Types.AbsolutePressure _GlobalScope.Modelica.Media.Water.waterConstants[1].triplePointPressure
     = 611.657 "Triple point pressure";
  constant Modelica.Media.Interfaces.Types.Temperature _GlobalScope.Modelica.Media.Water.waterConstants[1].meltingPoint
     = 273.15 "Melting point at 101325 Pa";
  constant Modelica.Media.Interfaces.Types.Temperature _GlobalScope.Modelica.Media.Water.waterConstants[1].normalBoilingPoint
     = 373.124 "Normal boiling point (at 101325 Pa)";
  constant Modelica.Media.Interfaces.Types.DipoleMoment _GlobalScope.Modelica.Media.Water.waterConstants[1].dipoleMoment
     = 1.8 "Dipole moment of molecule in Debye (1 debye = 3.33564e10-30 C.m)";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasIdealGasHeatCapacity
     = false "True if ideal gas heat capacity is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasCriticalData
     = true "True if critical data are known";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasDipoleMoment
     = false "True if a dipole moment known";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasFundamentalEquation
     = false "True if a fundamental equation";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasLiquidHeatCapacity
     = false "True if liquid heat capacity is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasSolidHeatCapacity
     = false "True if solid heat capacity is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasAccurateViscosityData
     = false "True if accurate data for a viscosity function is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasAccurateConductivityData
     = false "True if accurate data for thermal conductivity is available";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasVapourPressureCurve
     = false "True if vapour pressure data, e.g., Antoine coefficients are known";
  constant Boolean _GlobalScope.Modelica.Media.Water.waterConstants[1].hasAcentricFactor
     = false "True if Pitzer acentric factor is known";
  constant Modelica.Media.Interfaces.Types.SpecificEnthalpy _GlobalScope.Modelica.Media.Water.waterConstants[1].HCRIT0
     = 0.0 "Critical specific enthalpy of the fundamental equation";
  constant Modelica.Media.Interfaces.Types.SpecificEntropy _GlobalScope.Modelica.Media.Water.waterConstants[1].SCRIT0
     = 0.0 "Critical specific entropy of the fundamental equation";
  constant Modelica.Media.Interfaces.Types.SpecificEnthalpy _GlobalScope.Modelica.Media.Water.waterConstants[1].deltah
     = 0.0 "Difference between specific enthalpy model (h_m) and f.eq. (h_f) (h_m - h_f)";
  constant Modelica.Media.Interfaces.Types.SpecificEntropy _GlobalScope.Modelica.Media.Water.waterConstants[1].deltas
     = 0.0 "Difference between specific enthalpy model (s_m) and f.eq. (s_f) (s_m - s_f)";

  Real breaker;
  Real Q_util "Thermal Cycle Efficiency";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate stateSensor1.port_a.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure stateSensor1.port_a.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy stateSensor1.port_a.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction stateSensor1.port_a.Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty stateSensor1.port_a.C_outflow[0]
    (start = fill(1.0, size(stateSensor1.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate stateSensor1.port_b.m_flow
    (max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure stateSensor1.port_b.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy stateSensor1.port_b.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction stateSensor1.port_b.Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty stateSensor1.port_b.C_outflow[0]
    (start = fill(1.0, size(stateSensor1.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate stateSensor1.pressure.port.m_flow
    (min = 0.0) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure stateSensor1.pressure.port.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy stateSensor1.pressure.port.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction stateSensor1.pressure.port.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty stateSensor1.pressure.port.C_outflow
    [0](start = fill(1.0, size(stateSensor1.pressure.port.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealOutput stateSensor1.pressure.p(unit = "Pa", 
    displayUnit = "bar", min = 0.0) "Pressure at port";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate stateSensor1.temperature.port.m_flow
    (min = 0.0) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure stateSensor1.temperature.port.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy stateSensor1.temperature.port.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction stateSensor1.temperature.port.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty stateSensor1.temperature.port.C_outflow
    [0](start = fill(1.0, size(stateSensor1.temperature.port.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealOutput stateSensor1.temperature.T(unit = "K", 
    displayUnit = "degC", min = 0.0) "Temperature in port medium";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate stateSensor1.massFlowRate.port_a.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure stateSensor1.massFlowRate.port_a.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy stateSensor1.massFlowRate.port_a.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction stateSensor1.massFlowRate.port_a.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty stateSensor1.massFlowRate.port_a.C_outflow
    [0](start = fill(1.0, size(stateSensor1.massFlowRate.port_a.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate stateSensor1.massFlowRate.port_b.m_flow
    (max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure stateSensor1.massFlowRate.port_b.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy stateSensor1.massFlowRate.port_b.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction stateSensor1.massFlowRate.port_b.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty stateSensor1.massFlowRate.port_b.C_outflow
    [0](start = fill(1.0, size(stateSensor1.massFlowRate.port_b.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealOutput stateSensor1.massFlowRate.m_flow(unit = 
    "kg/s") "Mass flow rate from port_a to port_b";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate stateSensor1.specificEnthalpy.port.m_flow
    (min = 0.0) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure stateSensor1.specificEnthalpy.port.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy stateSensor1.specificEnthalpy.port.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction stateSensor1.specificEnthalpy.port.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty stateSensor1.specificEnthalpy.port.C_outflow
    [0](start = fill(1.0, size(stateSensor1.specificEnthalpy.port.C_outflow, 1)))
     "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealOutput stateSensor1.specificEnthalpy.h_out(
    unit = "J/kg") "Specific enthalpy in port medium";
  Real stateSensor1.statePort.p;
  Real stateSensor1.statePort.T;
  Real stateSensor1.statePort.m_flow;
  Real stateSensor1.statePort.h_out;
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate stateSensor2.port_a.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure stateSensor2.port_a.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy stateSensor2.port_a.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction stateSensor2.port_a.Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty stateSensor2.port_a.C_outflow[0]
    (start = fill(1.0, size(stateSensor2.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate stateSensor2.port_b.m_flow
    (max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure stateSensor2.port_b.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy stateSensor2.port_b.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction stateSensor2.port_b.Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty stateSensor2.port_b.C_outflow[0]
    (start = fill(1.0, size(stateSensor2.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate stateSensor2.pressure.port.m_flow
    (min = 0.0) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure stateSensor2.pressure.port.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy stateSensor2.pressure.port.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction stateSensor2.pressure.port.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty stateSensor2.pressure.port.C_outflow
    [0](start = fill(1.0, size(stateSensor2.pressure.port.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealOutput stateSensor2.pressure.p(unit = "Pa", 
    displayUnit = "bar", min = 0.0) "Pressure at port";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate stateSensor2.temperature.port.m_flow
    (min = 0.0) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure stateSensor2.temperature.port.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy stateSensor2.temperature.port.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction stateSensor2.temperature.port.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty stateSensor2.temperature.port.C_outflow
    [0](start = fill(1.0, size(stateSensor2.temperature.port.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealOutput stateSensor2.temperature.T(unit = "K", 
    displayUnit = "degC", min = 0.0) "Temperature in port medium";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate stateSensor2.massFlowRate.port_a.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure stateSensor2.massFlowRate.port_a.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy stateSensor2.massFlowRate.port_a.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction stateSensor2.massFlowRate.port_a.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty stateSensor2.massFlowRate.port_a.C_outflow
    [0](start = fill(1.0, size(stateSensor2.massFlowRate.port_a.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate stateSensor2.massFlowRate.port_b.m_flow
    (max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure stateSensor2.massFlowRate.port_b.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy stateSensor2.massFlowRate.port_b.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction stateSensor2.massFlowRate.port_b.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty stateSensor2.massFlowRate.port_b.C_outflow
    [0](start = fill(1.0, size(stateSensor2.massFlowRate.port_b.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealOutput stateSensor2.massFlowRate.m_flow(unit = 
    "kg/s") "Mass flow rate from port_a to port_b";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate stateSensor2.specificEnthalpy.port.m_flow
    (min = 0.0) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure stateSensor2.specificEnthalpy.port.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy stateSensor2.specificEnthalpy.port.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction stateSensor2.specificEnthalpy.port.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty stateSensor2.specificEnthalpy.port.C_outflow
    [0](start = fill(1.0, size(stateSensor2.specificEnthalpy.port.C_outflow, 1)))
     "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealOutput stateSensor2.specificEnthalpy.h_out(
    unit = "J/kg") "Specific enthalpy in port medium";
  Real stateSensor2.statePort.p;
  Real stateSensor2.statePort.T;
  Real stateSensor2.statePort.m_flow;
  Real stateSensor2.statePort.h_out;
  Real stateDisplay2.statePort.p;
  Real stateDisplay2.statePort.T;
  Real stateDisplay2.statePort.m_flow;
  Real stateDisplay2.statePort.h_out;
  Real stateDisplay2.h_out(unit = "kJ/kg");
  Real stateDisplay2.p(unit = "bar");
  Real stateDisplay2.m_flow(unit = "kg/s");
  Real stateDisplay2.T(unit = "degC");
  Real stateDisplay1.statePort.p;
  Real stateDisplay1.statePort.T;
  Real stateDisplay1.statePort.m_flow;
  Real stateDisplay1.statePort.h_out;
  Real stateDisplay1.h_out(unit = "kJ/kg");
  Real stateDisplay1.p(unit = "bar");
  Real stateDisplay1.m_flow(unit = "kg/s");
  Real stateDisplay1.T(unit = "degC");
  Real BOP.CS.actuatorBus.opening_TCV "TCV fraction open";
  Real BOP.CS.actuatorBus.opening_TDV "TDV fraction open";
  Real BOP.CS.actuatorBus.opening_BV "BV fraction open";
  Real BOP.CS.actuatorBus.opening_BV_TCV "BV for TCV fraction open";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.actuatorBus.TBV "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.actuatorBus.Feed_Pump_Speed 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.actuatorBus.LPT2_BV 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.actuatorBus.LPT1_BV 
    "Connector of Real output signal";
  Modelica.Units.SI.Power BOP.CS.sensorBus.Q_balance "Heat loss (negative)/gain (positive) not accounted for in connections (e.g., energy vented to atmosphere)";
  Modelica.Units.SI.Power BOP.CS.sensorBus.W_balance "Electricity loss (negative)/gain (positive) not accounted for in connections (e.g., heating/cooling, pumps, etc.)";
  Modelica.Units.SI.Power BOP.CS.sensorBus.W_total "Total electrical power generated";
  Modelica.Units.SI.Power BOP.CS.sensorBus.W_totalSetpoint "Total electrical power setpoint";
  Modelica.Units.SI.Pressure BOP.CS.sensorBus.p_inlet_steamTurbine 
    "Inlet pressure to steam turbine";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.sensorBus.Steam_Pressure 
    "Connector of measurement input signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.sensorBus.Steam_Temperature 
    "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.sensorBus.Feedwater_Temp 
    "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.sensorBus.Extract_flow 
    "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.T_in_set.y = BOP.CS.data.Tin 
    "Value of Real output";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.T_feed_set.y = BOP.CS.data.Tfeed 
    "Value of Real output";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.P_in_set.y = BOP.CS.data.HPT_p_in
     "Value of Real output";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.Steam_Extraction.y = data.m_ext 
    "Value of Real output";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.u_s "Connector of setpoint input signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.u_m "Connector of measurement input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.FeedPump_PID.y "Connector of actuator output signal";
  Real BOP.CS.FeedPump_PID.controlError = BOP.CS.FeedPump_PID.u_s-
    BOP.CS.FeedPump_PID.u_m "Control error (set point - measurement)";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.addP.u1 
    "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.addP.u2 
    "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.FeedPump_PID.addP.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.P.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.FeedPump_PID.P.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.gainPID.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.FeedPump_PID.gainPID.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.addPID.u1 
    "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.addPID.u2 
    "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.addPID.u3 
    "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.FeedPump_PID.addPID.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.limiter.u(start = 
    BOP.CS.FeedPump_PID.y_start) "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.FeedPump_PID.limiter.y 
    "Connector of Real output signal";
  Real BOP.CS.FeedPump_PID.limiter.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.FeedPump_PID.Fzero.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.addFF.u1 
    "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.addFF.u2 
    "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.addFF.u3 
    "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.FeedPump_PID.addFF.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.gain_u_s.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.FeedPump_PID.gain_u_s.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.gain_u_m.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.FeedPump_PID.gain_u_m.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.FeedPump_PID.null_bias.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.y_reset_internal 
    "Internal connector for controller output reset";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.I.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.FeedPump_PID.I.y(start = 
    BOP.CS.FeedPump_PID.I.y_start) "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.I.y_reset_internal 
    "Internal connector for integrator reset";
  Modelica.Blocks.Interfaces.BooleanInput BOP.CS.FeedPump_PID.I.trigger_internal
     "Needed to use conditional connector trigger";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.addI.u1 
    "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.addI.u2 
    "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.addI.u3 
    "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.FeedPump_PID.addI.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.addSat.u1 
    "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.addSat.u2 
    "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.FeedPump_PID.addSat.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.FeedPump_PID.gainTrack.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.FeedPump_PID.gainTrack.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.FeedPump_PID.Dzero.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.u_s "Connector of setpoint input signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.u_m "Connector of measurement input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.TCV_PID.y "Connector of actuator output signal";
  Real BOP.CS.TCV_PID.controlError = BOP.CS.TCV_PID.u_s-BOP.CS.TCV_PID.u_m 
    "Control error (set point - measurement)";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.addP.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.addP.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.TCV_PID.addP.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.P.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.TCV_PID.P.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.gainPID.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.TCV_PID.gainPID.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.addPID.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.addPID.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.addPID.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.TCV_PID.addPID.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.limiter.u(start = 
    BOP.CS.TCV_PID.y_start) "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.TCV_PID.limiter.y 
    "Connector of Real output signal";
  Real BOP.CS.TCV_PID.limiter.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.TCV_PID.Fzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.addFF.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.addFF.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.addFF.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.TCV_PID.addFF.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.gain_u_s.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.TCV_PID.gain_u_s.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.gain_u_m.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.TCV_PID.gain_u_m.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.TCV_PID.null_bias.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.y_reset_internal 
    "Internal connector for controller output reset";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.I.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.TCV_PID.I.y(start = 
    BOP.CS.TCV_PID.I.y_start) "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.I.y_reset_internal 
    "Internal connector for integrator reset";
  Modelica.Blocks.Interfaces.BooleanInput BOP.CS.TCV_PID.I.trigger_internal 
    "Needed to use conditional connector trigger";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.addI.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.addI.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.addI.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.TCV_PID.addI.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.addSat.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.addSat.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.TCV_PID.addSat.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.TCV_PID.gainTrack.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.TCV_PID.gainTrack.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.TCV_PID.Dzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.u_s "Connector of setpoint input signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.u_m "Connector of measurement input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT1_BV_PID.y "Connector of actuator output signal";
  Real BOP.CS.LPT1_BV_PID.controlError = BOP.CS.LPT1_BV_PID.u_s-BOP.CS.LPT1_BV_PID.u_m
     "Control error (set point - measurement)";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.addP.u1 
    "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.addP.u2 
    "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT1_BV_PID.addP.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.P.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT1_BV_PID.P.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.gainPID.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT1_BV_PID.gainPID.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.addPID.u1 
    "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.addPID.u2 
    "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.addPID.u3 
    "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT1_BV_PID.addPID.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.limiter.u(start = 
    BOP.CS.LPT1_BV_PID.y_start) "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT1_BV_PID.limiter.y 
    "Connector of Real output signal";
  Real BOP.CS.LPT1_BV_PID.limiter.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT1_BV_PID.Fzero.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.addFF.u1 
    "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.addFF.u2 
    "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.addFF.u3 
    "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT1_BV_PID.addFF.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.gain_u_s.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT1_BV_PID.gain_u_s.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.gain_u_m.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT1_BV_PID.gain_u_m.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT1_BV_PID.null_bias.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.y_reset_internal 
    "Internal connector for controller output reset";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.I.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT1_BV_PID.I.y(start = 
    BOP.CS.LPT1_BV_PID.I.y_start) "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.I.y_reset_internal 
    "Internal connector for integrator reset";
  Modelica.Blocks.Interfaces.BooleanInput BOP.CS.LPT1_BV_PID.I.trigger_internal 
    "Needed to use conditional connector trigger";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.addI.u1 
    "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.addI.u2 
    "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.addI.u3 
    "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT1_BV_PID.addI.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.addSat.u1 
    "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.addSat.u2 
    "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT1_BV_PID.addSat.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT1_BV_PID.gainTrack.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT1_BV_PID.gainTrack.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT1_BV_PID.Dzero.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.u_s "Connector of setpoint input signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.u_m "Connector of measurement input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT2_BV_PID.y "Connector of actuator output signal";
  Real BOP.CS.LPT2_BV_PID.controlError = BOP.CS.LPT2_BV_PID.u_s-BOP.CS.LPT2_BV_PID.u_m
     "Control error (set point - measurement)";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.addP.u1 
    "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.addP.u2 
    "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT2_BV_PID.addP.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.P.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT2_BV_PID.P.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.gainPID.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT2_BV_PID.gainPID.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.addPID.u1 
    "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.addPID.u2 
    "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.addPID.u3 
    "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT2_BV_PID.addPID.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.limiter.u(start = 
    BOP.CS.LPT2_BV_PID.y_start) "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT2_BV_PID.limiter.y 
    "Connector of Real output signal";
  Real BOP.CS.LPT2_BV_PID.limiter.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT2_BV_PID.Fzero.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.addFF.u1 
    "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.addFF.u2 
    "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.addFF.u3 
    "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT2_BV_PID.addFF.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.gain_u_s.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT2_BV_PID.gain_u_s.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.gain_u_m.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT2_BV_PID.gain_u_m.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT2_BV_PID.null_bias.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.y_reset_internal 
    "Internal connector for controller output reset";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.I.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT2_BV_PID.I.y(start = 
    BOP.CS.LPT2_BV_PID.I.y_start) "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.I.y_reset_internal 
    "Internal connector for integrator reset";
  Modelica.Blocks.Interfaces.BooleanInput BOP.CS.LPT2_BV_PID.I.trigger_internal 
    "Needed to use conditional connector trigger";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.addI.u1 
    "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.addI.u2 
    "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.addI.u3 
    "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT2_BV_PID.addI.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.addSat.u1 
    "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.addSat.u2 
    "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT2_BV_PID.addSat.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.LPT2_BV_PID.gainTrack.u 
    "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT2_BV_PID.gainTrack.y 
    "Output signal connector";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.LPT2_BV_PID.Dzero.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.hysteresis.u;
  Modelica.Blocks.Interfaces.BooleanOutput BOP.CS.hysteresis.y;
  Modelica.Blocks.Interfaces.RealInput BOP.CS.switch1.u1 "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.BooleanInput BOP.CS.switch1.u2 "Connector of Boolean input signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.switch1.u3 "Connector of second Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.switch1.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.P_dump_open0.y = 0 
    "Value of Real output";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.P_dump_open1.y = 1 
    "Value of Real output";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.ramp.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.product1.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.product1.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.product1.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.T_in_set1.y = BOP.CS.data.mdot_total
     "Value of Real output";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.switch2.u1 "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.BooleanInput BOP.CS.switch2.u2 "Connector of Boolean input signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.switch2.u3 "Connector of second Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.switch2.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.BooleanOutput BOP.CS.booleanStep.y "Connector of Boolean output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.switch3.u1 "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.BooleanInput BOP.CS.switch3.u2 "Connector of Boolean input signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.switch3.u3 "Connector of second Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.switch3.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.switch4.u1 "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.BooleanInput BOP.CS.switch4.u2 "Connector of Boolean input signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.switch4.u3 "Connector of second Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.switch4.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.BooleanOutput BOP.CS.booleanStep1.y 
    "Connector of Boolean output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.switch5.u1 "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.BooleanInput BOP.CS.switch5.u2 "Connector of Boolean input signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.switch5.u3 "Connector of second Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.switch5.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.T_in_set2.y = 0.0 
    "Value of Real output";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.switch6.u1 "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.BooleanInput BOP.CS.switch6.u2 "Connector of Boolean input signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.switch6.u3 "Connector of second Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.switch6.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.BooleanOutput BOP.CS.booleanStep2.y 
    "Connector of Boolean output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.switch7.u1 "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.BooleanInput BOP.CS.switch7.u2 "Connector of Boolean input signal";
  Modelica.Blocks.Interfaces.RealInput BOP.CS.switch7.u3 "Connector of second Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.switch7.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.CS.ext_pos_start.y "Connector of Real output signal";
  Real BOP.ED.actuatorBus.opening_TCV "TCV fraction open";
  Real BOP.ED.actuatorBus.opening_TDV "TDV fraction open";
  Real BOP.ED.actuatorBus.opening_BV "BV fraction open";
  Real BOP.ED.actuatorBus.opening_BV_TCV "BV for TCV fraction open";
  Modelica.Blocks.Interfaces.RealOutput BOP.ED.actuatorBus.Feed_Pump_Speed 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput BOP.ED.actuatorBus.LPT1_BV(min = 0.0, 
    max = 1.0) "=1: completely open, =0: completely closed";
  Modelica.Blocks.Interfaces.RealInput BOP.ED.actuatorBus.LPT2_BV 
    "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.RealInput BOP.ED.actuatorBus.TBV(min = 0.0, max = 
    1.0) "=1: completely open, =0: completely closed";
  Modelica.Units.SI.Power BOP.ED.sensorBus.Q_balance "Heat loss (negative)/gain (positive) not accounted for in connections (e.g., energy vented to atmosphere)";
  Modelica.Units.SI.Power BOP.ED.sensorBus.W_balance "Electricity loss (negative)/gain (positive) not accounted for in connections (e.g., heating/cooling, pumps, etc.)";
  Modelica.Units.SI.Power BOP.ED.sensorBus.W_total "Total electrical power generated";
  Modelica.Units.SI.Power BOP.ED.sensorBus.W_totalSetpoint "Total electrical power setpoint";
  Modelica.Units.SI.Pressure BOP.ED.sensorBus.p_inlet_steamTurbine 
    "Inlet pressure to steam turbine";
  Modelica.Blocks.Interfaces.RealOutput BOP.ED.sensorBus.Extract_flow(unit = 
    "kg/s") "Mass flow rate from port_a to port_b";
  Modelica.Blocks.Interfaces.RealOutput BOP.ED.sensorBus.Feedwater_Temp(unit = 
    "K", displayUnit = "degC", min = 0.0) "Temperature in port medium";
  Modelica.Blocks.Interfaces.RealOutput BOP.ED.sensorBus.Steam_Pressure(unit = 
    "Pa", displayUnit = "bar", min = 0.0) "Pressure at port";
  Modelica.Blocks.Interfaces.RealOutput BOP.ED.sensorBus.Steam_Temperature(
    unit = "K", displayUnit = "degC", min = 0.0) "Temperature in port medium";
  Real BOP.actuatorBus.opening_TCV "TCV fraction open";
  Real BOP.actuatorBus.opening_TDV "TDV fraction open";
  Real BOP.actuatorBus.opening_BV "BV fraction open";
  Real BOP.actuatorBus.opening_BV_TCV "BV for TCV fraction open";
  Modelica.Blocks.Interfaces.RealInput BOP.actuatorBus.TBV(min = 0.0, max = 1.0)
     "=1: completely open, =0: completely closed";
  Modelica.Blocks.Interfaces.RealInput BOP.actuatorBus.LPT1_BV(min = 0.0, max = 
    1.0) "=1: completely open, =0: completely closed";
  Modelica.Blocks.Interfaces.RealInput BOP.actuatorBus.LPT2_BV "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.actuatorBus.Feed_Pump_Speed 
    "Connector of Real output signal";
  Modelica.Units.SI.Power BOP.sensorBus.Q_balance "Heat loss (negative)/gain (positive) not accounted for in connections (e.g., energy vented to atmosphere)";
  Modelica.Units.SI.Power BOP.sensorBus.W_balance "Electricity loss (negative)/gain (positive) not accounted for in connections (e.g., heating/cooling, pumps, etc.)";
  Modelica.Units.SI.Power BOP.sensorBus.W_total "Total electrical power generated";
  Modelica.Units.SI.Power BOP.sensorBus.W_totalSetpoint "Total electrical power setpoint";
  Modelica.Units.SI.Pressure BOP.sensorBus.p_inlet_steamTurbine "Inlet pressure to steam turbine";
  Modelica.Blocks.Interfaces.RealOutput BOP.sensorBus.Steam_Temperature(unit = 
    "K", displayUnit = "degC", min = 0.0) "Temperature in port medium";
  Modelica.Blocks.Interfaces.RealOutput BOP.sensorBus.Feedwater_Temp(unit = "K",
     displayUnit = "degC", min = 0.0) "Temperature in port medium";
  Modelica.Blocks.Interfaces.RealOutput BOP.sensorBus.Steam_Pressure(unit = "Pa",
     displayUnit = "bar", min = 0.0) "Pressure at port";
  Modelica.Blocks.Interfaces.RealOutput BOP.sensorBus.Extract_flow(unit = "kg/s")
     "Mass flow rate from port_a to port_b";
  Modelica.Blocks.Interfaces.RealOutput BOP.Q_balance.y = 0.0 "Value of Real output";
  Modelica.Blocks.Interfaces.RealOutput BOP.W_balance.y = 0.0 "Value of Real output";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.port_a_steam.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.port_a_steam.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.port_a_steam.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.port_a_steam.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.port_a_steam.C_outflow[0](
    start = fill(1.0, size(BOP.port_a_steam.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.port_b_feed.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.port_b_feed.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.port_b_feed.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.port_b_feed.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.port_b_feed.C_outflow[0](
    start = fill(1.0, size(BOP.port_b_feed.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.HPT.portHP.m_flow(
    min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.HPT.portHP.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.HPT.portHP.h_outflow(
    start = BOP.HPT.h_a_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.HPT.portHP.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.HPT.portHP.C_outflow[0](
    start = fill(1.0, size(BOP.HPT.portHP.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.HPT.portLP.m_flow(
    max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.HPT.portLP.p(start = 
    BOP.HPT.p_b_start, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.HPT.portLP.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.HPT.portLP.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.HPT.portLP.C_outflow[0](
    start = fill(1.0, size(BOP.HPT.portLP.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Angle BOP.HPT.shaft_a.phi "Absolute rotation angle of flange";
  Modelica.Units.SI.Torque BOP.HPT.shaft_a.tau "Cut torque in the flange";
  Modelica.Units.SI.Angle BOP.HPT.shaft_b.phi "Absolute rotation angle of flange";
  Modelica.Units.SI.Torque BOP.HPT.shaft_b.tau "Cut torque in the flange";
  TRANSFORM.Units.NonDim BOP.HPT.eta_wetSteam.x_abs_in = BOP.HPT.x_abs_in 
    "Inlet quality";
  TRANSFORM.Units.NonDim BOP.HPT.eta_wetSteam.x_abs_out = BOP.HPT.x_abs_out 
    "Outlet quality";
  Modelica.Units.SI.Efficiency BOP.HPT.eta_wetSteam.eta "Turbine efficiency due to wetness";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.HPT.state_a.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.HPT.state_a.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.HPT.state_a.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.HPT.state_a.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.HPT.state_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.HPT.state_b.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.HPT.state_b.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.HPT.state_b.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.HPT.state_b.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.HPT.state_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Real BOP.HPT.p_ratio "p_out/p_in pressure ratio";
  Modelica.Units.SI.Angle BOP.HPT.phi "Shaft rotation angle";
  Modelica.Units.SI.Torque BOP.HPT.tau "Net torque acting on the turbine";
  Modelica.Units.SI.AngularVelocity BOP.HPT.omega "Shaft angular velocity";
  Modelica.Units.SI.MassFlowRate BOP.HPT.m_flow(start = BOP.HPT.m_flow_start) 
    "Mass flow rate";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.HPT.h_in(start = 
    BOP.HPT.h_a_start, nominal = 500000.0) "Inlet enthalpy";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.HPT.h_out(start = 
    BOP.HPT.h_b_start, nominal = 500000.0) "Outlet enthalpy";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.HPT.h_is(start = 
    BOP.HPT.h_b_start, nominal = 500000.0) "Isentropic outlet enthalpy";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.HPT.p_in(start = 
    BOP.HPT.p_a_start, nominal = 1000000.0, min = 611.657) "Inlet pressure";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.HPT.p_out(start = 
    BOP.HPT.p_b_start, nominal = 1000000.0, min = 611.657) "Outlet pressure";
  Modelica.Units.SI.Power BOP.HPT.Q_mech "Total mechanical power";
  Modelica.Units.SI.Power BOP.HPT.Q_units[BOP.HPT.nUnits](start = 
    BOP.HPT.Q_units_start) "Mechanical power per unit";
  Modelica.Units.SI.Power BOP.HPT.Qbs[BOP.HPT.nUnits] "Power balance";
  Modelica.Units.SI.Efficiency BOP.HPT.eta_is "Isentropic efficiency";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.HPT.sat_in.psat(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature BOP.HPT.sat_in.Tsat(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.HPT.sat_out.psat(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature BOP.HPT.sat_out.Tsat(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.HPT.bubble_in.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.HPT.bubble_in.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.HPT.bubble_in.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.HPT.bubble_in.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.HPT.bubble_in.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.HPT.dew_in.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.HPT.dew_in.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.HPT.dew_in.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.HPT.dew_in.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.HPT.dew_in.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.HPT.bubble_out.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.HPT.bubble_out.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.HPT.bubble_out.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.HPT.bubble_out.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.HPT.bubble_out.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.HPT.dew_out.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.HPT.dew_out.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.HPT.dew_out.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.HPT.dew_out.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.HPT.dew_out.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.SI.SpecificEnthalpy BOP.HPT.h_fsat_in = BOP.HPT.bubble_in.h 
    "Saturated liquid specific enthalpy at inlet";
  Modelica.Units.SI.SpecificEnthalpy BOP.HPT.h_gsat_in = BOP.HPT.dew_in.h 
    "Saturated vapor specific enthalpy  at inlet";
  Modelica.Units.SI.SpecificEnthalpy BOP.HPT.h_fsat_out = BOP.HPT.bubble_out.h 
    "Saturated liquid specific enthalpy at outlet";
  Modelica.Units.SI.SpecificEnthalpy BOP.HPT.h_gsat_out = BOP.HPT.dew_out.h 
    "Saturated vapor specific enthalpy  at outlet";
  TRANSFORM.Units.NonDim BOP.HPT.x_th_in "Inlet thermodynamic quality";
  TRANSFORM.Units.NonDim BOP.HPT.x_abs_in "Inlet absolute mass quality";
  TRANSFORM.Units.NonDim BOP.HPT.x_th_out "Outlet thermodynamic quality";
  TRANSFORM.Units.NonDim BOP.HPT.x_abs_out "Outlet absolute mass quality";
  Modelica.Blocks.Interfaces.RealInput BOP.HPT.partialArc;
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.LPT1.portHP.m_flow(
    min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1.portHP.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1.portHP.h_outflow(
    start = BOP.LPT1.h_a_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.LPT1.portHP.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.LPT1.portHP.C_outflow[0](
    start = fill(1.0, size(BOP.LPT1.portHP.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.LPT1.portLP.m_flow(
    max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1.portLP.p(start = 
    BOP.LPT1.p_b_start, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1.portLP.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.LPT1.portLP.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.LPT1.portLP.C_outflow[0](
    start = fill(1.0, size(BOP.LPT1.portLP.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Angle BOP.LPT1.shaft_a.phi "Absolute rotation angle of flange";
  Modelica.Units.SI.Torque BOP.LPT1.shaft_a.tau "Cut torque in the flange";
  Modelica.Units.SI.Angle BOP.LPT1.shaft_b.phi "Absolute rotation angle of flange";
  Modelica.Units.SI.Torque BOP.LPT1.shaft_b.tau "Cut torque in the flange";
  TRANSFORM.Units.NonDim BOP.LPT1.eta_wetSteam.x_abs_in = BOP.LPT1.x_abs_in 
    "Inlet quality";
  TRANSFORM.Units.NonDim BOP.LPT1.eta_wetSteam.x_abs_out = BOP.LPT1.x_abs_out 
    "Outlet quality";
  Modelica.Units.SI.Efficiency BOP.LPT1.eta_wetSteam.eta "Turbine efficiency due to wetness";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.LPT1.state_a.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1.state_a.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.LPT1.state_a.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT1.state_a.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1.state_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.LPT1.state_b.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1.state_b.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.LPT1.state_b.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT1.state_b.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1.state_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Real BOP.LPT1.p_ratio "p_out/p_in pressure ratio";
  Modelica.Units.SI.Angle BOP.LPT1.phi "Shaft rotation angle";
  Modelica.Units.SI.Torque BOP.LPT1.tau "Net torque acting on the turbine";
  Modelica.Units.SI.AngularVelocity BOP.LPT1.omega "Shaft angular velocity";
  Modelica.Units.SI.MassFlowRate BOP.LPT1.m_flow(start = BOP.LPT1.m_flow_start) 
    "Mass flow rate";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1.h_in(start = 
    BOP.LPT1.h_a_start, nominal = 500000.0) "Inlet enthalpy";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1.h_out(start = 
    BOP.LPT1.h_b_start, nominal = 500000.0) "Outlet enthalpy";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1.h_is(start = 
    BOP.LPT1.h_b_start, nominal = 500000.0) "Isentropic outlet enthalpy";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1.p_in(start = 
    BOP.LPT1.p_a_start, nominal = 1000000.0, min = 611.657) "Inlet pressure";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1.p_out(start = 
    BOP.LPT1.p_b_start, nominal = 1000000.0, min = 611.657) "Outlet pressure";
  Modelica.Units.SI.Power BOP.LPT1.Q_mech "Total mechanical power";
  Modelica.Units.SI.Power BOP.LPT1.Q_units[BOP.LPT1.nUnits](start = 
    BOP.LPT1.Q_units_start) "Mechanical power per unit";
  Modelica.Units.SI.Power BOP.LPT1.Qbs[BOP.LPT1.nUnits] "Power balance";
  Modelica.Units.SI.Efficiency BOP.LPT1.eta_is "Isentropic efficiency";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1.sat_in.psat(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT1.sat_in.Tsat(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1.sat_out.psat(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT1.sat_out.Tsat(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.LPT1.bubble_in.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1.bubble_in.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.LPT1.bubble_in.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT1.bubble_in.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1.bubble_in.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.LPT1.dew_in.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1.dew_in.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.LPT1.dew_in.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT1.dew_in.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1.dew_in.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.LPT1.bubble_out.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1.bubble_out.h(
    start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.LPT1.bubble_out.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT1.bubble_out.T(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1.bubble_out.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.LPT1.dew_out.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1.dew_out.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.LPT1.dew_out.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT1.dew_out.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1.dew_out.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.SI.SpecificEnthalpy BOP.LPT1.h_fsat_in = BOP.LPT1.bubble_in.h 
    "Saturated liquid specific enthalpy at inlet";
  Modelica.Units.SI.SpecificEnthalpy BOP.LPT1.h_gsat_in = BOP.LPT1.dew_in.h 
    "Saturated vapor specific enthalpy  at inlet";
  Modelica.Units.SI.SpecificEnthalpy BOP.LPT1.h_fsat_out = BOP.LPT1.bubble_out.h
     "Saturated liquid specific enthalpy at outlet";
  Modelica.Units.SI.SpecificEnthalpy BOP.LPT1.h_gsat_out = BOP.LPT1.dew_out.h 
    "Saturated vapor specific enthalpy  at outlet";
  TRANSFORM.Units.NonDim BOP.LPT1.x_th_in "Inlet thermodynamic quality";
  TRANSFORM.Units.NonDim BOP.LPT1.x_abs_in "Inlet absolute mass quality";
  TRANSFORM.Units.NonDim BOP.LPT1.x_th_out "Outlet thermodynamic quality";
  TRANSFORM.Units.NonDim BOP.LPT1.x_abs_out "Outlet absolute mass quality";
  Modelica.Blocks.Interfaces.RealInput BOP.LPT1.partialArc;
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.LPT2.portHP.m_flow(
    min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT2.portHP.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT2.portHP.h_outflow(
    start = BOP.LPT2.h_a_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.LPT2.portHP.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.LPT2.portHP.C_outflow[0](
    start = fill(1.0, size(BOP.LPT2.portHP.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.LPT2.portLP.m_flow(
    max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT2.portLP.p(start = 
    BOP.LPT2.p_b_start, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT2.portLP.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.LPT2.portLP.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.LPT2.portLP.C_outflow[0](
    start = fill(1.0, size(BOP.LPT2.portLP.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Angle BOP.LPT2.shaft_a.phi "Absolute rotation angle of flange";
  Modelica.Units.SI.Torque BOP.LPT2.shaft_a.tau "Cut torque in the flange";
  Modelica.Units.SI.Angle BOP.LPT2.shaft_b.phi "Absolute rotation angle of flange";
  Modelica.Units.SI.Torque BOP.LPT2.shaft_b.tau "Cut torque in the flange";
  TRANSFORM.Units.NonDim BOP.LPT2.eta_wetSteam.x_abs_in = BOP.LPT2.x_abs_in 
    "Inlet quality";
  TRANSFORM.Units.NonDim BOP.LPT2.eta_wetSteam.x_abs_out = BOP.LPT2.x_abs_out 
    "Outlet quality";
  Modelica.Units.SI.Efficiency BOP.LPT2.eta_wetSteam.eta "Turbine efficiency due to wetness";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.LPT2.state_a.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT2.state_a.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.LPT2.state_a.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT2.state_a.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT2.state_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.LPT2.state_b.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT2.state_b.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.LPT2.state_b.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT2.state_b.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT2.state_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Real BOP.LPT2.p_ratio "p_out/p_in pressure ratio";
  Modelica.Units.SI.Angle BOP.LPT2.phi "Shaft rotation angle";
  Modelica.Units.SI.Torque BOP.LPT2.tau "Net torque acting on the turbine";
  Modelica.Units.SI.AngularVelocity BOP.LPT2.omega "Shaft angular velocity";
  Modelica.Units.SI.MassFlowRate BOP.LPT2.m_flow(start = BOP.LPT2.m_flow_start) 
    "Mass flow rate";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT2.h_in(start = 
    BOP.LPT2.h_a_start, nominal = 500000.0) "Inlet enthalpy";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT2.h_out(start = 
    BOP.LPT2.h_b_start, nominal = 500000.0) "Outlet enthalpy";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT2.h_is(start = 
    BOP.LPT2.h_b_start, nominal = 500000.0) "Isentropic outlet enthalpy";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT2.p_in(start = 
    BOP.LPT2.p_a_start, nominal = 1000000.0, min = 611.657) "Inlet pressure";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT2.p_out(start = 
    BOP.LPT2.p_b_start, nominal = 1000000.0, min = 611.657) "Outlet pressure";
  Modelica.Units.SI.Power BOP.LPT2.Q_mech "Total mechanical power";
  Modelica.Units.SI.Power BOP.LPT2.Q_units[BOP.LPT2.nUnits](start = 
    BOP.LPT2.Q_units_start) "Mechanical power per unit";
  Modelica.Units.SI.Power BOP.LPT2.Qbs[BOP.LPT2.nUnits] "Power balance";
  Modelica.Units.SI.Efficiency BOP.LPT2.eta_is "Isentropic efficiency";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT2.sat_in.psat(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT2.sat_in.Tsat(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT2.sat_out.psat(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT2.sat_out.Tsat(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.LPT2.bubble_in.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT2.bubble_in.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.LPT2.bubble_in.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT2.bubble_in.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT2.bubble_in.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.LPT2.dew_in.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT2.dew_in.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.LPT2.dew_in.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT2.dew_in.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT2.dew_in.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.LPT2.bubble_out.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT2.bubble_out.h(
    start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.LPT2.bubble_out.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT2.bubble_out.T(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT2.bubble_out.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.LPT2.dew_out.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT2.dew_out.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.LPT2.dew_out.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT2.dew_out.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT2.dew_out.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.SI.SpecificEnthalpy BOP.LPT2.h_fsat_in = BOP.LPT2.bubble_in.h 
    "Saturated liquid specific enthalpy at inlet";
  Modelica.Units.SI.SpecificEnthalpy BOP.LPT2.h_gsat_in = BOP.LPT2.dew_in.h 
    "Saturated vapor specific enthalpy  at inlet";
  Modelica.Units.SI.SpecificEnthalpy BOP.LPT2.h_fsat_out = BOP.LPT2.bubble_out.h
     "Saturated liquid specific enthalpy at outlet";
  Modelica.Units.SI.SpecificEnthalpy BOP.LPT2.h_gsat_out = BOP.LPT2.dew_out.h 
    "Saturated vapor specific enthalpy  at outlet";
  TRANSFORM.Units.NonDim BOP.LPT2.x_th_in "Inlet thermodynamic quality";
  TRANSFORM.Units.NonDim BOP.LPT2.x_abs_in "Inlet absolute mass quality";
  TRANSFORM.Units.NonDim BOP.LPT2.x_th_out "Outlet thermodynamic quality";
  TRANSFORM.Units.NonDim BOP.LPT2.x_abs_out "Outlet absolute mass quality";
  Modelica.Blocks.Interfaces.RealInput BOP.LPT2.partialArc;
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.moistureSeperator.port_Liquid.m_flow
     "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.moistureSeperator.port_Liquid.p
    (start = BOP.moistureSeperator.p_start, nominal = 1000000.0, min = 611.657) 
    "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.moistureSeperator.port_Liquid.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.moistureSeperator.port_Liquid.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.moistureSeperator.port_Liquid.C_outflow
    [0](start = fill(1.0, size(BOP.moistureSeperator.port_Liquid.C_outflow, 1)))
     "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.moistureSeperator.port_a[1].m_flow
     "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.moistureSeperator.port_a[1].p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.moistureSeperator.port_a[1].h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.moistureSeperator.port_a[1].Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.moistureSeperator.port_a[1].C_outflow
    [0](start = fill(1.0, size(BOP.moistureSeperator.port_a[1].C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.moistureSeperator.port_b[1].m_flow
     "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.moistureSeperator.port_b[1].p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.moistureSeperator.port_b[1].h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.moistureSeperator.port_b[1].Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.moistureSeperator.port_b[1].C_outflow
    [0](start = fill(1.0, size(BOP.moistureSeperator.port_b[1].C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Volume BOP.moistureSeperator.V(min = 0.0) = BOP.moistureSeperator.geometry.V
     "Volume";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    BOP.moistureSeperator.medium.p(start = BOP.moistureSeperator.p_start, 
    nominal = 100000.0, unit = "Pa", displayUnit = "bar", min = 0.0, 
    stateSelect = StateSelect.prefer) "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    BOP.moistureSeperator.medium.Xi[0](start = BOP.moistureSeperator.X_start[1:0],
     unit = "1", min = 0.0, max = 1.0) "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    BOP.moistureSeperator.medium.h(start = (if  not BOP.moistureSeperator.use_T_start
     then BOP.moistureSeperator.h_start else Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11
    (BOP.moistureSeperator.p_start, BOP.moistureSeperator.T_start, 
    BOP.moistureSeperator.X_start[1:0], 0)), unit = "J/kg", stateSelect = 
    StateSelect.prefer) "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density BOP.moistureSeperator.medium.d(
    start = (if BOP.moistureSeperator.use_T_start then Modelica.Media.Water.WaterIF97_ph.density_pTX_Unique32
    (BOP.moistureSeperator.p_start, BOP.moistureSeperator.T_start, 
    BOP.moistureSeperator.X_start[1:0]) else Modelica.Media.Water.WaterIF97_ph.density_phX_Unique33
    (BOP.moistureSeperator.p_start, BOP.moistureSeperator.h_start, 
    BOP.moistureSeperator.X_start[1:0], 0)), nominal = 500.0) "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature BOP.moistureSeperator.medium.T(
    start = (if BOP.moistureSeperator.use_T_start then BOP.moistureSeperator.T_start
     else Modelica.Media.Water.WaterIF97_ph.temperature_phX_Unique34(
    BOP.moistureSeperator.p_start, BOP.moistureSeperator.h_start, 
    BOP.moistureSeperator.X_start[1:0], 0)), nominal = 500.0, min = 273.15, 
    max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction BOP.moistureSeperator.medium.X[1]
    (start = BOP.moistureSeperator.X_start) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy BOP.moistureSeperator.medium.u
     "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity BOP.moistureSeperator.medium.R_s
     "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass BOP.moistureSeperator.medium.MM 
    "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.moistureSeperator.medium.state.phase
     "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.moistureSeperator.medium.state.h
    (start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.moistureSeperator.medium.state.d(
    start = 150, nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.moistureSeperator.medium.state.T
    (start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.moistureSeperator.medium.state.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC BOP.moistureSeperator.medium.T_degC = 
    Modelica.Units.Conversions.to_degC(BOP.moistureSeperator.medium.T) 
    "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar BOP.moistureSeperator.medium.p_bar = 
    Modelica.Units.Conversions.to_bar(BOP.moistureSeperator.medium.p) 
    "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.moistureSeperator.medium.sat.psat
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature BOP.moistureSeperator.medium.sat.Tsat
    (start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer BOP.moistureSeperator.medium.phase(start = 1, fixed = false, min = 0.0,
     max = 2.0) "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Units.SI.Mass BOP.moistureSeperator.m "Mass";
  Modelica.Units.SI.InternalEnergy BOP.moistureSeperator.U "Internal energy";
  Modelica.Units.SI.Mass BOP.moistureSeperator.mXi[0] "Species mass";
  TRANSFORM.Units.ExtraPropertyExtrinsic BOP.moistureSeperator.mC[0] 
    "Trace substance extrinsic value";
  TRANSFORM.Units.ExtraPropertyExtrinsic BOP.moistureSeperator.mC_scaled[0] 
    "Scaled trace substance for improved numerical stability";
  TRANSFORM.Units.ExtraProperty BOP.moistureSeperator.C[0](start = 
    BOP.moistureSeperator.C_start, stateSelect = StateSelect.prefer) 
    "Trace substance mass-specific value";
  Modelica.Units.SI.MassFlowRate BOP.moistureSeperator.mb = sum(BOP.moistureSeperator.port_a
    .m_flow)+sum(BOP.moistureSeperator.port_b.m_flow)+BOP.moistureSeperator.port_Liquid.m_flow
     "Mass flow rate source/sinks within volumes";
  Modelica.Units.SI.HeatFlowRate BOP.moistureSeperator.Ub = sum(BOP.moistureSeperator.H_flows_a)
    +sum(BOP.moistureSeperator.H_flows_b)+BOP.moistureSeperator.port_Liquid.m_flow
    *actualStream(BOP.moistureSeperator.port_Liquid.h_outflow)+BOP.moistureSeperator.Q_flow_internal
    +BOP.moistureSeperator.Q_gen "Energy source/sinks within volumes (e.g., ohmic heating, external convection)";
  Modelica.Units.SI.MassFlowRate BOP.moistureSeperator.mXib[0] = array(sum(
    BOP.moistureSeperator.mXi_flows_a[:, i])+sum(BOP.moistureSeperator.mXi_flows_b
    [:, i])+BOP.moistureSeperator.port_Liquid.m_flow*actualStream(
    BOP.moistureSeperator.port_Liquid.Xi_outflow[i]) for i in 1:0) 
    "Species mass flow rates source/sinks within volumes";
  TRANSFORM.Units.ExtraPropertyFlowRate BOP.moistureSeperator.mCb[0] = array(sum
    (BOP.moistureSeperator.mC_flows_a[:, i])+sum(BOP.moistureSeperator.mC_flows_b
    [:, i])+BOP.moistureSeperator.port_Liquid.m_flow*actualStream(
    BOP.moistureSeperator.port_Liquid.C_outflow[i])+BOP.moistureSeperator.mC_flow_internal
    [i]+BOP.moistureSeperator.mC_gen[i] for i in 1:0) "Trace flow rate source/sinks within volumes (e.g., chemical reactions, external convection)";
  Modelica.Units.SI.Volume BOP.moistureSeperator.geometry.V = 5 "Volume";
  Modelica.Units.SI.Angle BOP.moistureSeperator.geometry.angle(min = 
    -1.5807963267948966, max = 1.5807963267948966) = 0.0 "Vertical angle from the horizontal (-pi/2 <= x <= pi/2)";
  Modelica.Units.SI.Length BOP.moistureSeperator.geometry.dheight = 0*sin(
    BOP.moistureSeperator.geometry.angle) "Height(port_b) - Height(port_a)";
  Modelica.Units.SI.Length BOP.moistureSeperator.geometry.height_a = 0 
    "Elevation at port_a: Reference value only. No impact on calculations.";
  Modelica.Units.SI.Length BOP.moistureSeperator.geometry.height_b = 
    BOP.moistureSeperator.geometry.height_a+BOP.moistureSeperator.geometry.dheight
     "Elevation at port_b: Reference value only. No impact on calculations.";
  Modelica.Units.SI.Acceleration BOP.moistureSeperator.g_n = 9.80665 
    "Gravitational acceleration";
  Modelica.Units.SI.HeatFlowRate BOP.moistureSeperator.H_flows_a[
    BOP.moistureSeperator.nPorts_a] "Enthalpy flow rates at port_a";
  Modelica.Units.SI.MassFlowRate BOP.moistureSeperator.mXi_flows_a[
    BOP.moistureSeperator.nPorts_a, 0] "Species mass flow rates at port_a";
  TRANSFORM.Units.ExtraPropertyFlowRate BOP.moistureSeperator.mC_flows_a[
    BOP.moistureSeperator.nPorts_a, 0] "Trace substance flow rates at port_a";
  Modelica.Units.SI.HeatFlowRate BOP.moistureSeperator.H_flows_b[
    BOP.moistureSeperator.nPorts_b] "Enthalpy flow rates at port_b";
  Modelica.Units.SI.MassFlowRate BOP.moistureSeperator.mXi_flows_b[
    BOP.moistureSeperator.nPorts_b, 0] "Species mass flow rates at port_b";
  TRANSFORM.Units.ExtraPropertyFlowRate BOP.moistureSeperator.mC_flows_b[
    BOP.moistureSeperator.nPorts_b, 0] "Trace substance flow rates at port_b";
  Modelica.Units.SI.HeatFlowRate BOP.moistureSeperator.Q_gen = 0 
    "Internal heat generation";
  TRANSFORM.Units.ExtraPropertyFlowRate BOP.moistureSeperator.mC_gen[0] = fill(0,
     0) "Internal trace mass generation";
  Modelica.Units.SI.HeatFlowRate BOP.moistureSeperator.Q_flow_internal;
  TRANSFORM.Units.ExtraPropertyFlowRate BOP.moistureSeperator.mC_flow_internal[0];
  Modelica.Units.SI.Efficiency BOP.moistureSeperator.eta_sep(max = 1.0) = 0.99 
    "Separation efficiency";
  Modelica.Units.SI.MassFlowRate BOP.moistureSeperator.m_flow_liquid;
  Modelica.Units.SI.MassFlowRate BOP.moistureSeperator.m_flow_a_inflow;
  Modelica.Units.SI.MassFlowRate BOP.moistureSeperator.m_flow_b_inflow;
  Modelica.Units.SI.MassFraction BOP.moistureSeperator.x_abs;
  Modelica.Units.SI.Pressure BOP.moistureSeperator.p_crit = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
    .criticalPressure;
  Modelica.Units.SI.SpecificEnthalpy BOP.moistureSeperator.h_lsat;
  Modelica.Units.SI.SpecificEnthalpy BOP.moistureSeperator.h_vsat;
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.port_b_bypass.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.port_b_bypass.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.port_b_bypass.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.port_b_bypass.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.port_b_bypass.C_outflow[0](
    start = fill(1.0, size(BOP.port_b_bypass.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Volume BOP.LPT1_bypass.V(min = 0.0) = 5 "Volume";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    BOP.LPT1_bypass.medium.p(start = BOP.LPT1_bypass.p_start, nominal = 100000.0,
     unit = "Pa", displayUnit = "bar", min = 0.0, stateSelect = StateSelect.prefer)
     "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    BOP.LPT1_bypass.medium.Xi[0](start = BOP.LPT1_bypass.X_start[1:0], unit = 
    "1", min = 0.0, max = 1.0) "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    BOP.LPT1_bypass.medium.h(start = (if  not BOP.LPT1_bypass.use_T_start then 
    BOP.LPT1_bypass.h_start else Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11
    (BOP.LPT1_bypass.p_start, BOP.LPT1_bypass.T_start, BOP.LPT1_bypass.X_start[1
    :0], 0)), unit = "J/kg", stateSelect = StateSelect.prefer) "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density BOP.LPT1_bypass.medium.d(start = (if 
    BOP.LPT1_bypass.use_T_start then Modelica.Media.Water.WaterIF97_ph.density_pTX_Unique32
    (BOP.LPT1_bypass.p_start, BOP.LPT1_bypass.T_start, BOP.LPT1_bypass.X_start[1
    :0]) else Modelica.Media.Water.WaterIF97_ph.density_phX_Unique33(
    BOP.LPT1_bypass.p_start, BOP.LPT1_bypass.h_start, BOP.LPT1_bypass.X_start[1:0],
     0)), nominal = 500.0) "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT1_bypass.medium.T(start = (
    if BOP.LPT1_bypass.use_T_start then BOP.LPT1_bypass.T_start else 
    Modelica.Media.Water.WaterIF97_ph.temperature_phX_Unique34(BOP.LPT1_bypass.p_start,
     BOP.LPT1_bypass.h_start, BOP.LPT1_bypass.X_start[1:0], 0)), nominal = 500.0,
     min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction BOP.LPT1_bypass.medium.X[1](
    start = BOP.LPT1_bypass.X_start) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy BOP.LPT1_bypass.medium.u
     "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity BOP.LPT1_bypass.medium.R_s
     "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass BOP.LPT1_bypass.medium.MM 
    "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.LPT1_bypass.medium.state.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1_bypass.medium.state.h
    (start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.LPT1_bypass.medium.state.d(
    start = 150, nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT1_bypass.medium.state.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1_bypass.medium.state.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC BOP.LPT1_bypass.medium.T_degC = 
    Modelica.Units.Conversions.to_degC(BOP.LPT1_bypass.medium.T) 
    "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar BOP.LPT1_bypass.medium.p_bar = 
    Modelica.Units.Conversions.to_bar(BOP.LPT1_bypass.medium.p) "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1_bypass.medium.sat.psat
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT1_bypass.medium.sat.Tsat(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer BOP.LPT1_bypass.medium.phase(start = 1, fixed = false, min = 0.0, 
    max = 2.0) "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Units.SI.Mass BOP.LPT1_bypass.m "Mass";
  Modelica.Units.SI.InternalEnergy BOP.LPT1_bypass.U "Internal energy";
  Modelica.Units.SI.Mass BOP.LPT1_bypass.mXi[0] "Species mass";
  TRANSFORM.Units.ExtraPropertyExtrinsic BOP.LPT1_bypass.mC[0] "Trace substance extrinsic value";
  TRANSFORM.Units.ExtraPropertyExtrinsic BOP.LPT1_bypass.mC_scaled[0] 
    "Scaled trace substance for improved numerical stability";
  TRANSFORM.Units.ExtraProperty BOP.LPT1_bypass.C[0](start = BOP.LPT1_bypass.C_start,
     stateSelect = StateSelect.prefer) "Trace substance mass-specific value";
  Modelica.Units.SI.MassFlowRate BOP.LPT1_bypass.mb = BOP.LPT1_bypass.port_1.m_flow
    +BOP.LPT1_bypass.port_2.m_flow+BOP.LPT1_bypass.port_3.m_flow 
    "Mass flow rate source/sinks within volumes";
  Modelica.Units.SI.HeatFlowRate BOP.LPT1_bypass.Ub = BOP.LPT1_bypass.port_1.m_flow
    *actualStream(BOP.LPT1_bypass.port_1.h_outflow)+BOP.LPT1_bypass.port_2.m_flow
    *actualStream(BOP.LPT1_bypass.port_2.h_outflow)+BOP.LPT1_bypass.port_3.m_flow
    *actualStream(BOP.LPT1_bypass.port_3.h_outflow) "Energy source/sinks within volumes (e.g., ohmic heating, external convection)";
  Modelica.Units.SI.MassFlowRate BOP.LPT1_bypass.mXib[0] = BOP.LPT1_bypass.port_1.m_flow
    *actualStream(BOP.LPT1_bypass.port_1.Xi_outflow)+BOP.LPT1_bypass.port_2.m_flow
    *actualStream(BOP.LPT1_bypass.port_2.Xi_outflow)+BOP.LPT1_bypass.port_3.m_flow
    *actualStream(BOP.LPT1_bypass.port_3.Xi_outflow) "Species mass flow rates source/sinks within volumes";
  TRANSFORM.Units.ExtraPropertyFlowRate BOP.LPT1_bypass.mCb[0] = 
    BOP.LPT1_bypass.port_1.m_flow*actualStream(BOP.LPT1_bypass.port_1.C_outflow)
    +BOP.LPT1_bypass.port_2.m_flow*actualStream(BOP.LPT1_bypass.port_2.C_outflow)
    +BOP.LPT1_bypass.port_3.m_flow*actualStream(BOP.LPT1_bypass.port_3.C_outflow)
     "Trace flow rate source/sinks within volumes (e.g., chemical reactions, external convection)";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.LPT1_bypass.port_1.m_flow
     "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1_bypass.port_1.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1_bypass.port_1.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.LPT1_bypass.port_1.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.LPT1_bypass.port_1.C_outflow
    [0](start = fill(1.0, size(BOP.LPT1_bypass.port_1.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.LPT1_bypass.port_2.m_flow
     "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1_bypass.port_2.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1_bypass.port_2.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.LPT1_bypass.port_2.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.LPT1_bypass.port_2.C_outflow
    [0](start = fill(1.0, size(BOP.LPT1_bypass.port_2.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.LPT1_bypass.port_3.m_flow
     "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1_bypass.port_3.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1_bypass.port_3.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.LPT1_bypass.port_3.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.LPT1_bypass.port_3.C_outflow
    [0](start = fill(1.0, size(BOP.LPT1_bypass.port_3.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.LPT1_bypass_valve.port_a.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1_bypass_valve.port_a.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1_bypass_valve.port_a.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.LPT1_bypass_valve.port_a.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.LPT1_bypass_valve.port_a.C_outflow
    [0](start = fill(1.0, size(BOP.LPT1_bypass_valve.port_a.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.LPT1_bypass_valve.port_b.m_flow
    (max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1_bypass_valve.port_b.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1_bypass_valve.port_b.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.LPT1_bypass_valve.port_b.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.LPT1_bypass_valve.port_b.C_outflow
    [0](start = fill(1.0, size(BOP.LPT1_bypass_valve.port_b.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.LPT1_bypass_valve.m_flow
    (start = BOP.LPT1_bypass_valve.m_flow_start, min = -1E+60) "Mass flow rate in design flow direction";
  Modelica.Units.SI.Pressure BOP.LPT1_bypass_valve.dp(start = BOP.LPT1_bypass_valve.dp_start)
     "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
  Modelica.Units.SI.VolumeFlowRate BOP.LPT1_bypass_valve.V_flow = 
    BOP.LPT1_bypass_valve.m_flow/Modelica.Fluid.Utilities.regStep(
    BOP.LPT1_bypass_valve.m_flow, Modelica.Media.Water.WaterIF97_ph.density_Unique30
    (
    BOP.LPT1_bypass_valve.state_a), Modelica.Media.Water.WaterIF97_ph.density_Unique30
    (
    BOP.LPT1_bypass_valve.state_b), BOP.LPT1_bypass_valve.m_flow_small) 
    "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT1_bypass_valve.port_a_T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = 
    Modelica.Fluid.Utilities.regStep(BOP.LPT1_bypass_valve.port_a.m_flow, 
    Modelica.Media.Water.WaterIF97_ph.temperature_Unique35(
    BOP.LPT1_bypass_valve.state_a), Modelica.Media.Water.WaterIF97_ph.temperature_Unique35
    (
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(BOP.LPT1_bypass_valve.port_a.p,
       BOP.LPT1_bypass_valve.port_a.h_outflow, BOP.LPT1_bypass_valve.port_a.Xi_outflow,
       0, 0)), BOP.LPT1_bypass_valve.m_flow_small) "Temperature close to port_a, if show_T = true";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT1_bypass_valve.port_b_T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = 
    Modelica.Fluid.Utilities.regStep(BOP.LPT1_bypass_valve.port_b.m_flow, 
    Modelica.Media.Water.WaterIF97_ph.temperature_Unique35(
    BOP.LPT1_bypass_valve.state_b), Modelica.Media.Water.WaterIF97_ph.temperature_Unique35
    (
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(BOP.LPT1_bypass_valve.port_b.p,
       BOP.LPT1_bypass_valve.port_b.h_outflow, BOP.LPT1_bypass_valve.port_b.Xi_outflow,
       0, 0)), BOP.LPT1_bypass_valve.m_flow_small) "Temperature close to port_b, if show_T = true";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.LPT1_bypass_valve.state_a.phase
     "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1_bypass_valve.state_a.h
    (start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.LPT1_bypass_valve.state_a.d(
    start = 150, nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT1_bypass_valve.state_a.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1_bypass_valve.state_a.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.LPT1_bypass_valve.state_b.phase
     "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.LPT1_bypass_valve.state_b.h
    (start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.LPT1_bypass_valve.state_b.d(
    start = 150, nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.LPT1_bypass_valve.state_b.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.LPT1_bypass_valve.state_b.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Blocks.Interfaces.RealInput BOP.LPT1_bypass_valve.opening(min = 0.0, 
    max = 1.0) "=1: completely open, =0: completely closed";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.prt_b_steamdump.m_flow
     "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.prt_b_steamdump.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.prt_b_steamdump.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.prt_b_steamdump.Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.prt_b_steamdump.C_outflow[0]
    (start = fill(1.0, size(BOP.prt_b_steamdump.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.TBV.port_a.m_flow(
    min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.TBV.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.TBV.port_a.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.TBV.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.TBV.port_a.C_outflow[0](
    start = fill(1.0, size(BOP.TBV.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.TBV.port_b.m_flow(
    max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.TBV.port_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.TBV.port_b.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.TBV.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.TBV.port_b.C_outflow[0](
    start = fill(1.0, size(BOP.TBV.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.TBV.m_flow(start = 
    BOP.TBV.m_flow_start, min = -1E+60) "Mass flow rate in design flow direction";
  Modelica.Units.SI.Pressure BOP.TBV.dp(start = BOP.TBV.dp_start) 
    "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
  Modelica.Units.SI.VolumeFlowRate BOP.TBV.V_flow = BOP.TBV.m_flow/
    Modelica.Fluid.Utilities.regStep(BOP.TBV.m_flow, Modelica.Media.Water.WaterIF97_ph.density_Unique30
    (
    BOP.TBV.state_a), Modelica.Media.Water.WaterIF97_ph.density_Unique30(
    BOP.TBV.state_b), BOP.TBV.m_flow_small) "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";
  Modelica.Media.Interfaces.Types.Temperature BOP.TBV.port_a_T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) = Modelica.Fluid.Utilities.regStep
    (BOP.TBV.port_a.m_flow, Modelica.Media.Water.WaterIF97_ph.temperature_Unique35
    (
    BOP.TBV.state_a), Modelica.Media.Water.WaterIF97_ph.temperature_Unique35(
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(BOP.TBV.port_a.p, 
      BOP.TBV.port_a.h_outflow, BOP.TBV.port_a.Xi_outflow, 0, 0)), 
    BOP.TBV.m_flow_small) "Temperature close to port_a, if show_T = true";
  Modelica.Media.Interfaces.Types.Temperature BOP.TBV.port_b_T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) = Modelica.Fluid.Utilities.regStep
    (BOP.TBV.port_b.m_flow, Modelica.Media.Water.WaterIF97_ph.temperature_Unique35
    (
    BOP.TBV.state_b), Modelica.Media.Water.WaterIF97_ph.temperature_Unique35(
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(BOP.TBV.port_b.p, 
      BOP.TBV.port_b.h_outflow, BOP.TBV.port_b.Xi_outflow, 0, 0)), 
    BOP.TBV.m_flow_small) "Temperature close to port_b, if show_T = true";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.TBV.state_a.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.TBV.state_a.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.TBV.state_a.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.TBV.state_a.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.TBV.state_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.TBV.state_b.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.TBV.state_b.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.TBV.state_b.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.TBV.state_b.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.TBV.state_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Blocks.Interfaces.RealInput BOP.TBV.opening(min = 0.0, max = 1.0) 
    "=1: completely open, =0: completely closed";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.condenser.port_a.m_flow
     "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.condenser.port_a.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.condenser.port_a.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.condenser.port_a.Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.condenser.port_a.C_outflow[0]
    (start = fill(1.0, size(BOP.condenser.port_a.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.condenser.port_b.m_flow
     "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.condenser.port_b.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.condenser.port_b.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.condenser.port_b.Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.condenser.port_b.C_outflow[0]
    (start = fill(1.0, size(BOP.condenser.port_b.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.condenser.sat.psat(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature BOP.condenser.sat.Tsat(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.condenser.h_fsat(start = 
    100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique25
    (
    BOP.condenser.sat) "Specific enthalpy of saturated liquid";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.condenser.h_gsat(start = 
    100000.0, nominal = 500000.0) = Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique28
    (
    BOP.condenser.sat) "Specific enthalpy of saturated vapor";
  Modelica.Units.SI.Density BOP.condenser.rho_fsat = Modelica.Media.Water.WaterIF97_ph.bubbleDensity_Unique26
    (
    BOP.condenser.sat) "Density of saturated liquid";
  Modelica.Units.SI.Density BOP.condenser.rho_gsat = Modelica.Media.Water.WaterIF97_ph.dewDensity_Unique29
    (
    BOP.condenser.sat) "Density of saturated steam";
  Modelica.Units.SI.Mass BOP.condenser.m_total "Total mass, steam+liquid";
  Modelica.Units.SI.Mass BOP.condenser.m_liquid "Liquid mass";
  Modelica.Units.SI.Mass BOP.condenser.m_vapor "Steam mass";
  Modelica.Units.SI.Volume BOP.condenser.V_liquid(start = BOP.condenser.V_liquid_start)
     "Liquid volume";
  Modelica.Units.SI.Volume BOP.condenser.V_vapor "Steam volume";
  Modelica.Units.SI.Energy BOP.condenser.E "Internal energy";
  Modelica.Units.SI.Power BOP.condenser.Q_total "Total thermal energy removed";
  Modelica.Units.SI.Power BOP.generator.Q_mech "Mechanical power";
  Modelica.Units.SI.Power BOP.generator.Q_elec "Electrical Power";
  Modelica.Units.SI.Power BOP.generator.Q_loss "Inertial power Loss";
  Modelica.Units.SI.Torque BOP.generator.tau "Torque at shaft";
  Modelica.Units.SI.AngularVelocity BOP.generator.omega_m(start = 
    6.283185307179586*BOP.generator.f_start/BOP.generator.nPoles) 
    "Angular velocity of the shaft";
  Modelica.Units.SI.AngularVelocity BOP.generator.omega_e "Angular velocity of the e.m.f. rotating frame";
  Modelica.Units.NonSI.AngularVelocity_rpm BOP.generator.shaft_rpm = 
    Modelica.Units.Conversions.to_rpm(BOP.generator.omega_m) "Shaft rotational speed";
  Modelica.Units.SI.Frequency BOP.generator.f "Electrical frequency";
  Modelica.Units.SI.Power BOP.generator.port.W "Active power";
  Modelica.Units.SI.Frequency BOP.generator.port.f "Frequency";
  Modelica.Units.SI.Angle BOP.generator.shaft.phi "Absolute rotation angle of flange";
  Modelica.Units.SI.Torque BOP.generator.shaft.tau "Cut torque in the flange";
  Modelica.Units.SI.Power BOP.port_a_elec.W "Active power";
  Modelica.Units.SI.Frequency BOP.port_a_elec.f "Frequency";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.pump.port_a.m_flow(
    min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.pump.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.pump.port_a.h_outflow(
    start = BOP.pump.h_a_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.pump.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.pump.port_a.C_outflow[0](
    start = fill(1.0, size(BOP.pump.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.pump.port_b.m_flow(
    max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.pump.port_b.p(start = 
    BOP.pump.p_b_start, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.pump.port_b.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.pump.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.pump.port_b.C_outflow[0](
    start = fill(1.0, size(BOP.pump.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Efficiency BOP.pump.eta_is "Isentropic or aerodynamic efficiency";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.pump.state_a.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.pump.state_a.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.pump.state_a.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.pump.state_a.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.pump.state_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.pump.state_b.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.pump.state_b.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.pump.state_b.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.pump.state_b.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.pump.state_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.SI.PressureDifference BOP.pump.dp(start = BOP.pump.p_b_start-
    BOP.pump.p_a_start) "Pressure change";
  Modelica.Units.SI.MassFlowRate BOP.pump.m_flow(start = BOP.pump.m_flow_start) 
    "Mass flow rate";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.pump.dh_ideal(start = 
    100000.0, nominal = 500000.0) "Ideal enthalpy change";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.pump.dh(start = 100000.0,
     nominal = 500000.0) "Actual enthalpy change";
  Modelica.Units.SI.Power BOP.pump.W "Pumping power required";
  Modelica.Units.SI.Power BOP.pump.W_ideal = BOP.pump.dh_ideal*BOP.pump.m_flow 
    "Ideal pumping power required";
  Modelica.Units.SI.Power BOP.pump.Ub "Energy balance";
  Modelica.Units.SI.Pressure BOP.pump.p "Outlet pressure (port_b.p)";
  Modelica.Units.SI.Pressure BOP.pump.p_internal;
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.pump1.port_a.m_flow(
    min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.pump1.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.pump1.port_a.h_outflow(
    start = BOP.pump1.h_a_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.pump1.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.pump1.port_a.C_outflow[0](
    start = fill(1.0, size(BOP.pump1.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.pump1.port_b.m_flow(
    max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.pump1.port_b.p(start = 
    BOP.pump1.p_b_start, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.pump1.port_b.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.pump1.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.pump1.port_b.C_outflow[0](
    start = fill(1.0, size(BOP.pump1.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Efficiency BOP.pump1.eta_is "Isentropic or aerodynamic efficiency";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.pump1.state_a.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.pump1.state_a.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.pump1.state_a.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.pump1.state_a.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.pump1.state_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.pump1.state_b.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.pump1.state_b.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.pump1.state_b.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.pump1.state_b.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.pump1.state_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.SI.PressureDifference BOP.pump1.dp(start = BOP.pump1.p_b_start-
    BOP.pump1.p_a_start) "Pressure change";
  Modelica.Units.SI.MassFlowRate BOP.pump1.m_flow(start = BOP.pump1.m_flow_start)
     "Mass flow rate";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.pump1.dh_ideal(start = 
    100000.0, nominal = 500000.0) "Ideal enthalpy change";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.pump1.dh(start = 100000.0,
     nominal = 500000.0) "Actual enthalpy change";
  Modelica.Units.SI.Power BOP.pump1.W "Pumping power required";
  Modelica.Units.SI.Power BOP.pump1.W_ideal = BOP.pump1.dh_ideal*
    BOP.pump1.m_flow "Ideal pumping power required";
  Modelica.Units.SI.Power BOP.pump1.Ub "Energy balance";
  Modelica.Units.SI.Pressure BOP.pump1.p "Outlet pressure (port_b.p)";
  Modelica.Units.SI.Pressure BOP.pump1.p_internal;
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.OFWH_1.port_a.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.OFWH_1.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.OFWH_1.port_a.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.OFWH_1.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.OFWH_1.port_a.C_outflow[0](
    start = fill(1.0, size(BOP.OFWH_1.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.OFWH_1.port_b.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.OFWH_1.port_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.OFWH_1.port_b.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.OFWH_1.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.OFWH_1.port_b.C_outflow[0](
    start = fill(1.0, size(BOP.OFWH_1.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Volume BOP.OFWH_1.V(min = 0.0) = BOP.OFWH_1.geometry.V 
    "Volume";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    BOP.OFWH_1.medium.p(start = BOP.OFWH_1.p_start, nominal = 100000.0, unit = 
    "Pa", displayUnit = "bar", min = 0.0, stateSelect = StateSelect.prefer) 
    "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    BOP.OFWH_1.medium.Xi[0](start = BOP.OFWH_1.X_start[1:0], unit = "1", min = 
    0.0, max = 1.0) "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    BOP.OFWH_1.medium.h(start = (if  not BOP.OFWH_1.use_T_start then 
    BOP.OFWH_1.h_start else Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11
    (BOP.OFWH_1.p_start, BOP.OFWH_1.T_start, BOP.OFWH_1.X_start[1:0], 0)), 
    unit = "J/kg", stateSelect = StateSelect.prefer) "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density BOP.OFWH_1.medium.d(start = (if 
    BOP.OFWH_1.use_T_start then Modelica.Media.Water.WaterIF97_ph.density_pTX_Unique32
    (BOP.OFWH_1.p_start, BOP.OFWH_1.T_start, BOP.OFWH_1.X_start[1:0]) else 
    Modelica.Media.Water.WaterIF97_ph.density_phX_Unique33(BOP.OFWH_1.p_start, 
    BOP.OFWH_1.h_start, BOP.OFWH_1.X_start[1:0], 0)), nominal = 500.0) 
    "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature BOP.OFWH_1.medium.T(start = (if 
    BOP.OFWH_1.use_T_start then BOP.OFWH_1.T_start else Modelica.Media.Water.WaterIF97_ph.temperature_phX_Unique34
    (BOP.OFWH_1.p_start, BOP.OFWH_1.h_start, BOP.OFWH_1.X_start[1:0], 0)), 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction BOP.OFWH_1.medium.X[1](start = 
    BOP.OFWH_1.X_start) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy BOP.OFWH_1.medium.u 
    "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity BOP.OFWH_1.medium.R_s 
    "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass BOP.OFWH_1.medium.MM 
    "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.OFWH_1.medium.state.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.OFWH_1.medium.state.h(
    start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.OFWH_1.medium.state.d(start = 150,
     nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.OFWH_1.medium.state.T(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.OFWH_1.medium.state.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC BOP.OFWH_1.medium.T_degC = 
    Modelica.Units.Conversions.to_degC(BOP.OFWH_1.medium.T) "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar BOP.OFWH_1.medium.p_bar = Modelica.Units.Conversions.to_bar
    (BOP.OFWH_1.medium.p) "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.OFWH_1.medium.sat.psat(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature BOP.OFWH_1.medium.sat.Tsat(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer BOP.OFWH_1.medium.phase(start = 1, fixed = false, min = 0.0, max = 2.0)
     "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Units.SI.Mass BOP.OFWH_1.m "Mass";
  Modelica.Units.SI.InternalEnergy BOP.OFWH_1.U "Internal energy";
  Modelica.Units.SI.Mass BOP.OFWH_1.mXi[0] "Species mass";
  TRANSFORM.Units.ExtraPropertyExtrinsic BOP.OFWH_1.mC[0] "Trace substance extrinsic value";
  TRANSFORM.Units.ExtraPropertyExtrinsic BOP.OFWH_1.mC_scaled[0] 
    "Scaled trace substance for improved numerical stability";
  TRANSFORM.Units.ExtraProperty BOP.OFWH_1.C[0](start = BOP.OFWH_1.C_start, 
    stateSelect = StateSelect.prefer) "Trace substance mass-specific value";
  Modelica.Units.SI.MassFlowRate BOP.OFWH_1.mb = BOP.OFWH_1.port_a.m_flow+
    BOP.OFWH_1.port_b.m_flow "Mass flow rate source/sinks within volumes";
  Modelica.Units.SI.HeatFlowRate BOP.OFWH_1.Ub = BOP.OFWH_1.port_a.m_flow*
    actualStream(BOP.OFWH_1.port_a.h_outflow)+BOP.OFWH_1.port_b.m_flow*
    actualStream(BOP.OFWH_1.port_b.h_outflow)+BOP.OFWH_1.Q_flow_internal+
    BOP.OFWH_1.Q_gen "Energy source/sinks within volumes (e.g., ohmic heating, external convection)";
  Modelica.Units.SI.MassFlowRate BOP.OFWH_1.mXib[0] = BOP.OFWH_1.port_a.m_flow*
    actualStream(BOP.OFWH_1.port_a.Xi_outflow)+BOP.OFWH_1.port_b.m_flow*
    actualStream(BOP.OFWH_1.port_b.Xi_outflow) "Species mass flow rates source/sinks within volumes";
  TRANSFORM.Units.ExtraPropertyFlowRate BOP.OFWH_1.mCb[0] = BOP.OFWH_1.port_a.m_flow
    *actualStream(BOP.OFWH_1.port_a.C_outflow)+BOP.OFWH_1.port_b.m_flow*
    actualStream(BOP.OFWH_1.port_b.C_outflow)+BOP.OFWH_1.mC_flow_internal+
    BOP.OFWH_1.mC_gen "Trace flow rate source/sinks within volumes (e.g., chemical reactions, external convection)";
  Modelica.Units.SI.Volume BOP.OFWH_1.geometry.V = 2 "Volume";
  Modelica.Units.SI.Angle BOP.OFWH_1.geometry.angle(min = -1.5807963267948966, 
    max = 1.5807963267948966) = 0.0 "Vertical angle from the horizontal (-pi/2 <= x <= pi/2)";
  Modelica.Units.SI.Length BOP.OFWH_1.geometry.dheight = 0*sin(BOP.OFWH_1.geometry.angle)
     "Height(port_b) - Height(port_a)";
  Modelica.Units.SI.Length BOP.OFWH_1.geometry.height_a = 0 "Elevation at port_a: Reference value only. No impact on calculations.";
  Modelica.Units.SI.Length BOP.OFWH_1.geometry.height_b = BOP.OFWH_1.geometry.height_a
    +BOP.OFWH_1.geometry.dheight "Elevation at port_b: Reference value only. No impact on calculations.";
  Modelica.Units.SI.Acceleration BOP.OFWH_1.g_n = 9.80665 "Gravitational acceleration";
  Modelica.Units.SI.HeatFlowRate BOP.OFWH_1.Q_gen = 0 "Internal heat generation";
  TRANSFORM.Units.ExtraPropertyFlowRate BOP.OFWH_1.mC_gen[0] = fill(0, 0) 
    "Internal trace mass generation";
  Modelica.Units.SI.HeatFlowRate BOP.OFWH_1.Q_flow_internal;
  TRANSFORM.Units.ExtraPropertyFlowRate BOP.OFWH_1.mC_flow_internal[0];
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.HPT_bypass_valve.port_a.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.HPT_bypass_valve.port_a.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.HPT_bypass_valve.port_a.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.HPT_bypass_valve.port_a.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.HPT_bypass_valve.port_a.C_outflow
    [0](start = fill(1.0, size(BOP.HPT_bypass_valve.port_a.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.HPT_bypass_valve.port_b.m_flow
    (max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.HPT_bypass_valve.port_b.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.HPT_bypass_valve.port_b.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.HPT_bypass_valve.port_b.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.HPT_bypass_valve.port_b.C_outflow
    [0](start = fill(1.0, size(BOP.HPT_bypass_valve.port_b.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.HPT_bypass_valve.m_flow
    (start = BOP.HPT_bypass_valve.m_flow_start, min = -1E+60) "Mass flow rate in design flow direction";
  Modelica.Units.SI.Pressure BOP.HPT_bypass_valve.dp(start = BOP.HPT_bypass_valve.dp_start)
     "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
  Modelica.Units.SI.VolumeFlowRate BOP.HPT_bypass_valve.V_flow = 
    BOP.HPT_bypass_valve.m_flow/Modelica.Fluid.Utilities.regStep(
    BOP.HPT_bypass_valve.m_flow, Modelica.Media.Water.WaterIF97_ph.density_Unique30
    (
    BOP.HPT_bypass_valve.state_a), Modelica.Media.Water.WaterIF97_ph.density_Unique30
    (
    BOP.HPT_bypass_valve.state_b), BOP.HPT_bypass_valve.m_flow_small) 
    "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";
  Modelica.Media.Interfaces.Types.Temperature BOP.HPT_bypass_valve.port_a_T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = 
    Modelica.Fluid.Utilities.regStep(BOP.HPT_bypass_valve.port_a.m_flow, 
    Modelica.Media.Water.WaterIF97_ph.temperature_Unique35(
    BOP.HPT_bypass_valve.state_a), Modelica.Media.Water.WaterIF97_ph.temperature_Unique35
    (
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(BOP.HPT_bypass_valve.port_a.p,
       BOP.HPT_bypass_valve.port_a.h_outflow, BOP.HPT_bypass_valve.port_a.Xi_outflow,
       0, 0)), BOP.HPT_bypass_valve.m_flow_small) "Temperature close to port_a, if show_T = true";
  Modelica.Media.Interfaces.Types.Temperature BOP.HPT_bypass_valve.port_b_T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = 
    Modelica.Fluid.Utilities.regStep(BOP.HPT_bypass_valve.port_b.m_flow, 
    Modelica.Media.Water.WaterIF97_ph.temperature_Unique35(
    BOP.HPT_bypass_valve.state_b), Modelica.Media.Water.WaterIF97_ph.temperature_Unique35
    (
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(BOP.HPT_bypass_valve.port_b.p,
       BOP.HPT_bypass_valve.port_b.h_outflow, BOP.HPT_bypass_valve.port_b.Xi_outflow,
       0, 0)), BOP.HPT_bypass_valve.m_flow_small) "Temperature close to port_b, if show_T = true";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.HPT_bypass_valve.state_a.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.HPT_bypass_valve.state_a.h
    (start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.HPT_bypass_valve.state_a.d(
    start = 150, nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.HPT_bypass_valve.state_a.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.HPT_bypass_valve.state_a.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.HPT_bypass_valve.state_b.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.HPT_bypass_valve.state_b.h
    (start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.HPT_bypass_valve.state_b.d(
    start = 150, nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.HPT_bypass_valve.state_b.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.HPT_bypass_valve.state_b.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Blocks.Interfaces.RealInput BOP.HPT_bypass_valve.opening(min = 0.0, 
    max = 1.0) "=1: completely open, =0: completely closed";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.OFWH_2.port_a.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.OFWH_2.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.OFWH_2.port_a.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.OFWH_2.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.OFWH_2.port_a.C_outflow[0](
    start = fill(1.0, size(BOP.OFWH_2.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.OFWH_2.port_b.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.OFWH_2.port_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.OFWH_2.port_b.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.OFWH_2.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.OFWH_2.port_b.C_outflow[0](
    start = fill(1.0, size(BOP.OFWH_2.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Volume BOP.OFWH_2.V(min = 0.0) = BOP.OFWH_2.geometry.V 
    "Volume";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    BOP.OFWH_2.medium.p(start = BOP.OFWH_2.p_start, nominal = 100000.0, unit = 
    "Pa", displayUnit = "bar", min = 0.0, stateSelect = StateSelect.prefer) 
    "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    BOP.OFWH_2.medium.Xi[0](start = BOP.OFWH_2.X_start[1:0], unit = "1", min = 
    0.0, max = 1.0) "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    BOP.OFWH_2.medium.h(start = (if  not BOP.OFWH_2.use_T_start then 
    BOP.OFWH_2.h_start else Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11
    (BOP.OFWH_2.p_start, BOP.OFWH_2.T_start, BOP.OFWH_2.X_start[1:0], 0)), 
    unit = "J/kg", stateSelect = StateSelect.prefer) "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density BOP.OFWH_2.medium.d(start = (if 
    BOP.OFWH_2.use_T_start then Modelica.Media.Water.WaterIF97_ph.density_pTX_Unique32
    (BOP.OFWH_2.p_start, BOP.OFWH_2.T_start, BOP.OFWH_2.X_start[1:0]) else 
    Modelica.Media.Water.WaterIF97_ph.density_phX_Unique33(BOP.OFWH_2.p_start, 
    BOP.OFWH_2.h_start, BOP.OFWH_2.X_start[1:0], 0)), nominal = 500.0) 
    "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature BOP.OFWH_2.medium.T(start = (if 
    BOP.OFWH_2.use_T_start then BOP.OFWH_2.T_start else Modelica.Media.Water.WaterIF97_ph.temperature_phX_Unique34
    (BOP.OFWH_2.p_start, BOP.OFWH_2.h_start, BOP.OFWH_2.X_start[1:0], 0)), 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction BOP.OFWH_2.medium.X[1](start = 
    BOP.OFWH_2.X_start) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy BOP.OFWH_2.medium.u 
    "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity BOP.OFWH_2.medium.R_s 
    "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass BOP.OFWH_2.medium.MM 
    "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.OFWH_2.medium.state.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.OFWH_2.medium.state.h(
    start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.OFWH_2.medium.state.d(start = 150,
     nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.OFWH_2.medium.state.T(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.OFWH_2.medium.state.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC BOP.OFWH_2.medium.T_degC = 
    Modelica.Units.Conversions.to_degC(BOP.OFWH_2.medium.T) "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar BOP.OFWH_2.medium.p_bar = Modelica.Units.Conversions.to_bar
    (BOP.OFWH_2.medium.p) "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.OFWH_2.medium.sat.psat(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature BOP.OFWH_2.medium.sat.Tsat(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer BOP.OFWH_2.medium.phase(start = 1, fixed = false, min = 0.0, max = 2.0)
     "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Units.SI.Mass BOP.OFWH_2.m "Mass";
  Modelica.Units.SI.InternalEnergy BOP.OFWH_2.U "Internal energy";
  Modelica.Units.SI.Mass BOP.OFWH_2.mXi[0] "Species mass";
  TRANSFORM.Units.ExtraPropertyExtrinsic BOP.OFWH_2.mC[0] "Trace substance extrinsic value";
  TRANSFORM.Units.ExtraPropertyExtrinsic BOP.OFWH_2.mC_scaled[0] 
    "Scaled trace substance for improved numerical stability";
  TRANSFORM.Units.ExtraProperty BOP.OFWH_2.C[0](start = BOP.OFWH_2.C_start, 
    stateSelect = StateSelect.prefer) "Trace substance mass-specific value";
  Modelica.Units.SI.MassFlowRate BOP.OFWH_2.mb = BOP.OFWH_2.port_a.m_flow+
    BOP.OFWH_2.port_b.m_flow "Mass flow rate source/sinks within volumes";
  Modelica.Units.SI.HeatFlowRate BOP.OFWH_2.Ub = BOP.OFWH_2.port_a.m_flow*
    actualStream(BOP.OFWH_2.port_a.h_outflow)+BOP.OFWH_2.port_b.m_flow*
    actualStream(BOP.OFWH_2.port_b.h_outflow)+BOP.OFWH_2.Q_flow_internal+
    BOP.OFWH_2.Q_gen "Energy source/sinks within volumes (e.g., ohmic heating, external convection)";
  Modelica.Units.SI.MassFlowRate BOP.OFWH_2.mXib[0] = BOP.OFWH_2.port_a.m_flow*
    actualStream(BOP.OFWH_2.port_a.Xi_outflow)+BOP.OFWH_2.port_b.m_flow*
    actualStream(BOP.OFWH_2.port_b.Xi_outflow) "Species mass flow rates source/sinks within volumes";
  TRANSFORM.Units.ExtraPropertyFlowRate BOP.OFWH_2.mCb[0] = BOP.OFWH_2.port_a.m_flow
    *actualStream(BOP.OFWH_2.port_a.C_outflow)+BOP.OFWH_2.port_b.m_flow*
    actualStream(BOP.OFWH_2.port_b.C_outflow)+BOP.OFWH_2.mC_flow_internal+
    BOP.OFWH_2.mC_gen "Trace flow rate source/sinks within volumes (e.g., chemical reactions, external convection)";
  Modelica.Units.SI.Volume BOP.OFWH_2.geometry.V = 2 "Volume";
  Modelica.Units.SI.Angle BOP.OFWH_2.geometry.angle(min = -1.5807963267948966, 
    max = 1.5807963267948966) = 0.0 "Vertical angle from the horizontal (-pi/2 <= x <= pi/2)";
  Modelica.Units.SI.Length BOP.OFWH_2.geometry.dheight = 0*sin(BOP.OFWH_2.geometry.angle)
     "Height(port_b) - Height(port_a)";
  Modelica.Units.SI.Length BOP.OFWH_2.geometry.height_a = 0 "Elevation at port_a: Reference value only. No impact on calculations.";
  Modelica.Units.SI.Length BOP.OFWH_2.geometry.height_b = BOP.OFWH_2.geometry.height_a
    +BOP.OFWH_2.geometry.dheight "Elevation at port_b: Reference value only. No impact on calculations.";
  Modelica.Units.SI.Acceleration BOP.OFWH_2.g_n = 9.80665 "Gravitational acceleration";
  Modelica.Units.SI.HeatFlowRate BOP.OFWH_2.Q_gen = 0 "Internal heat generation";
  TRANSFORM.Units.ExtraPropertyFlowRate BOP.OFWH_2.mC_gen[0] = fill(0, 0) 
    "Internal trace mass generation";
  Modelica.Units.SI.HeatFlowRate BOP.OFWH_2.Q_flow_internal;
  TRANSFORM.Units.ExtraPropertyFlowRate BOP.OFWH_2.mC_flow_internal[0];
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.FWCP.port_a.m_flow(
    min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.FWCP.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.FWCP.port_a.h_outflow(
    start = BOP.FWCP.h_a_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.FWCP.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.FWCP.port_a.C_outflow[0](
    start = fill(1.0, size(BOP.FWCP.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.FWCP.port_b.m_flow(
    max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.FWCP.port_b.p(start = 
    BOP.FWCP.p_b_start, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.FWCP.port_b.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.FWCP.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.FWCP.port_b.C_outflow[0](
    start = fill(1.0, size(BOP.FWCP.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Efficiency BOP.FWCP.eta_is "Isentropic or aerodynamic efficiency";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.FWCP.state_a.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.FWCP.state_a.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.FWCP.state_a.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.FWCP.state_a.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.FWCP.state_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.FWCP.state_b.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.FWCP.state_b.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.FWCP.state_b.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.FWCP.state_b.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.FWCP.state_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.SI.PressureDifference BOP.FWCP.dp(start = BOP.FWCP.p_b_start-
    BOP.FWCP.p_a_start) "Pressure change";
  Modelica.Units.SI.MassFlowRate BOP.FWCP.m_flow(start = BOP.FWCP.m_flow_start) 
    "Mass flow rate";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.FWCP.dh_ideal(start = 
    100000.0, nominal = 500000.0) "Ideal enthalpy change";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.FWCP.dh(start = 100000.0,
     nominal = 500000.0) "Actual enthalpy change";
  Modelica.Units.SI.Power BOP.FWCP.W "Pumping power required";
  Modelica.Units.SI.Power BOP.FWCP.W_ideal = BOP.FWCP.dh_ideal*BOP.FWCP.m_flow 
    "Ideal pumping power required";
  Modelica.Units.SI.Power BOP.FWCP.Ub "Energy balance";
  Modelica.Units.SI.MassFlowRate BOP.FWCP.m_flow_internal;
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.TCV.port_a.m_flow(
    min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.TCV.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.TCV.port_a.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.TCV.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.TCV.port_a.C_outflow[0](
    start = fill(1.0, size(BOP.TCV.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.TCV.port_b.m_flow(
    max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.TCV.port_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.TCV.port_b.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.TCV.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.TCV.port_b.C_outflow[0](
    start = fill(1.0, size(BOP.TCV.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.TCV.m_flow(start = 
    BOP.TCV.m_flow_start, min = -1E+60) "Mass flow rate in design flow direction";
  Modelica.Units.SI.Pressure BOP.TCV.dp(start = BOP.TCV.dp_start) 
    "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
  Modelica.Units.SI.VolumeFlowRate BOP.TCV.V_flow = BOP.TCV.m_flow/
    Modelica.Fluid.Utilities.regStep(BOP.TCV.m_flow, Modelica.Media.Water.WaterIF97_ph.density_Unique30
    (
    BOP.TCV.state_a), Modelica.Media.Water.WaterIF97_ph.density_Unique30(
    BOP.TCV.state_b), BOP.TCV.m_flow_small) "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";
  Modelica.Media.Interfaces.Types.Temperature BOP.TCV.port_a_T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) = Modelica.Fluid.Utilities.regStep
    (BOP.TCV.port_a.m_flow, Modelica.Media.Water.WaterIF97_ph.temperature_Unique35
    (
    BOP.TCV.state_a), Modelica.Media.Water.WaterIF97_ph.temperature_Unique35(
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(BOP.TCV.port_a.p, 
      BOP.TCV.port_a.h_outflow, BOP.TCV.port_a.Xi_outflow, 0, 0)), 
    BOP.TCV.m_flow_small) "Temperature close to port_a, if show_T = true";
  Modelica.Media.Interfaces.Types.Temperature BOP.TCV.port_b_T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) = Modelica.Fluid.Utilities.regStep
    (BOP.TCV.port_b.m_flow, Modelica.Media.Water.WaterIF97_ph.temperature_Unique35
    (
    BOP.TCV.state_b), Modelica.Media.Water.WaterIF97_ph.temperature_Unique35(
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(BOP.TCV.port_b.p, 
      BOP.TCV.port_b.h_outflow, BOP.TCV.port_b.Xi_outflow, 0, 0)), 
    BOP.TCV.m_flow_small) "Temperature close to port_b, if show_T = true";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.TCV.state_a.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.TCV.state_a.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.TCV.state_a.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.TCV.state_a.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.TCV.state_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.TCV.state_b.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.TCV.state_b.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.TCV.state_b.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.TCV.state_b.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.TCV.state_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Blocks.Interfaces.RealInput BOP.TCV.opening(min = 0.0, max = 1.0) 
    "=1: completely open, =0: completely closed";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.Feed_T.port.m_flow(
    min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.Feed_T.port.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.Feed_T.port.h_outflow(
    start = 84013.0581525969, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.Feed_T.port.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.Feed_T.port.C_outflow[0](
    start = fill(1.0, size(BOP.Feed_T.port.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Real BOP.Feed_T.var = BOP.Feed_T.T "Variable to be converted";
  Real BOP.Feed_T.y = BOP.Feed_T.iconUnit_Unique39(BOP.Feed_T.var) 
    "Icon display";
  Modelica.Blocks.Interfaces.RealOutput BOP.Feed_T.T(unit = "K", displayUnit = 
    "degC", min = 0.0) "Temperature in port medium";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.Steam_T.port.m_flow(
    min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.Steam_T.port.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.Steam_T.port.h_outflow(
    start = 84013.0581525969, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.Steam_T.port.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.Steam_T.port.C_outflow[0](
    start = fill(1.0, size(BOP.Steam_T.port.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Real BOP.Steam_T.var = BOP.Steam_T.T "Variable to be converted";
  Real BOP.Steam_T.y = BOP.Steam_T.iconUnit_Unique40(BOP.Steam_T.var) 
    "Icon display";
  Modelica.Blocks.Interfaces.RealOutput BOP.Steam_T.T(unit = "K", displayUnit = 
    "degC", min = 0.0) "Temperature in port medium";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.sensor_p.port.m_flow(
    min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.sensor_p.port.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.sensor_p.port.h_outflow(
    start = 84013.0581525969, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.sensor_p.port.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.sensor_p.port.C_outflow[0](
    start = fill(1.0, size(BOP.sensor_p.port.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Real BOP.sensor_p.var = BOP.sensor_p.p "Variable to be converted";
  Real BOP.sensor_p.y = BOP.sensor_p.iconUnit_Unique41(BOP.sensor_p.var) 
    "Icon display";
  Modelica.Blocks.Interfaces.RealOutput BOP.sensor_p.p(unit = "Pa", 
    displayUnit = "bar", min = 0.0) "Pressure at port";
  Real BOP.sensorW.var = BOP.sensorW.W "Variable to be converted";
  Real BOP.sensorW.y = BOP.sensorW.iconUnit_Unique42(BOP.sensorW.var) 
    "Icon display";
  Modelica.Units.SI.Power BOP.sensorW.port_a.W "Active power";
  Modelica.Units.SI.Frequency BOP.sensorW.port_a.f "Frequency";
  Modelica.Units.SI.Power BOP.sensorW.port_b.W "Active power";
  Modelica.Units.SI.Frequency BOP.sensorW.port_b.f "Frequency";
  Modelica.Blocks.Interfaces.RealOutput BOP.sensorW.W "Power flowing from port_a to port_b";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.port_a_cond.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.port_a_cond.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.port_a_cond.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.port_a_cond.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.port_a_cond.C_outflow[0](
    start = fill(1.0, size(BOP.port_a_cond.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.delay2.port_a.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2.port_a.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2.port_a.C_outflow[0](
    start = fill(1.0, size(BOP.delay2.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.delay2.port_b.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2.port_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2.port_b.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2.port_b.C_outflow[0](
    start = fill(1.0, size(BOP.delay2.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.delay2.sensor_p.port.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2.sensor_p.port.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2.sensor_p.port.h_outflow
    (start = 84013.0581525969, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2.sensor_p.port.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2.sensor_p.port.C_outflow
    [0](start = fill(1.0, size(BOP.delay2.sensor_p.port.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Real BOP.delay2.sensor_p.var = BOP.delay2.sensor_p.p "Variable to be converted";
  Real BOP.delay2.sensor_p.y = BOP.delay2.sensor_p.iconUnit_Unique43(
    BOP.delay2.sensor_p.var) "Icon display";
  Modelica.Blocks.Interfaces.RealOutput BOP.delay2.sensor_p.p(unit = "Pa", 
    displayUnit = "bar", min = 0.0) "Pressure at port";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.delay2.sensor_m_flow.port_a.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2.sensor_m_flow.port_a.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2.sensor_m_flow.port_a.h_outflow
    (start = BOP.delay2.sensor_m_flow.h_start, nominal = 500000.0) 
    "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2.sensor_m_flow.port_a.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2.sensor_m_flow.port_a.C_outflow
    [0](start = fill(1.0, size(BOP.delay2.sensor_m_flow.port_a.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.delay2.sensor_m_flow.port_b.m_flow
    (max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2.sensor_m_flow.port_b.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2.sensor_m_flow.port_b.h_outflow
    (start = BOP.delay2.sensor_m_flow.h_start, nominal = 500000.0) 
    "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2.sensor_m_flow.port_b.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2.sensor_m_flow.port_b.C_outflow
    [0](start = fill(1.0, size(BOP.delay2.sensor_m_flow.port_b.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Real BOP.delay2.sensor_m_flow.var = BOP.delay2.sensor_m_flow.m_flow 
    "Variable to be converted";
  Real BOP.delay2.sensor_m_flow.y = BOP.delay2.sensor_m_flow.iconUnit_Unique44(
    BOP.delay2.sensor_m_flow.var) "Icon display";
  Modelica.Blocks.Interfaces.RealOutput BOP.delay2.sensor_m_flow.m_flow(unit = 
    "kg/s") "Mass flow rate from port_a to port_b";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.delay2.sensor_h.port.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2.sensor_h.port.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2.sensor_h.port.h_outflow
    (start = 84013.0581525969, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2.sensor_h.port.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2.sensor_h.port.C_outflow
    [0](start = fill(1.0, size(BOP.delay2.sensor_h.port.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Real BOP.delay2.sensor_h.var = BOP.delay2.sensor_h.h_out "Variable to be converted";
  Real BOP.delay2.sensor_h.y = BOP.delay2.sensor_h.iconUnit_Unique45(
    BOP.delay2.sensor_h.var) "Icon display";
  Modelica.Blocks.Interfaces.RealOutput BOP.delay2.sensor_h.h_out(unit = "J/kg")
     "Specific enthalpy in port medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    BOP.delay2.boundary.medium.p(nominal = 100000.0, unit = "Pa", displayUnit = 
    "bar", min = 0.0) "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    BOP.delay2.boundary.medium.Xi[0](start = {}, unit = "1", min = 0.0, max = 
    1.0) "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    BOP.delay2.boundary.medium.h(unit = "J/kg") "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density BOP.delay2.boundary.medium.d(start = 150,
     nominal = 500.0) "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature BOP.delay2.boundary.medium.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2.boundary.medium.X[1](
    start = {1.0}) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy BOP.delay2.boundary.medium.u
     "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity BOP.delay2.boundary.medium.R_s
     "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass BOP.delay2.boundary.medium.MM 
    "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.delay2.boundary.medium.state.phase
     "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2.boundary.medium.state.h
    (start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.delay2.boundary.medium.state.d(
    start = 150, nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.delay2.boundary.medium.state.T
    (start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2.boundary.medium.state.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC BOP.delay2.boundary.medium.T_degC = 
    Modelica.Units.Conversions.to_degC(BOP.delay2.boundary.medium.T) 
    "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar BOP.delay2.boundary.medium.p_bar = 
    Modelica.Units.Conversions.to_bar(BOP.delay2.boundary.medium.p) 
    "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2.boundary.medium.sat.psat
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature BOP.delay2.boundary.medium.sat.Tsat
    (start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer BOP.delay2.boundary.medium.phase(start = 1, fixed = false, min = 0.0, 
    max = 2.0) "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.delay2.boundary.ports[1].m_flow
    (min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2.boundary.ports[1].p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2.boundary.ports[1].h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2.boundary.ports[1].Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2.boundary.ports[1].C_outflow
    [0](start = fill(1.0, size(BOP.delay2.boundary.ports[1].C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2.boundary.p_in "Prescribed boundary pressure";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2.boundary.p_in_internal 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2.boundary.h_in_internal 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2.boundary.X_in_internal[1] 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2.boundary.C_in_internal[0] 
    "Needed to connect to conditional connector";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    BOP.delay2.boundary1.medium.p(nominal = 100000.0, unit = "Pa", 
    displayUnit = "bar", min = 0.0) "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    BOP.delay2.boundary1.medium.Xi[0](start = {}, unit = "1", min = 0.0, max = 
    1.0) "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    BOP.delay2.boundary1.medium.h(unit = "J/kg") "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density BOP.delay2.boundary1.medium.d(start = 150,
     nominal = 500.0) "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature BOP.delay2.boundary1.medium.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2.boundary1.medium.X[1](
    start = {1.0}) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy BOP.delay2.boundary1.medium.u
     "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity BOP.delay2.boundary1.medium.R_s
     "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass BOP.delay2.boundary1.medium.MM 
    "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.delay2.boundary1.medium.state.phase
     "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2.boundary1.medium.state.h
    (start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.delay2.boundary1.medium.state.d(
    start = 150, nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.delay2.boundary1.medium.state.T
    (start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2.boundary1.medium.state.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC BOP.delay2.boundary1.medium.T_degC = 
    Modelica.Units.Conversions.to_degC(BOP.delay2.boundary1.medium.T) 
    "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar BOP.delay2.boundary1.medium.p_bar = 
    Modelica.Units.Conversions.to_bar(BOP.delay2.boundary1.medium.p) 
    "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2.boundary1.medium.sat.psat
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature BOP.delay2.boundary1.medium.sat.Tsat
    (start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer BOP.delay2.boundary1.medium.phase(start = 1, fixed = false, min = 0.0,
     max = 2.0) "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.delay2.boundary1.ports[1].m_flow
    (min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2.boundary1.ports[1].p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2.boundary1.ports[1].h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2.boundary1.ports[1].Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2.boundary1.ports[1].C_outflow
    [0](start = fill(1.0, size(BOP.delay2.boundary1.ports[1].C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2.boundary1.m_flow_in 
    "Prescribed mass flow rate";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2.boundary1.h_in 
    "Prescribed fluid specific enthalpy";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2.boundary1.m_flow_in_internal 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2.boundary1.h_in_internal 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2.boundary1.X_in_internal[1] 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2.boundary1.C_in_internal[0] 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2.limiter1.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.delay2.limiter1.y "Connector of Real output signal";
  Real BOP.delay2.limiter1.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2.limiter2.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.delay2.limiter2.y "Connector of Real output signal";
  Real BOP.delay2.limiter2.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2.limiter.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.delay2.limiter.y "Connector of Real output signal";
  Real BOP.delay2.limiter.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.delay2_2.port_a.m_flow
     "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2_2.port_a.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2_2.port_a.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2_2.port_a.Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2_2.port_a.C_outflow[0]
    (start = fill(1.0, size(BOP.delay2_2.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.delay2_2.port_b.m_flow
     "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2_2.port_b.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2_2.port_b.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2_2.port_b.Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2_2.port_b.C_outflow[0]
    (start = fill(1.0, size(BOP.delay2_2.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.delay2_2.sensor_p.port.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2_2.sensor_p.port.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2_2.sensor_p.port.h_outflow
    (start = 84013.0581525969, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2_2.sensor_p.port.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2_2.sensor_p.port.C_outflow
    [0](start = fill(1.0, size(BOP.delay2_2.sensor_p.port.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Real BOP.delay2_2.sensor_p.var = BOP.delay2_2.sensor_p.p "Variable to be converted";
  Real BOP.delay2_2.sensor_p.y = BOP.delay2_2.sensor_p.iconUnit_Unique46(
    BOP.delay2_2.sensor_p.var) "Icon display";
  Modelica.Blocks.Interfaces.RealOutput BOP.delay2_2.sensor_p.p(unit = "Pa", 
    displayUnit = "bar", min = 0.0) "Pressure at port";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.delay2_2.sensor_m_flow.port_a.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2_2.sensor_m_flow.port_a.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2_2.sensor_m_flow.port_a.h_outflow
    (start = BOP.delay2_2.sensor_m_flow.h_start, nominal = 500000.0) 
    "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2_2.sensor_m_flow.port_a.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2_2.sensor_m_flow.port_a.C_outflow
    [0](start = fill(1.0, size(BOP.delay2_2.sensor_m_flow.port_a.C_outflow, 1)))
     "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.delay2_2.sensor_m_flow.port_b.m_flow
    (max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2_2.sensor_m_flow.port_b.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2_2.sensor_m_flow.port_b.h_outflow
    (start = BOP.delay2_2.sensor_m_flow.h_start, nominal = 500000.0) 
    "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2_2.sensor_m_flow.port_b.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2_2.sensor_m_flow.port_b.C_outflow
    [0](start = fill(1.0, size(BOP.delay2_2.sensor_m_flow.port_b.C_outflow, 1)))
     "Properties c_i/m close to the connection point if m_flow < 0";
  Real BOP.delay2_2.sensor_m_flow.var = BOP.delay2_2.sensor_m_flow.m_flow 
    "Variable to be converted";
  Real BOP.delay2_2.sensor_m_flow.y = BOP.delay2_2.sensor_m_flow.iconUnit_Unique47
    (BOP.delay2_2.sensor_m_flow.var) "Icon display";
  Modelica.Blocks.Interfaces.RealOutput BOP.delay2_2.sensor_m_flow.m_flow(
    unit = "kg/s") "Mass flow rate from port_a to port_b";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.delay2_2.sensor_h.port.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2_2.sensor_h.port.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2_2.sensor_h.port.h_outflow
    (start = 84013.0581525969, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2_2.sensor_h.port.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2_2.sensor_h.port.C_outflow
    [0](start = fill(1.0, size(BOP.delay2_2.sensor_h.port.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Real BOP.delay2_2.sensor_h.var = BOP.delay2_2.sensor_h.h_out "Variable to be converted";
  Real BOP.delay2_2.sensor_h.y = BOP.delay2_2.sensor_h.iconUnit_Unique48(
    BOP.delay2_2.sensor_h.var) "Icon display";
  Modelica.Blocks.Interfaces.RealOutput BOP.delay2_2.sensor_h.h_out(unit = 
    "J/kg") "Specific enthalpy in port medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    BOP.delay2_2.boundary.medium.p(nominal = 100000.0, unit = "Pa", 
    displayUnit = "bar", min = 0.0) "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    BOP.delay2_2.boundary.medium.Xi[0](start = {}, unit = "1", min = 0.0, max = 
    1.0) "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    BOP.delay2_2.boundary.medium.h(unit = "J/kg") "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density BOP.delay2_2.boundary.medium.d(
    start = 150, nominal = 500.0) "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature BOP.delay2_2.boundary.medium.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2_2.boundary.medium.X[1]
    (start = {1.0}) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy BOP.delay2_2.boundary.medium.u
     "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity BOP.delay2_2.boundary.medium.R_s
     "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass BOP.delay2_2.boundary.medium.MM 
    "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.delay2_2.boundary.medium.state.phase
     "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2_2.boundary.medium.state.h
    (start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.delay2_2.boundary.medium.state.d(
    start = 150, nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.delay2_2.boundary.medium.state.T
    (start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2_2.boundary.medium.state.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC BOP.delay2_2.boundary.medium.T_degC = 
    Modelica.Units.Conversions.to_degC(BOP.delay2_2.boundary.medium.T) 
    "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar BOP.delay2_2.boundary.medium.p_bar = 
    Modelica.Units.Conversions.to_bar(BOP.delay2_2.boundary.medium.p) 
    "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2_2.boundary.medium.sat.psat
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature BOP.delay2_2.boundary.medium.sat.Tsat
    (start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer BOP.delay2_2.boundary.medium.phase(start = 1, fixed = false, min = 0.0,
     max = 2.0) "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.delay2_2.boundary.ports[1].m_flow
    (min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2_2.boundary.ports[1].p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2_2.boundary.ports[1].h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2_2.boundary.ports[1].Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2_2.boundary.ports[1].C_outflow
    [0](start = fill(1.0, size(BOP.delay2_2.boundary.ports[1].C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2_2.boundary.p_in 
    "Prescribed boundary pressure";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2_2.boundary.p_in_internal 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2_2.boundary.h_in_internal 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2_2.boundary.X_in_internal[1] 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2_2.boundary.C_in_internal[0] 
    "Needed to connect to conditional connector";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    BOP.delay2_2.boundary1.medium.p(nominal = 100000.0, unit = "Pa", 
    displayUnit = "bar", min = 0.0) "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    BOP.delay2_2.boundary1.medium.Xi[0](start = {}, unit = "1", min = 0.0, 
    max = 1.0) "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    BOP.delay2_2.boundary1.medium.h(unit = "J/kg") "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density BOP.delay2_2.boundary1.medium.d(
    start = 150, nominal = 500.0) "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature BOP.delay2_2.boundary1.medium.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2_2.boundary1.medium.X[1]
    (start = {1.0}) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy BOP.delay2_2.boundary1.medium.u
     "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity BOP.delay2_2.boundary1.medium.R_s
     "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass BOP.delay2_2.boundary1.medium.MM 
    "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase BOP.delay2_2.boundary1.medium.state.phase
     "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2_2.boundary1.medium.state.h
    (start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density BOP.delay2_2.boundary1.medium.state.d(
    start = 150, nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature BOP.delay2_2.boundary1.medium.state.T
    (start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2_2.boundary1.medium.state.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC BOP.delay2_2.boundary1.medium.T_degC = 
    Modelica.Units.Conversions.to_degC(BOP.delay2_2.boundary1.medium.T) 
    "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar BOP.delay2_2.boundary1.medium.p_bar = 
    Modelica.Units.Conversions.to_bar(BOP.delay2_2.boundary1.medium.p) 
    "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2_2.boundary1.medium.sat.psat
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature BOP.delay2_2.boundary1.medium.sat.Tsat
    (start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer BOP.delay2_2.boundary1.medium.phase(start = 1, fixed = false, min = 
    0.0, max = 2.0) "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.delay2_2.boundary1.ports[1].m_flow
    (min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.delay2_2.boundary1.ports[1].p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.delay2_2.boundary1.ports[1].h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.delay2_2.boundary1.ports[1].Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.delay2_2.boundary1.ports[1].C_outflow
    [0](start = fill(1.0, size(BOP.delay2_2.boundary1.ports[1].C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2_2.boundary1.m_flow_in 
    "Prescribed mass flow rate";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2_2.boundary1.h_in 
    "Prescribed fluid specific enthalpy";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2_2.boundary1.m_flow_in_internal
     "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2_2.boundary1.h_in_internal 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2_2.boundary1.X_in_internal[1] 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2_2.boundary1.C_in_internal[0] 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2_2.limiter1.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.delay2_2.limiter1.y "Connector of Real output signal";
  Real BOP.delay2_2.limiter1.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2_2.limiter2.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.delay2_2.limiter2.y "Connector of Real output signal";
  Real BOP.delay2_2.limiter2.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealInput BOP.delay2_2.limiter.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.delay2_2.limiter.y "Connector of Real output signal";
  Real BOP.delay2_2.limiter.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.sensor_m_flow.port_a.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.sensor_m_flow.port_a.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.sensor_m_flow.port_a.h_outflow
    (start = BOP.sensor_m_flow.h_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.sensor_m_flow.port_a.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.sensor_m_flow.port_a.C_outflow
    [0](start = fill(1.0, size(BOP.sensor_m_flow.port_a.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate BOP.sensor_m_flow.port_b.m_flow
    (max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure BOP.sensor_m_flow.port_b.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy BOP.sensor_m_flow.port_b.h_outflow
    (start = BOP.sensor_m_flow.h_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction BOP.sensor_m_flow.port_b.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty BOP.sensor_m_flow.port_b.C_outflow
    [0](start = fill(1.0, size(BOP.sensor_m_flow.port_b.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Real BOP.sensor_m_flow.var = BOP.sensor_m_flow.m_flow "Variable to be converted";
  Real BOP.sensor_m_flow.y = BOP.sensor_m_flow.iconUnit_Unique49(
    BOP.sensor_m_flow.var) "Icon display";
  Modelica.Blocks.Interfaces.RealOutput BOP.sensor_m_flow.m_flow(unit = "kg/s") 
    "Mass flow rate from port_a to port_b";
  Modelica.Blocks.Interfaces.RealOutput BOP.realExpression.y = 0.4946 
    "Value of Real output";
  Modelica.Blocks.Interfaces.RealInput BOP.switch1.u1 "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.BooleanInput BOP.switch1.u2 "Connector of Boolean input signal";
  Modelica.Blocks.Interfaces.RealInput BOP.switch1.u3 "Connector of second Real input signal";
  Modelica.Blocks.Interfaces.RealOutput BOP.switch1.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.BooleanOutput BOP.booleanStep1.y "Connector of Boolean output signal";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    bypassdump.medium.p(nominal = 100000.0, unit = "Pa", displayUnit = "bar", 
    min = 0.0) "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    bypassdump.medium.Xi[0](start = {}, unit = "1", min = 0.0, max = 1.0) 
    "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    bypassdump.medium.h(unit = "J/kg") "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density bypassdump.medium.d(start = 150, 
    nominal = 500.0) "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature bypassdump.medium.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction bypassdump.medium.X[1](start = {
    1.0}) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy bypassdump.medium.u 
    "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity bypassdump.medium.R_s 
    "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass bypassdump.medium.MM 
    "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase bypassdump.medium.state.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy bypassdump.medium.state.h(
    start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density bypassdump.medium.state.d(start = 150,
     nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature bypassdump.medium.state.T(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure bypassdump.medium.state.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC bypassdump.medium.T_degC = 
    Modelica.Units.Conversions.to_degC(bypassdump.medium.T) "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar bypassdump.medium.p_bar = Modelica.Units.Conversions.to_bar
    (bypassdump.medium.p) "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure bypassdump.medium.sat.psat(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature bypassdump.medium.sat.Tsat(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer bypassdump.medium.phase(start = 1, fixed = false, min = 0.0, max = 2.0)
     "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate bypassdump.ports[1].m_flow
    (min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure bypassdump.ports[1].p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy bypassdump.ports[1].h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction bypassdump.ports[1].Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty bypassdump.ports[1].C_outflow[0]
    (start = fill(1.0, size(bypassdump.ports[1].C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealInput bypassdump.p_in "Prescribed boundary pressure";
  Modelica.Blocks.Interfaces.RealInput bypassdump.p_in_internal "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput bypassdump.T_in_internal "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput bypassdump.X_in_internal[1] 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput bypassdump.C_in_internal[0] 
    "Needed to connect to conditional connector";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    steamdump.medium.p(nominal = 100000.0, unit = "Pa", displayUnit = "bar", 
    min = 0.0) "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    steamdump.medium.Xi[0](start = {}, unit = "1", min = 0.0, max = 1.0) 
    "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    steamdump.medium.h(unit = "J/kg") "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density steamdump.medium.d(start = 150, 
    nominal = 500.0) "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature steamdump.medium.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction steamdump.medium.X[1](start = {
    1.0}) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy steamdump.medium.u 
    "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity steamdump.medium.R_s 
    "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass steamdump.medium.MM "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase steamdump.medium.state.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy steamdump.medium.state.h(
    start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density steamdump.medium.state.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature steamdump.medium.state.T(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure steamdump.medium.state.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC steamdump.medium.T_degC = 
    Modelica.Units.Conversions.to_degC(steamdump.medium.T) "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar steamdump.medium.p_bar = Modelica.Units.Conversions.to_bar
    (steamdump.medium.p) "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure steamdump.medium.sat.psat(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature steamdump.medium.sat.Tsat(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer steamdump.medium.phase(start = 1, fixed = false, min = 0.0, max = 2.0)
     "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate steamdump.ports[1].m_flow
    (min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure steamdump.ports[1].p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy steamdump.ports[1].h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction steamdump.ports[1].Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty steamdump.ports[1].C_outflow[0](
    start = fill(1.0, size(steamdump.ports[1].C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealInput steamdump.p_in_internal "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput steamdump.T_in_internal "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput steamdump.X_in_internal[1] 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput steamdump.C_in_internal[0] 
    "Needed to connect to conditional connector";
  Modelica.Units.SI.Power boundary.port.W "Active power";
  Modelica.Units.SI.Frequency boundary.port.f "Frequency";
  Modelica.Blocks.Interfaces.RealInput boundary.f_internal(unit = "1/s");
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    bypassdump1.medium.p(nominal = 100000.0, unit = "Pa", displayUnit = "bar", 
    min = 0.0) "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    bypassdump1.medium.Xi[0](start = {}, unit = "1", min = 0.0, max = 1.0) 
    "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    bypassdump1.medium.h(unit = "J/kg") "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density bypassdump1.medium.d(start = 150, 
    nominal = 500.0) "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature bypassdump1.medium.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction bypassdump1.medium.X[1](start = {
    1.0}) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy bypassdump1.medium.u 
    "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity bypassdump1.medium.R_s 
    "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass bypassdump1.medium.MM 
    "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase bypassdump1.medium.state.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy bypassdump1.medium.state.h(
    start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density bypassdump1.medium.state.d(start = 150,
     nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature bypassdump1.medium.state.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure bypassdump1.medium.state.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC bypassdump1.medium.T_degC = 
    Modelica.Units.Conversions.to_degC(bypassdump1.medium.T) "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar bypassdump1.medium.p_bar = Modelica.Units.Conversions.to_bar
    (bypassdump1.medium.p) "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure bypassdump1.medium.sat.psat(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature bypassdump1.medium.sat.Tsat(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer bypassdump1.medium.phase(start = 1, fixed = false, min = 0.0, max = 
    2.0) "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate bypassdump1.ports[1].m_flow
    (min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure bypassdump1.ports[1].p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy bypassdump1.ports[1].h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction bypassdump1.ports[1].Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty bypassdump1.ports[1].C_outflow[0]
    (start = fill(1.0, size(bypassdump1.ports[1].C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealInput bypassdump1.m_flow_in "Prescribed mass flow rate";
  Modelica.Blocks.Interfaces.RealInput bypassdump1.m_flow_in_internal 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput bypassdump1.h_in_internal 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput bypassdump1.X_in_internal[1] 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput bypassdump1.C_in_internal[0] 
    "Needed to connect to conditional connector";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate sensor_m_flow.port_a.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure sensor_m_flow.port_a.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy sensor_m_flow.port_a.h_outflow
    (start = sensor_m_flow.h_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction sensor_m_flow.port_a.Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty sensor_m_flow.port_a.C_outflow[0]
    (start = fill(1.0, size(sensor_m_flow.port_a.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate sensor_m_flow.port_b.m_flow
    (max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure sensor_m_flow.port_b.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy sensor_m_flow.port_b.h_outflow
    (start = sensor_m_flow.h_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction sensor_m_flow.port_b.Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty sensor_m_flow.port_b.C_outflow[0]
    (start = fill(1.0, size(sensor_m_flow.port_b.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Real sensor_m_flow.var = sensor_m_flow.m_flow "Variable to be converted";
  Real sensor_m_flow.y = sensor_m_flow.iconUnit_Unique50(sensor_m_flow.var) 
    "Icon display";
  Modelica.Blocks.Interfaces.RealOutput sensor_m_flow.m_flow(unit = "kg/s") 
    "Mass flow rate from port_a to port_b";
  Modelica.Blocks.Interfaces.RealOutput realExpression.y = P_demand*100000 
    "Value of Real output";
  Modelica.Blocks.Interfaces.RealInput integrator.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput integrator.y(start = integrator.y_start)
     "Connector of Real output signal";
  Modelica.Blocks.Interfaces.BooleanOutput integrator.local_reset;
  Modelica.Blocks.Interfaces.RealOutput integrator.local_set;
  Modelica.Units.SI.Power sensorW.port_a.W "Active power";
  Modelica.Units.SI.Frequency sensorW.port_a.f "Frequency";
  Modelica.Units.SI.Power sensorW.port_b.W "Active power";
  Modelica.Units.SI.Frequency sensorW.port_b.f "Frequency";
  Modelica.Blocks.Interfaces.RealOutput sensorW.W "Power flowing from port_a to port_b";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate volume.port_a.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure volume.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy volume.port_a.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction volume.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty volume.port_a.C_outflow[0](
    start = fill(1.0, size(volume.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate volume.port_b.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure volume.port_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy volume.port_b.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction volume.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty volume.port_b.C_outflow[0](
    start = fill(1.0, size(volume.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Units.SI.Volume volume.V(min = 0.0) = volume.geometry.V "Volume";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    volume.medium.p(start = volume.p_start, nominal = 100000.0, unit = "Pa", 
    displayUnit = "bar", min = 0.0, stateSelect = StateSelect.prefer) 
    "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    volume.medium.Xi[0](start = volume.X_start[1:0], unit = "1", min = 0.0, 
    max = 1.0) "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    volume.medium.h(start = (if  not volume.use_T_start then volume.h_start
     else Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_pTX_Unique11(
    volume.p_start, volume.T_start, volume.X_start[1:0], 0)), unit = "J/kg", 
    stateSelect = StateSelect.prefer) "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density volume.medium.d(start = (if 
    volume.use_T_start then Modelica.Media.Water.WaterIF97_ph.density_pTX_Unique32
    (volume.p_start, volume.T_start, volume.X_start[1:0]) else Modelica.Media.Water.WaterIF97_ph.density_phX_Unique33
    (volume.p_start, volume.h_start, volume.X_start[1:0], 0)), nominal = 500.0) 
    "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature volume.medium.T(start = (if 
    volume.use_T_start then volume.T_start else Modelica.Media.Water.WaterIF97_ph.temperature_phX_Unique34
    (volume.p_start, volume.h_start, volume.X_start[1:0], 0)), nominal = 500.0, 
    min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction volume.medium.X[1](start = 
    volume.X_start) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy volume.medium.u 
    "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity volume.medium.R_s 
    "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass volume.medium.MM "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase volume.medium.state.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy volume.medium.state.h(
    start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density volume.medium.state.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature volume.medium.state.T(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure volume.medium.state.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC volume.medium.T_degC = Modelica.Units.Conversions.to_degC
    (volume.medium.T) "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar volume.medium.p_bar = Modelica.Units.Conversions.to_bar
    (volume.medium.p) "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure volume.medium.sat.psat(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature volume.medium.sat.Tsat(start = 500,
     nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer volume.medium.phase(start = 1, fixed = false, min = 0.0, max = 2.0) 
    "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Units.SI.Mass volume.m "Mass";
  Modelica.Units.SI.InternalEnergy volume.U "Internal energy";
  Modelica.Units.SI.Mass volume.mXi[0] "Species mass";
  TRANSFORM.Units.ExtraPropertyExtrinsic volume.mC[0] "Trace substance extrinsic value";
  TRANSFORM.Units.ExtraPropertyExtrinsic volume.mC_scaled[0] "Scaled trace substance for improved numerical stability";
  TRANSFORM.Units.ExtraProperty volume.C[0](start = volume.C_start, 
    stateSelect = StateSelect.prefer) "Trace substance mass-specific value";
  Modelica.Units.SI.MassFlowRate volume.mb = volume.port_a.m_flow+
    volume.port_b.m_flow "Mass flow rate source/sinks within volumes";
  Modelica.Units.SI.HeatFlowRate volume.Ub = volume.port_a.m_flow*actualStream(
    volume.port_a.h_outflow)+volume.port_b.m_flow*actualStream(volume.port_b.h_outflow)
    +volume.Q_flow_internal+volume.Q_gen "Energy source/sinks within volumes (e.g., ohmic heating, external convection)";
  Modelica.Units.SI.MassFlowRate volume.mXib[0] = volume.port_a.m_flow*
    actualStream(volume.port_a.Xi_outflow)+volume.port_b.m_flow*actualStream(
    volume.port_b.Xi_outflow) "Species mass flow rates source/sinks within volumes";
  TRANSFORM.Units.ExtraPropertyFlowRate volume.mCb[0] = volume.port_a.m_flow*
    actualStream(volume.port_a.C_outflow)+volume.port_b.m_flow*actualStream(
    volume.port_b.C_outflow)+volume.mC_flow_internal+volume.mC_gen 
    "Trace flow rate source/sinks within volumes (e.g., chemical reactions, external convection)";
  Modelica.Units.SI.Volume volume.geometry.V = 10 "Volume";
  Modelica.Units.SI.Angle volume.geometry.angle(min = -1.5807963267948966, 
    max = 1.5807963267948966) = 0.0 "Vertical angle from the horizontal (-pi/2 <= x <= pi/2)";
  Modelica.Units.SI.Length volume.geometry.dheight = 0*sin(volume.geometry.angle)
     "Height(port_b) - Height(port_a)";
  Modelica.Units.SI.Length volume.geometry.height_a = 0 "Elevation at port_a: Reference value only. No impact on calculations.";
  Modelica.Units.SI.Length volume.geometry.height_b = volume.geometry.height_a+
    volume.geometry.dheight "Elevation at port_b: Reference value only. No impact on calculations.";
  Modelica.Units.SI.Acceleration volume.g_n = 9.80665 "Gravitational acceleration";
  Modelica.Units.SI.HeatFlowRate volume.Q_gen(displayUnit = "MW") = 0 
    "Internal heat generation";
  TRANSFORM.Units.ExtraPropertyFlowRate volume.mC_gen[0] = fill(0, 0) 
    "Internal trace mass generation";
  Modelica.Units.SI.Temperature volume.heatPort.T = volume.medium.T 
    "Port temperature";
  Modelica.Units.SI.HeatFlowRate volume.heatPort.Q_flow = volume.Q_flow_internal
     "Heat flow rate (positive if flowing from outside into the component)";
  Modelica.Units.SI.HeatFlowRate volume.Q_flow_internal;
  TRANSFORM.Units.ExtraPropertyFlowRate volume.mC_flow_internal[0];
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate resistance.port_a.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure resistance.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy resistance.port_a.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction resistance.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty resistance.port_a.C_outflow[0](
    start = fill(1.0, size(resistance.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate resistance.port_b.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure resistance.port_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy resistance.port_b.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction resistance.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty resistance.port_b.C_outflow[0](
    start = fill(1.0, size(resistance.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.FixedPhase resistance.state.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy resistance.state.h(start = 
    100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density resistance.state.d(start = 150, 
    nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature resistance.state.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure resistance.state.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.SI.PressureDifference resistance.dp;
  Modelica.Units.SI.MassFlowRate resistance.m_flow;
  Real resistance.dp_display = resistance.iconUnit_Unique51(resistance.dp) 
    "Icon display";
  Modelica.Units.SI.PressureDifference resistance.dp0 = 310 "Pressure loss (port_a.p-port_b.p)";
  Modelica.Blocks.Interfaces.RealInput boundary1.Q_flow_int(unit = "W");
  Modelica.Units.SI.HeatFlowRate boundary1.port.Q_flow "Heat flow rate. Flow from the connection point into the component is positive.";
  Modelica.Units.SI.Temperature boundary1.port.T "Temperature at the connection point";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate flowCV.valveLinear.port_a.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure flowCV.valveLinear.port_a.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy flowCV.valveLinear.port_a.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction flowCV.valveLinear.port_a.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty flowCV.valveLinear.port_a.C_outflow
    [0](start = fill(1.0, size(flowCV.valveLinear.port_a.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate flowCV.valveLinear.port_b.m_flow
    (max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure flowCV.valveLinear.port_b.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy flowCV.valveLinear.port_b.h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction flowCV.valveLinear.port_b.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty flowCV.valveLinear.port_b.C_outflow
    [0](start = fill(1.0, size(flowCV.valveLinear.port_b.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate flowCV.valveLinear.m_flow
    (start = flowCV.valveLinear.m_flow_start, min = -1E+60) "Mass flow rate in design flow direction";
  Modelica.Units.SI.Pressure flowCV.valveLinear.dp(start = flowCV.valveLinear.dp_start)
     "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
  Modelica.Units.SI.VolumeFlowRate flowCV.valveLinear.V_flow = flowCV.valveLinear.m_flow
    /Modelica.Fluid.Utilities.regStep(flowCV.valveLinear.m_flow, 
    Modelica.Media.Water.WaterIF97_ph.density_Unique30(
    flowCV.valveLinear.state_a), Modelica.Media.Water.WaterIF97_ph.density_Unique30
    (
    flowCV.valveLinear.state_b), flowCV.valveLinear.m_flow_small) 
    "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";
  Modelica.Media.Interfaces.Types.Temperature flowCV.valveLinear.port_a_T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = 
    Modelica.Fluid.Utilities.regStep(flowCV.valveLinear.port_a.m_flow, 
    Modelica.Media.Water.WaterIF97_ph.temperature_Unique35(
    flowCV.valveLinear.state_a), Modelica.Media.Water.WaterIF97_ph.temperature_Unique35
    (
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(flowCV.valveLinear.port_a.p,
       flowCV.valveLinear.port_a.h_outflow, flowCV.valveLinear.port_a.Xi_outflow,
       0, 0)), flowCV.valveLinear.m_flow_small) "Temperature close to port_a, if show_T = true";
  Modelica.Media.Interfaces.Types.Temperature flowCV.valveLinear.port_b_T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) = 
    Modelica.Fluid.Utilities.regStep(flowCV.valveLinear.port_b.m_flow, 
    Modelica.Media.Water.WaterIF97_ph.temperature_Unique35(
    flowCV.valveLinear.state_b), Modelica.Media.Water.WaterIF97_ph.temperature_Unique35
    (
    Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(flowCV.valveLinear.port_b.p,
       flowCV.valveLinear.port_b.h_outflow, flowCV.valveLinear.port_b.Xi_outflow,
       0, 0)), flowCV.valveLinear.m_flow_small) "Temperature close to port_b, if show_T = true";
  Modelica.Media.Interfaces.Types.FixedPhase flowCV.valveLinear.state_a.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy flowCV.valveLinear.state_a.h(
    start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density flowCV.valveLinear.state_a.d(start = 150,
     nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature flowCV.valveLinear.state_a.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure flowCV.valveLinear.state_a.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Media.Interfaces.Types.FixedPhase flowCV.valveLinear.state_b.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy flowCV.valveLinear.state_b.h(
    start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density flowCV.valveLinear.state_b.d(start = 150,
     nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature flowCV.valveLinear.state_b.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure flowCV.valveLinear.state_b.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Blocks.Interfaces.RealInput flowCV.valveLinear.opening(min = 0.0, 
    max = 1.0) "=1: completely open, =0: completely closed";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate flowCV.sensor_m_flow.port_a.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure flowCV.sensor_m_flow.port_a.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy flowCV.sensor_m_flow.port_a.h_outflow
    (start = flowCV.sensor_m_flow.h_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction flowCV.sensor_m_flow.port_a.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty flowCV.sensor_m_flow.port_a.C_outflow
    [0](start = fill(1.0, size(flowCV.sensor_m_flow.port_a.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate flowCV.sensor_m_flow.port_b.m_flow
    (max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure flowCV.sensor_m_flow.port_b.p
    (start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy flowCV.sensor_m_flow.port_b.h_outflow
    (start = flowCV.sensor_m_flow.h_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction flowCV.sensor_m_flow.port_b.Xi_outflow
    [0] "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty flowCV.sensor_m_flow.port_b.C_outflow
    [0](start = fill(1.0, size(flowCV.sensor_m_flow.port_b.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Real flowCV.sensor_m_flow.var = flowCV.sensor_m_flow.m_flow "Variable to be converted";
  Real flowCV.sensor_m_flow.y = flowCV.sensor_m_flow.iconUnit_Unique52(
    flowCV.sensor_m_flow.var) "Icon display";
  Modelica.Blocks.Interfaces.RealOutput flowCV.sensor_m_flow.m_flow(unit = 
    "kg/s") "Mass flow rate from port_a to port_b";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.u_s "Connector of setpoint input signal";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.u_m "Connector of measurement input signal";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.y "Connector of actuator output signal";
  Real flowCV.PID.controlError = flowCV.PID.u_s-flowCV.PID.u_m "Control error (set point - measurement)";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.addP.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.addP.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.addP.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.P.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.P.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.gainPID.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.gainPID.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.addPID.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.addPID.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.addPID.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.addPID.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.limiter.u(start = 
    flowCV.PID.y_start) "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.limiter.y "Connector of Real output signal";
  Real flowCV.PID.limiter.simplifiedExpr "Simplified expression for homotopy-based initialization";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.Fzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.addFF.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.addFF.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.addFF.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.addFF.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.gain_u_s.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.gain_u_s.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.gain_u_m.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.gain_u_m.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.null_bias.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.y_reset_internal 
    "Internal connector for controller output reset";
  Modelica.Blocks.Interfaces.BooleanOutput flowCV.PID.delay_boolean.y 
    "Connector of Boolean output signal";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.input_switch.u1 
    "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.BooleanInput flowCV.PID.input_switch.u2 
    "Connector of Boolean input signal";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.input_switch.u3 
    "Connector of second Real input signal";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.input_switch.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.output_switch.u1 
    "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.BooleanInput flowCV.PID.output_switch.u2 
    "Connector of Boolean input signal";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.output_switch.u3 
    "Connector of second Real input signal";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.output_switch.y 
    "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.init.y = flowCV.PID.init_output
     "Value of Real output";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.add_offset.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.add_offset.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.add_offset.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.offset_set.y = 
    flowCV.PID.offset "Value of Real output";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.I.u "Connector of Real input signal";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.I.y(start = flowCV.PID.I.y_start)
     "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.I.y_reset_internal 
    "Internal connector for integrator reset";
  Modelica.Blocks.Interfaces.BooleanInput flowCV.PID.I.trigger_internal 
    "Needed to use conditional connector trigger";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.addI.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.addI.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.addI.u3 "Connector of Real input signal 3";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.addI.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.addSat.u1 "Connector of Real input signal 1";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.addSat.u2 "Connector of Real input signal 2";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.addSat.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealInput flowCV.PID.gainTrack.u "Input signal connector";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.gainTrack.y "Output signal connector";
  Modelica.Blocks.Interfaces.RealOutput flowCV.PID.Dzero.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.RealOutput flowCV.flowRate_nom.y = flowCV.FlowRate_target
     "Value of Real output";
  Modelica.Blocks.Interfaces.RealInput flowCV.inputSwitch.u1 "Connector of first Real input signal";
  Modelica.Blocks.Interfaces.BooleanInput flowCV.inputSwitch.u2 "Connector of Boolean input signal";
  Modelica.Blocks.Interfaces.RealInput flowCV.inputSwitch.u3 "Connector of second Real input signal";
  Modelica.Blocks.Interfaces.RealOutput flowCV.inputSwitch.y "Connector of Real output signal";
  Modelica.Blocks.Interfaces.BooleanOutput flowCV.booleanConstant.y 
    "Connector of Boolean output signal";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate flowCV.port_a.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure flowCV.port_a.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy flowCV.port_a.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction flowCV.port_a.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty flowCV.port_a.C_outflow[0](
    start = fill(1.0, size(flowCV.port_a.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate flowCV.port_b.m_flow 
    "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure flowCV.port_b.p(start = 
    5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy flowCV.port_b.h_outflow(
    start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction flowCV.port_b.Xi_outflow[0] 
    "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty flowCV.port_b.C_outflow[0](
    start = fill(1.0, size(flowCV.port_b.C_outflow, 1))) "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealOutput flowCV.zero.y = 0 "Value of Real output";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputAbsolutePressure 
    bypassdump2.medium.p(nominal = 100000.0, unit = "Pa", displayUnit = "bar", 
    min = 0.0) "Absolute pressure of medium";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputMassFraction 
    bypassdump2.medium.Xi[0](start = {}, unit = "1", min = 0.0, max = 1.0) 
    "Structurally independent mass fractions";
  Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1.InputSpecificEnthalpy 
    bypassdump2.medium.h(unit = "J/kg") "Specific enthalpy of medium";
  Modelica.Media.Interfaces.Types.Density bypassdump2.medium.d(start = 150, 
    nominal = 500.0) "Density of medium";
  Modelica.Media.Interfaces.Types.Temperature bypassdump2.medium.T(start = 500, 
    nominal = 500.0, min = 273.15, max = 2273.15) "Temperature of medium";
  Modelica.Media.Interfaces.Types.MassFraction bypassdump2.medium.X[1](start = {
    1.0}) "Mass fractions (= (component mass)/total mass  m_i/m)";
  Modelica.Media.Interfaces.Types.SpecificInternalEnergy bypassdump2.medium.u 
    "Specific internal energy of medium";
  Modelica.Media.Interfaces.Types.SpecificHeatCapacity bypassdump2.medium.R_s 
    "Gas constant (of mixture if applicable)";
  Modelica.Media.Interfaces.Types.MolarMass bypassdump2.medium.MM 
    "Molar mass (of mixture or single fluid)";
  Modelica.Media.Interfaces.Types.FixedPhase bypassdump2.medium.state.phase 
    "Phase of the fluid: 1 for 1-phase, 2 for two-phase, 0 for not known, e.g., interactive use";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy bypassdump2.medium.state.h(
    start = 100000.0, nominal = 500000.0) "Specific enthalpy";
  Modelica.Media.Interfaces.Types.Density bypassdump2.medium.state.d(start = 150,
     nominal = 500.0) "Density";
  Modelica.Media.Interfaces.Types.Temperature bypassdump2.medium.state.T(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Temperature";
  Modelica.Media.Interfaces.Types.AbsolutePressure bypassdump2.medium.state.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Pressure";
  Modelica.Units.NonSI.Temperature_degC bypassdump2.medium.T_degC = 
    Modelica.Units.Conversions.to_degC(bypassdump2.medium.T) "Temperature of medium in [degC]";
  Modelica.Units.NonSI.Pressure_bar bypassdump2.medium.p_bar = Modelica.Units.Conversions.to_bar
    (bypassdump2.medium.p) "Absolute pressure of medium in [bar]";
  Modelica.Media.Interfaces.Types.AbsolutePressure bypassdump2.medium.sat.psat(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Saturation pressure";
  Modelica.Media.Interfaces.Types.Temperature bypassdump2.medium.sat.Tsat(
    start = 500, nominal = 500.0, min = 273.15, max = 2273.15) "Saturation temperature";
  Integer bypassdump2.medium.phase(start = 1, fixed = false, min = 0.0, max = 
    2.0) "2 for two-phase, 1 for one-phase, 0 if not known";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate bypassdump2.ports[1].m_flow
    (min = -1E+60, max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure bypassdump2.ports[1].p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy bypassdump2.ports[1].h_outflow
    (start = 100000.0, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction bypassdump2.ports[1].Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty bypassdump2.ports[1].C_outflow[0]
    (start = fill(1.0, size(bypassdump2.ports[1].C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Blocks.Interfaces.RealInput bypassdump2.p_in "Prescribed boundary pressure";
  Modelica.Blocks.Interfaces.RealInput bypassdump2.p_in_internal 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput bypassdump2.T_in_internal 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput bypassdump2.X_in_internal[1] 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealInput bypassdump2.C_in_internal[0] 
    "Needed to connect to conditional connector";
  Modelica.Blocks.Interfaces.RealOutput realExpression1.y = 5000000.0 
    "Value of Real output";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate sensor_m_flow1.port_a.m_flow
    (min = -1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure sensor_m_flow1.port_a.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy sensor_m_flow1.port_a.h_outflow
    (start = sensor_m_flow1.h_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction sensor_m_flow1.port_a.Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty sensor_m_flow1.port_a.C_outflow[0]
    (start = fill(1.0, size(sensor_m_flow1.port_a.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.PartialMedium.MassFlowRate sensor_m_flow1.port_b.m_flow
    (max = 1E+60) "Mass flow rate from the connection point into the component";
  Modelica.Media.Interfaces.Types.AbsolutePressure sensor_m_flow1.port_b.p(
    start = 5000000.0, nominal = 1000000.0, min = 611.657) "Thermodynamic pressure in the connection point";
  Modelica.Media.Interfaces.Types.SpecificEnthalpy sensor_m_flow1.port_b.h_outflow
    (start = sensor_m_flow1.h_start, nominal = 500000.0) "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.MassFraction sensor_m_flow1.port_b.Xi_outflow[0]
     "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
  Modelica.Media.Interfaces.Types.ExtraProperty sensor_m_flow1.port_b.C_outflow[0]
    (start = fill(1.0, size(sensor_m_flow1.port_b.C_outflow, 1))) 
    "Properties c_i/m close to the connection point if m_flow < 0";
  Real sensor_m_flow1.var = sensor_m_flow1.m_flow "Variable to be converted";
  Real sensor_m_flow1.y = sensor_m_flow1.iconUnit_Unique53(sensor_m_flow1.var) 
    "Icon display";
  Modelica.Blocks.Interfaces.RealOutput sensor_m_flow1.m_flow(unit = "kg/s") 
    "Mass flow rate from port_a to port_b";

// Equations and algorithms

  // Component stateSensor1.pressure
  // class Modelica.Fluid.Sensors.Pressure
    // extends Modelica.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      stateSensor1.pressure.port.m_flow = 0;
      stateSensor1.pressure.port.h_outflow = 84013.0581525969;
      stateSensor1.pressure.port.Xi_outflow = {};
      stateSensor1.pressure.port.C_outflow = zeros(0);
    // end of extends 
  equation
    stateSensor1.pressure.p = stateSensor1.pressure.port.p;

  // Component stateSensor1.temperature
  // class Modelica.Fluid.Sensors.Temperature
    // extends Modelica.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      stateSensor1.temperature.port.m_flow = 0;
      stateSensor1.temperature.port.h_outflow = 84013.0581525969;
      stateSensor1.temperature.port.Xi_outflow = {};
      stateSensor1.temperature.port.C_outflow = zeros(0);
    // end of extends 
  equation
    stateSensor1.temperature.T = Modelica.Media.Water.WaterIF97_ph.temperature_Unique7
      (
      Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique8(stateSensor1.temperature.port.p,
         inStream(stateSensor1.temperature.port.h_outflow), inStream(
        stateSensor1.temperature.port.Xi_outflow), 0, 0));

  // Component stateSensor1.massFlowRate
  // class Modelica.Fluid.Sensors.MassFlowRate
    // extends Modelica.Fluid.Sensors.BaseClasses.PartialFlowSensor
    equation
      0 = stateSensor1.massFlowRate.port_a.m_flow+stateSensor1.massFlowRate.port_b.m_flow;
      stateSensor1.massFlowRate.port_a.p = stateSensor1.massFlowRate.port_b.p;
      stateSensor1.massFlowRate.port_a.h_outflow = inStream(stateSensor1.massFlowRate.port_b.h_outflow);
      stateSensor1.massFlowRate.port_b.h_outflow = inStream(stateSensor1.massFlowRate.port_a.h_outflow);
      stateSensor1.massFlowRate.port_a.Xi_outflow = inStream(stateSensor1.massFlowRate.port_b.Xi_outflow);
      stateSensor1.massFlowRate.port_b.Xi_outflow = inStream(stateSensor1.massFlowRate.port_a.Xi_outflow);
      stateSensor1.massFlowRate.port_a.C_outflow = inStream(stateSensor1.massFlowRate.port_b.C_outflow);
      stateSensor1.massFlowRate.port_b.C_outflow = inStream(stateSensor1.massFlowRate.port_a.C_outflow);
    // end of extends 
  equation
    stateSensor1.massFlowRate.m_flow = stateSensor1.massFlowRate.port_a.m_flow;

  // Component stateSensor1.specificEnthalpy
  // class Modelica.Fluid.Sensors.SpecificEnthalpy
    // extends Modelica.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      stateSensor1.specificEnthalpy.port.m_flow = 0;
      stateSensor1.specificEnthalpy.port.h_outflow = 84013.0581525969;
      stateSensor1.specificEnthalpy.port.Xi_outflow = {};
      stateSensor1.specificEnthalpy.port.C_outflow = zeros(0);
    // end of extends 
  equation
    stateSensor1.specificEnthalpy.h_out = inStream(stateSensor1.specificEnthalpy.port.h_outflow);

  // Component stateSensor1
  // class NHES.Fluid.Sensors.stateSensor
  equation
    stateSensor1.statePort.p = stateSensor1.pressure.p;
    stateSensor1.statePort.T = stateSensor1.temperature.T;
    stateSensor1.statePort.m_flow = stateSensor1.massFlowRate.m_flow;
    stateSensor1.statePort.h_out = stateSensor1.specificEnthalpy.h_out;
    stateSensor1.port_a.m_flow-stateSensor1.massFlowRate.port_a.m_flow-
      stateSensor1.pressure.port.m_flow-stateSensor1.specificEnthalpy.port.m_flow
      -stateSensor1.temperature.port.m_flow = 0.0;
    stateSensor1.port_a.p = stateSensor1.massFlowRate.port_a.p;
    stateSensor1.pressure.port.p = stateSensor1.massFlowRate.port_a.p;
    stateSensor1.specificEnthalpy.port.p = stateSensor1.massFlowRate.port_a.p;
    stateSensor1.temperature.port.p = stateSensor1.massFlowRate.port_a.p;
    stateSensor1.port_b.m_flow-stateSensor1.massFlowRate.port_b.m_flow = 0.0;
    stateSensor1.port_b.p = stateSensor1.massFlowRate.port_b.p;

  // Component stateSensor2.pressure
  // class Modelica.Fluid.Sensors.Pressure
    // extends Modelica.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      stateSensor2.pressure.port.m_flow = 0;
      stateSensor2.pressure.port.h_outflow = 84013.0581525969;
      stateSensor2.pressure.port.Xi_outflow = {};
      stateSensor2.pressure.port.C_outflow = zeros(0);
    // end of extends 
  equation
    stateSensor2.pressure.p = stateSensor2.pressure.port.p;

  // Component stateSensor2.temperature
  // class Modelica.Fluid.Sensors.Temperature
    // extends Modelica.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      stateSensor2.temperature.port.m_flow = 0;
      stateSensor2.temperature.port.h_outflow = 84013.0581525969;
      stateSensor2.temperature.port.Xi_outflow = {};
      stateSensor2.temperature.port.C_outflow = zeros(0);
    // end of extends 
  equation
    stateSensor2.temperature.T = Modelica.Media.Water.WaterIF97_ph.temperature_Unique7
      (
      Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique8(stateSensor2.temperature.port.p,
         inStream(stateSensor2.temperature.port.h_outflow), inStream(
        stateSensor2.temperature.port.Xi_outflow), 0, 0));

  // Component stateSensor2.massFlowRate
  // class Modelica.Fluid.Sensors.MassFlowRate
    // extends Modelica.Fluid.Sensors.BaseClasses.PartialFlowSensor
    equation
      0 = stateSensor2.massFlowRate.port_a.m_flow+stateSensor2.massFlowRate.port_b.m_flow;
      stateSensor2.massFlowRate.port_a.p = stateSensor2.massFlowRate.port_b.p;
      stateSensor2.massFlowRate.port_a.h_outflow = inStream(stateSensor2.massFlowRate.port_b.h_outflow);
      stateSensor2.massFlowRate.port_b.h_outflow = inStream(stateSensor2.massFlowRate.port_a.h_outflow);
      stateSensor2.massFlowRate.port_a.Xi_outflow = inStream(stateSensor2.massFlowRate.port_b.Xi_outflow);
      stateSensor2.massFlowRate.port_b.Xi_outflow = inStream(stateSensor2.massFlowRate.port_a.Xi_outflow);
      stateSensor2.massFlowRate.port_a.C_outflow = inStream(stateSensor2.massFlowRate.port_b.C_outflow);
      stateSensor2.massFlowRate.port_b.C_outflow = inStream(stateSensor2.massFlowRate.port_a.C_outflow);
    // end of extends 
  equation
    stateSensor2.massFlowRate.m_flow = stateSensor2.massFlowRate.port_a.m_flow;

  // Component stateSensor2.specificEnthalpy
  // class Modelica.Fluid.Sensors.SpecificEnthalpy
    // extends Modelica.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      stateSensor2.specificEnthalpy.port.m_flow = 0;
      stateSensor2.specificEnthalpy.port.h_outflow = 84013.0581525969;
      stateSensor2.specificEnthalpy.port.Xi_outflow = {};
      stateSensor2.specificEnthalpy.port.C_outflow = zeros(0);
    // end of extends 
  equation
    stateSensor2.specificEnthalpy.h_out = inStream(stateSensor2.specificEnthalpy.port.h_outflow);

  // Component stateSensor2
  // class NHES.Fluid.Sensors.stateSensor
  equation
    stateSensor2.statePort.p = stateSensor2.pressure.p;
    stateSensor2.statePort.T = stateSensor2.temperature.T;
    stateSensor2.statePort.m_flow = stateSensor2.massFlowRate.m_flow;
    stateSensor2.statePort.h_out = stateSensor2.specificEnthalpy.h_out;
    stateSensor2.port_a.m_flow-stateSensor2.massFlowRate.port_a.m_flow-
      stateSensor2.pressure.port.m_flow-stateSensor2.specificEnthalpy.port.m_flow
      -stateSensor2.temperature.port.m_flow = 0.0;
    stateSensor2.port_a.p = stateSensor2.massFlowRate.port_a.p;
    stateSensor2.pressure.port.p = stateSensor2.massFlowRate.port_a.p;
    stateSensor2.specificEnthalpy.port.p = stateSensor2.massFlowRate.port_a.p;
    stateSensor2.temperature.port.p = stateSensor2.massFlowRate.port_a.p;
    stateSensor2.port_b.m_flow-stateSensor2.massFlowRate.port_b.m_flow = 0.0;
    stateSensor2.port_b.p = stateSensor2.massFlowRate.port_b.p;

  // Component stateDisplay2
  // class NHES.Fluid.Sensors.stateDisplay
  equation
    stateDisplay2.h_out = stateDisplay2.statePort.h_out/1000;
    stateDisplay2.p = stateDisplay2.statePort.p/100000.0;
    stateDisplay2.m_flow = stateDisplay2.statePort.m_flow;
    stateDisplay2.T = stateDisplay2.statePort.T-273.15;

  // Component stateDisplay1
  // class NHES.Fluid.Sensors.stateDisplay
  equation
    stateDisplay1.h_out = stateDisplay1.statePort.h_out/1000;
    stateDisplay1.p = stateDisplay1.statePort.p/100000.0;
    stateDisplay1.m_flow = stateDisplay1.statePort.m_flow;
    stateDisplay1.T = stateDisplay1.statePort.T-273.15;

  // Component BOP.CS.FeedPump_PID.addP
  // class Modelica.Blocks.Math.Add
  equation
    BOP.CS.FeedPump_PID.addP.y = BOP.CS.FeedPump_PID.addP.k1*BOP.CS.FeedPump_PID.addP.u1
      +BOP.CS.FeedPump_PID.addP.k2*BOP.CS.FeedPump_PID.addP.u2;

  // Component BOP.CS.FeedPump_PID.P
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.FeedPump_PID.P.y = BOP.CS.FeedPump_PID.P.k*BOP.CS.FeedPump_PID.P.u;

  // Component BOP.CS.FeedPump_PID.gainPID
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.FeedPump_PID.gainPID.y = BOP.CS.FeedPump_PID.gainPID.k*
      BOP.CS.FeedPump_PID.gainPID.u;

  // Component BOP.CS.FeedPump_PID.addPID
  // class Modelica.Blocks.Math.Add3
  equation
    BOP.CS.FeedPump_PID.addPID.y = BOP.CS.FeedPump_PID.addPID.k1*
      BOP.CS.FeedPump_PID.addPID.u1+BOP.CS.FeedPump_PID.addPID.k2*
      BOP.CS.FeedPump_PID.addPID.u2+BOP.CS.FeedPump_PID.addPID.k3*
      BOP.CS.FeedPump_PID.addPID.u3;

  // Component BOP.CS.FeedPump_PID.limiter
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(BOP.CS.FeedPump_PID.limiter.uMax >= BOP.CS.FeedPump_PID.limiter.uMin,
       "Limiter: Limits must be consistent. However, uMax (="+       String(
      BOP.CS.FeedPump_PID.limiter.uMax, true, 0)+") < uMin (="+       String(
      BOP.CS.FeedPump_PID.limiter.uMin, true, 0)+")");
    BOP.CS.FeedPump_PID.limiter.simplifiedExpr = (if BOP.CS.FeedPump_PID.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.Linear then BOP.CS.FeedPump_PID.limiter.u
       else (if BOP.CS.FeedPump_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then BOP.CS.FeedPump_PID.limiter.uMax else (if BOP.CS.FeedPump_PID.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then BOP.CS.FeedPump_PID.limiter.uMin
       else 0)));
    if (BOP.CS.FeedPump_PID.limiter.strict) then 
      if (BOP.CS.FeedPump_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.CS.FeedPump_PID.limiter.y = smooth(0, noEvent((if BOP.CS.FeedPump_PID.limiter.u
           > BOP.CS.FeedPump_PID.limiter.uMax then BOP.CS.FeedPump_PID.limiter.uMax
           else (if BOP.CS.FeedPump_PID.limiter.u < BOP.CS.FeedPump_PID.limiter.uMin
           then BOP.CS.FeedPump_PID.limiter.uMin else BOP.CS.FeedPump_PID.limiter.u))));
      else
        BOP.CS.FeedPump_PID.limiter.y = homotopy(smooth(0, noEvent((if 
          BOP.CS.FeedPump_PID.limiter.u > BOP.CS.FeedPump_PID.limiter.uMax then 
          BOP.CS.FeedPump_PID.limiter.uMax else (if BOP.CS.FeedPump_PID.limiter.u
           < BOP.CS.FeedPump_PID.limiter.uMin then BOP.CS.FeedPump_PID.limiter.uMin
           else BOP.CS.FeedPump_PID.limiter.u)))), BOP.CS.FeedPump_PID.limiter.simplifiedExpr);
      end if;
    else
      if (BOP.CS.FeedPump_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.CS.FeedPump_PID.limiter.y = smooth(0, (if BOP.CS.FeedPump_PID.limiter.u
           > BOP.CS.FeedPump_PID.limiter.uMax then BOP.CS.FeedPump_PID.limiter.uMax
           else (if BOP.CS.FeedPump_PID.limiter.u < BOP.CS.FeedPump_PID.limiter.uMin
           then BOP.CS.FeedPump_PID.limiter.uMin else BOP.CS.FeedPump_PID.limiter.u)));
      else
        BOP.CS.FeedPump_PID.limiter.y = homotopy(smooth(0, (if BOP.CS.FeedPump_PID.limiter.u
           > BOP.CS.FeedPump_PID.limiter.uMax then BOP.CS.FeedPump_PID.limiter.uMax
           else (if BOP.CS.FeedPump_PID.limiter.u < BOP.CS.FeedPump_PID.limiter.uMin
           then BOP.CS.FeedPump_PID.limiter.uMin else BOP.CS.FeedPump_PID.limiter.u))),
           BOP.CS.FeedPump_PID.limiter.simplifiedExpr);
      end if;
    end if;

  // Component BOP.CS.FeedPump_PID.Fzero
  // class Modelica.Blocks.Sources.Constant
  equation
    BOP.CS.FeedPump_PID.Fzero.y = BOP.CS.FeedPump_PID.Fzero.k;

  // Component BOP.CS.FeedPump_PID.addFF
  // class Modelica.Blocks.Math.Add3
  equation
    BOP.CS.FeedPump_PID.addFF.y = BOP.CS.FeedPump_PID.addFF.k1*BOP.CS.FeedPump_PID.addFF.u1
      +BOP.CS.FeedPump_PID.addFF.k2*BOP.CS.FeedPump_PID.addFF.u2+
      BOP.CS.FeedPump_PID.addFF.k3*BOP.CS.FeedPump_PID.addFF.u3;

  // Component BOP.CS.FeedPump_PID.gain_u_s
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.FeedPump_PID.gain_u_s.y = BOP.CS.FeedPump_PID.gain_u_s.k*
      BOP.CS.FeedPump_PID.gain_u_s.u;

  // Component BOP.CS.FeedPump_PID.gain_u_m
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.FeedPump_PID.gain_u_m.y = BOP.CS.FeedPump_PID.gain_u_m.k*
      BOP.CS.FeedPump_PID.gain_u_m.u;

  // Component BOP.CS.FeedPump_PID.null_bias
  // class Modelica.Blocks.Sources.Constant
  equation
    BOP.CS.FeedPump_PID.null_bias.y = BOP.CS.FeedPump_PID.null_bias.k;

  // Component BOP.CS.FeedPump_PID.I
  // class TRANSFORM.Blocks.IntegratorWithReset
  equation
    der(BOP.CS.FeedPump_PID.I.y) = BOP.CS.FeedPump_PID.I.k*BOP.CS.FeedPump_PID.I.u;
    if (BOP.CS.FeedPump_PID.I.reset <> TRANSFORM.Types.Reset.Input) then 
      BOP.CS.FeedPump_PID.I.y_reset_internal = BOP.CS.FeedPump_PID.I.y_reset;
    end if;
    if (BOP.CS.FeedPump_PID.I.reset == TRANSFORM.Types.Reset.Disabled) then 
      BOP.CS.FeedPump_PID.I.trigger_internal = false;
    else
      when BOP.CS.FeedPump_PID.I.trigger_internal then
        reinit(BOP.CS.FeedPump_PID.I.y, BOP.CS.FeedPump_PID.I.y_reset_internal);
      end when;
    end if;

  // Component BOP.CS.FeedPump_PID.addI
  // class Modelica.Blocks.Math.Add3
  equation
    BOP.CS.FeedPump_PID.addI.y = BOP.CS.FeedPump_PID.addI.k1*BOP.CS.FeedPump_PID.addI.u1
      +BOP.CS.FeedPump_PID.addI.k2*BOP.CS.FeedPump_PID.addI.u2+BOP.CS.FeedPump_PID.addI.k3
      *BOP.CS.FeedPump_PID.addI.u3;

  // Component BOP.CS.FeedPump_PID.addSat
  // class Modelica.Blocks.Math.Add
  equation
    BOP.CS.FeedPump_PID.addSat.y = BOP.CS.FeedPump_PID.addSat.k1*
      BOP.CS.FeedPump_PID.addSat.u1+BOP.CS.FeedPump_PID.addSat.k2*
      BOP.CS.FeedPump_PID.addSat.u2;

  // Component BOP.CS.FeedPump_PID.gainTrack
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.FeedPump_PID.gainTrack.y = BOP.CS.FeedPump_PID.gainTrack.k*
      BOP.CS.FeedPump_PID.gainTrack.u;

  // Component BOP.CS.FeedPump_PID.Dzero
  // class Modelica.Blocks.Sources.Constant
  equation
    BOP.CS.FeedPump_PID.Dzero.y = BOP.CS.FeedPump_PID.Dzero.k;

  // Component BOP.CS.FeedPump_PID
  // class TRANSFORM.Controls.LimPID
  equation
    assert(BOP.CS.FeedPump_PID.yMax >= BOP.CS.FeedPump_PID.yMin, 
      "LimPID: Limits must be consistent. However, yMax (="+       String(
      BOP.CS.FeedPump_PID.yMax, true, 0)+") < yMin (="+       String(
      BOP.CS.FeedPump_PID.yMin, true, 0)+")");
    if (BOP.CS.FeedPump_PID.initType == Modelica.Blocks.Types.Init.InitialOutput
       and (BOP.CS.FeedPump_PID.y_start < BOP.CS.FeedPump_PID.yMin or 
      BOP.CS.FeedPump_PID.y_start > BOP.CS.FeedPump_PID.yMax)) then 
      ModelicaError("LimPID: Start value y_start (="+       String(
        BOP.CS.FeedPump_PID.y_start, true, 0)+") is outside of the limits of yMin (="
        +       String(BOP.CS.FeedPump_PID.yMin, true, 0)+") and yMax (="+
               String(BOP.CS.FeedPump_PID.yMax, true, 0)+")");
    end if;
    if (BOP.CS.FeedPump_PID.reset <> TRANSFORM.Types.Reset.Input) then 
      BOP.CS.FeedPump_PID.y_reset_internal = BOP.CS.FeedPump_PID.y_reset;
    end if;
    BOP.CS.FeedPump_PID.addPID.u2 = BOP.CS.FeedPump_PID.Dzero.y;
    BOP.CS.FeedPump_PID.addFF.u1 = BOP.CS.FeedPump_PID.Fzero.y;
    BOP.CS.FeedPump_PID.addI.y = BOP.CS.FeedPump_PID.I.u;
    BOP.CS.FeedPump_PID.addPID.u3 = BOP.CS.FeedPump_PID.I.y;
    BOP.CS.FeedPump_PID.addP.y = BOP.CS.FeedPump_PID.P.u;
    BOP.CS.FeedPump_PID.addPID.u1 = BOP.CS.FeedPump_PID.P.y;
    BOP.CS.FeedPump_PID.gainPID.y = BOP.CS.FeedPump_PID.addFF.u2;
    BOP.CS.FeedPump_PID.null_bias.y = BOP.CS.FeedPump_PID.addFF.u3;
    BOP.CS.FeedPump_PID.addSat.u2 = BOP.CS.FeedPump_PID.addFF.y;
    BOP.CS.FeedPump_PID.limiter.u = BOP.CS.FeedPump_PID.addFF.y;
    BOP.CS.FeedPump_PID.addP.u1 = BOP.CS.FeedPump_PID.addI.u1;
    BOP.CS.FeedPump_PID.gain_u_s.y = BOP.CS.FeedPump_PID.addI.u1;
    BOP.CS.FeedPump_PID.addP.u2 = BOP.CS.FeedPump_PID.addI.u2;
    BOP.CS.FeedPump_PID.gain_u_m.y = BOP.CS.FeedPump_PID.addI.u2;
    BOP.CS.FeedPump_PID.gainTrack.y = BOP.CS.FeedPump_PID.addI.u3;
    BOP.CS.FeedPump_PID.gainPID.u = BOP.CS.FeedPump_PID.addPID.y;
    BOP.CS.FeedPump_PID.limiter.y = BOP.CS.FeedPump_PID.addSat.u1;
    BOP.CS.FeedPump_PID.y = BOP.CS.FeedPump_PID.addSat.u1;
    BOP.CS.FeedPump_PID.gainTrack.u = BOP.CS.FeedPump_PID.addSat.y;
    BOP.CS.FeedPump_PID.u_m = BOP.CS.FeedPump_PID.gain_u_m.u;
    BOP.CS.FeedPump_PID.u_s = BOP.CS.FeedPump_PID.gain_u_s.u;

  // Component BOP.CS.TCV_PID.addP
  // class Modelica.Blocks.Math.Add
  equation
    BOP.CS.TCV_PID.addP.y = BOP.CS.TCV_PID.addP.k1*BOP.CS.TCV_PID.addP.u1+
      BOP.CS.TCV_PID.addP.k2*BOP.CS.TCV_PID.addP.u2;

  // Component BOP.CS.TCV_PID.P
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.TCV_PID.P.y = BOP.CS.TCV_PID.P.k*BOP.CS.TCV_PID.P.u;

  // Component BOP.CS.TCV_PID.gainPID
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.TCV_PID.gainPID.y = BOP.CS.TCV_PID.gainPID.k*BOP.CS.TCV_PID.gainPID.u;

  // Component BOP.CS.TCV_PID.addPID
  // class Modelica.Blocks.Math.Add3
  equation
    BOP.CS.TCV_PID.addPID.y = BOP.CS.TCV_PID.addPID.k1*BOP.CS.TCV_PID.addPID.u1+
      BOP.CS.TCV_PID.addPID.k2*BOP.CS.TCV_PID.addPID.u2+BOP.CS.TCV_PID.addPID.k3
      *BOP.CS.TCV_PID.addPID.u3;

  // Component BOP.CS.TCV_PID.limiter
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(BOP.CS.TCV_PID.limiter.uMax >= BOP.CS.TCV_PID.limiter.uMin, 
      "Limiter: Limits must be consistent. However, uMax (="+       String(
      BOP.CS.TCV_PID.limiter.uMax, true, 0)+") < uMin (="+       String(
      BOP.CS.TCV_PID.limiter.uMin, true, 0)+")");
    BOP.CS.TCV_PID.limiter.simplifiedExpr = (if BOP.CS.TCV_PID.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.Linear then BOP.CS.TCV_PID.limiter.u
       else (if BOP.CS.TCV_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then BOP.CS.TCV_PID.limiter.uMax else (if BOP.CS.TCV_PID.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then BOP.CS.TCV_PID.limiter.uMin
       else 0)));
    if (BOP.CS.TCV_PID.limiter.strict) then 
      if (BOP.CS.TCV_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.CS.TCV_PID.limiter.y = smooth(0, noEvent((if BOP.CS.TCV_PID.limiter.u
           > BOP.CS.TCV_PID.limiter.uMax then BOP.CS.TCV_PID.limiter.uMax else (
          if BOP.CS.TCV_PID.limiter.u < BOP.CS.TCV_PID.limiter.uMin then 
          BOP.CS.TCV_PID.limiter.uMin else BOP.CS.TCV_PID.limiter.u))));
      else
        BOP.CS.TCV_PID.limiter.y = homotopy(smooth(0, noEvent((if 
          BOP.CS.TCV_PID.limiter.u > BOP.CS.TCV_PID.limiter.uMax then 
          BOP.CS.TCV_PID.limiter.uMax else (if BOP.CS.TCV_PID.limiter.u < 
          BOP.CS.TCV_PID.limiter.uMin then BOP.CS.TCV_PID.limiter.uMin else 
          BOP.CS.TCV_PID.limiter.u)))), BOP.CS.TCV_PID.limiter.simplifiedExpr);
      end if;
    else
      if (BOP.CS.TCV_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.CS.TCV_PID.limiter.y = smooth(0, (if BOP.CS.TCV_PID.limiter.u > 
          BOP.CS.TCV_PID.limiter.uMax then BOP.CS.TCV_PID.limiter.uMax else (if 
          BOP.CS.TCV_PID.limiter.u < BOP.CS.TCV_PID.limiter.uMin then 
          BOP.CS.TCV_PID.limiter.uMin else BOP.CS.TCV_PID.limiter.u)));
      else
        BOP.CS.TCV_PID.limiter.y = homotopy(smooth(0, (if BOP.CS.TCV_PID.limiter.u
           > BOP.CS.TCV_PID.limiter.uMax then BOP.CS.TCV_PID.limiter.uMax else (
          if BOP.CS.TCV_PID.limiter.u < BOP.CS.TCV_PID.limiter.uMin then 
          BOP.CS.TCV_PID.limiter.uMin else BOP.CS.TCV_PID.limiter.u))), 
          BOP.CS.TCV_PID.limiter.simplifiedExpr);
      end if;
    end if;

  // Component BOP.CS.TCV_PID.Fzero
  // class Modelica.Blocks.Sources.Constant
  equation
    BOP.CS.TCV_PID.Fzero.y = BOP.CS.TCV_PID.Fzero.k;

  // Component BOP.CS.TCV_PID.addFF
  // class Modelica.Blocks.Math.Add3
  equation
    BOP.CS.TCV_PID.addFF.y = BOP.CS.TCV_PID.addFF.k1*BOP.CS.TCV_PID.addFF.u1+
      BOP.CS.TCV_PID.addFF.k2*BOP.CS.TCV_PID.addFF.u2+BOP.CS.TCV_PID.addFF.k3*
      BOP.CS.TCV_PID.addFF.u3;

  // Component BOP.CS.TCV_PID.gain_u_s
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.TCV_PID.gain_u_s.y = BOP.CS.TCV_PID.gain_u_s.k*BOP.CS.TCV_PID.gain_u_s.u;

  // Component BOP.CS.TCV_PID.gain_u_m
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.TCV_PID.gain_u_m.y = BOP.CS.TCV_PID.gain_u_m.k*BOP.CS.TCV_PID.gain_u_m.u;

  // Component BOP.CS.TCV_PID.null_bias
  // class Modelica.Blocks.Sources.Constant
  equation
    BOP.CS.TCV_PID.null_bias.y = BOP.CS.TCV_PID.null_bias.k;

  // Component BOP.CS.TCV_PID.I
  // class TRANSFORM.Blocks.IntegratorWithReset
  equation
    der(BOP.CS.TCV_PID.I.y) = BOP.CS.TCV_PID.I.k*BOP.CS.TCV_PID.I.u;
    if (BOP.CS.TCV_PID.I.reset <> TRANSFORM.Types.Reset.Input) then 
      BOP.CS.TCV_PID.I.y_reset_internal = BOP.CS.TCV_PID.I.y_reset;
    end if;
    if (BOP.CS.TCV_PID.I.reset == TRANSFORM.Types.Reset.Disabled) then 
      BOP.CS.TCV_PID.I.trigger_internal = false;
    else
      when BOP.CS.TCV_PID.I.trigger_internal then
        reinit(BOP.CS.TCV_PID.I.y, BOP.CS.TCV_PID.I.y_reset_internal);
      end when;
    end if;

  // Component BOP.CS.TCV_PID.addI
  // class Modelica.Blocks.Math.Add3
  equation
    BOP.CS.TCV_PID.addI.y = BOP.CS.TCV_PID.addI.k1*BOP.CS.TCV_PID.addI.u1+
      BOP.CS.TCV_PID.addI.k2*BOP.CS.TCV_PID.addI.u2+BOP.CS.TCV_PID.addI.k3*
      BOP.CS.TCV_PID.addI.u3;

  // Component BOP.CS.TCV_PID.addSat
  // class Modelica.Blocks.Math.Add
  equation
    BOP.CS.TCV_PID.addSat.y = BOP.CS.TCV_PID.addSat.k1*BOP.CS.TCV_PID.addSat.u1+
      BOP.CS.TCV_PID.addSat.k2*BOP.CS.TCV_PID.addSat.u2;

  // Component BOP.CS.TCV_PID.gainTrack
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.TCV_PID.gainTrack.y = BOP.CS.TCV_PID.gainTrack.k*BOP.CS.TCV_PID.gainTrack.u;

  // Component BOP.CS.TCV_PID.Dzero
  // class Modelica.Blocks.Sources.Constant
  equation
    BOP.CS.TCV_PID.Dzero.y = BOP.CS.TCV_PID.Dzero.k;

  // Component BOP.CS.TCV_PID
  // class TRANSFORM.Controls.LimPID
  equation
    assert(BOP.CS.TCV_PID.yMax >= BOP.CS.TCV_PID.yMin, "LimPID: Limits must be consistent. However, yMax (="
      +       String(BOP.CS.TCV_PID.yMax, true, 0)+") < yMin (="+       String(
      BOP.CS.TCV_PID.yMin, true, 0)+")");
    if (BOP.CS.TCV_PID.initType == Modelica.Blocks.Types.Init.InitialOutput and 
      (BOP.CS.TCV_PID.y_start < BOP.CS.TCV_PID.yMin or BOP.CS.TCV_PID.y_start > 
      BOP.CS.TCV_PID.yMax)) then 
      ModelicaError("LimPID: Start value y_start (="+       String(
        BOP.CS.TCV_PID.y_start, true, 0)+") is outside of the limits of yMin (="
        +       String(BOP.CS.TCV_PID.yMin, true, 0)+") and yMax (="+
               String(BOP.CS.TCV_PID.yMax, true, 0)+")");
    end if;
    if (BOP.CS.TCV_PID.reset <> TRANSFORM.Types.Reset.Input) then 
      BOP.CS.TCV_PID.y_reset_internal = BOP.CS.TCV_PID.y_reset;
    end if;
    BOP.CS.TCV_PID.addPID.u2 = BOP.CS.TCV_PID.Dzero.y;
    BOP.CS.TCV_PID.addFF.u1 = BOP.CS.TCV_PID.Fzero.y;
    BOP.CS.TCV_PID.addI.y = BOP.CS.TCV_PID.I.u;
    BOP.CS.TCV_PID.addPID.u3 = BOP.CS.TCV_PID.I.y;
    BOP.CS.TCV_PID.addP.y = BOP.CS.TCV_PID.P.u;
    BOP.CS.TCV_PID.addPID.u1 = BOP.CS.TCV_PID.P.y;
    BOP.CS.TCV_PID.gainPID.y = BOP.CS.TCV_PID.addFF.u2;
    BOP.CS.TCV_PID.null_bias.y = BOP.CS.TCV_PID.addFF.u3;
    BOP.CS.TCV_PID.addSat.u2 = BOP.CS.TCV_PID.addFF.y;
    BOP.CS.TCV_PID.limiter.u = BOP.CS.TCV_PID.addFF.y;
    BOP.CS.TCV_PID.addP.u1 = BOP.CS.TCV_PID.addI.u1;
    BOP.CS.TCV_PID.gain_u_s.y = BOP.CS.TCV_PID.addI.u1;
    BOP.CS.TCV_PID.addP.u2 = BOP.CS.TCV_PID.addI.u2;
    BOP.CS.TCV_PID.gain_u_m.y = BOP.CS.TCV_PID.addI.u2;
    BOP.CS.TCV_PID.gainTrack.y = BOP.CS.TCV_PID.addI.u3;
    BOP.CS.TCV_PID.gainPID.u = BOP.CS.TCV_PID.addPID.y;
    BOP.CS.TCV_PID.limiter.y = BOP.CS.TCV_PID.addSat.u1;
    BOP.CS.TCV_PID.y = BOP.CS.TCV_PID.addSat.u1;
    BOP.CS.TCV_PID.gainTrack.u = BOP.CS.TCV_PID.addSat.y;
    BOP.CS.TCV_PID.u_m = BOP.CS.TCV_PID.gain_u_m.u;
    BOP.CS.TCV_PID.u_s = BOP.CS.TCV_PID.gain_u_s.u;

  // Component BOP.CS.LPT1_BV_PID.addP
  // class Modelica.Blocks.Math.Add
  equation
    BOP.CS.LPT1_BV_PID.addP.y = BOP.CS.LPT1_BV_PID.addP.k1*BOP.CS.LPT1_BV_PID.addP.u1
      +BOP.CS.LPT1_BV_PID.addP.k2*BOP.CS.LPT1_BV_PID.addP.u2;

  // Component BOP.CS.LPT1_BV_PID.P
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.LPT1_BV_PID.P.y = BOP.CS.LPT1_BV_PID.P.k*BOP.CS.LPT1_BV_PID.P.u;

  // Component BOP.CS.LPT1_BV_PID.gainPID
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.LPT1_BV_PID.gainPID.y = BOP.CS.LPT1_BV_PID.gainPID.k*BOP.CS.LPT1_BV_PID.gainPID.u;

  // Component BOP.CS.LPT1_BV_PID.addPID
  // class Modelica.Blocks.Math.Add3
  equation
    BOP.CS.LPT1_BV_PID.addPID.y = BOP.CS.LPT1_BV_PID.addPID.k1*BOP.CS.LPT1_BV_PID.addPID.u1
      +BOP.CS.LPT1_BV_PID.addPID.k2*BOP.CS.LPT1_BV_PID.addPID.u2+
      BOP.CS.LPT1_BV_PID.addPID.k3*BOP.CS.LPT1_BV_PID.addPID.u3;

  // Component BOP.CS.LPT1_BV_PID.limiter
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(BOP.CS.LPT1_BV_PID.limiter.uMax >= BOP.CS.LPT1_BV_PID.limiter.uMin, 
      "Limiter: Limits must be consistent. However, uMax (="+       String(
      BOP.CS.LPT1_BV_PID.limiter.uMax, true, 0)+") < uMin (="+       String(
      BOP.CS.LPT1_BV_PID.limiter.uMin, true, 0)+")");
    BOP.CS.LPT1_BV_PID.limiter.simplifiedExpr = (if BOP.CS.LPT1_BV_PID.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.Linear then BOP.CS.LPT1_BV_PID.limiter.u
       else (if BOP.CS.LPT1_BV_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then BOP.CS.LPT1_BV_PID.limiter.uMax else (if BOP.CS.LPT1_BV_PID.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then BOP.CS.LPT1_BV_PID.limiter.uMin
       else 0)));
    if (BOP.CS.LPT1_BV_PID.limiter.strict) then 
      if (BOP.CS.LPT1_BV_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.CS.LPT1_BV_PID.limiter.y = smooth(0, noEvent((if BOP.CS.LPT1_BV_PID.limiter.u
           > BOP.CS.LPT1_BV_PID.limiter.uMax then BOP.CS.LPT1_BV_PID.limiter.uMax
           else (if BOP.CS.LPT1_BV_PID.limiter.u < BOP.CS.LPT1_BV_PID.limiter.uMin
           then BOP.CS.LPT1_BV_PID.limiter.uMin else BOP.CS.LPT1_BV_PID.limiter.u))));
      else
        BOP.CS.LPT1_BV_PID.limiter.y = homotopy(smooth(0, noEvent((if 
          BOP.CS.LPT1_BV_PID.limiter.u > BOP.CS.LPT1_BV_PID.limiter.uMax then 
          BOP.CS.LPT1_BV_PID.limiter.uMax else (if BOP.CS.LPT1_BV_PID.limiter.u
           < BOP.CS.LPT1_BV_PID.limiter.uMin then BOP.CS.LPT1_BV_PID.limiter.uMin
           else BOP.CS.LPT1_BV_PID.limiter.u)))), BOP.CS.LPT1_BV_PID.limiter.simplifiedExpr);
      end if;
    else
      if (BOP.CS.LPT1_BV_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.CS.LPT1_BV_PID.limiter.y = smooth(0, (if BOP.CS.LPT1_BV_PID.limiter.u
           > BOP.CS.LPT1_BV_PID.limiter.uMax then BOP.CS.LPT1_BV_PID.limiter.uMax
           else (if BOP.CS.LPT1_BV_PID.limiter.u < BOP.CS.LPT1_BV_PID.limiter.uMin
           then BOP.CS.LPT1_BV_PID.limiter.uMin else BOP.CS.LPT1_BV_PID.limiter.u)));
      else
        BOP.CS.LPT1_BV_PID.limiter.y = homotopy(smooth(0, (if BOP.CS.LPT1_BV_PID.limiter.u
           > BOP.CS.LPT1_BV_PID.limiter.uMax then BOP.CS.LPT1_BV_PID.limiter.uMax
           else (if BOP.CS.LPT1_BV_PID.limiter.u < BOP.CS.LPT1_BV_PID.limiter.uMin
           then BOP.CS.LPT1_BV_PID.limiter.uMin else BOP.CS.LPT1_BV_PID.limiter.u))),
           BOP.CS.LPT1_BV_PID.limiter.simplifiedExpr);
      end if;
    end if;

  // Component BOP.CS.LPT1_BV_PID.Fzero
  // class Modelica.Blocks.Sources.Constant
  equation
    BOP.CS.LPT1_BV_PID.Fzero.y = BOP.CS.LPT1_BV_PID.Fzero.k;

  // Component BOP.CS.LPT1_BV_PID.addFF
  // class Modelica.Blocks.Math.Add3
  equation
    BOP.CS.LPT1_BV_PID.addFF.y = BOP.CS.LPT1_BV_PID.addFF.k1*BOP.CS.LPT1_BV_PID.addFF.u1
      +BOP.CS.LPT1_BV_PID.addFF.k2*BOP.CS.LPT1_BV_PID.addFF.u2+BOP.CS.LPT1_BV_PID.addFF.k3
      *BOP.CS.LPT1_BV_PID.addFF.u3;

  // Component BOP.CS.LPT1_BV_PID.gain_u_s
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.LPT1_BV_PID.gain_u_s.y = BOP.CS.LPT1_BV_PID.gain_u_s.k*
      BOP.CS.LPT1_BV_PID.gain_u_s.u;

  // Component BOP.CS.LPT1_BV_PID.gain_u_m
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.LPT1_BV_PID.gain_u_m.y = BOP.CS.LPT1_BV_PID.gain_u_m.k*
      BOP.CS.LPT1_BV_PID.gain_u_m.u;

  // Component BOP.CS.LPT1_BV_PID.null_bias
  // class Modelica.Blocks.Sources.Constant
  equation
    BOP.CS.LPT1_BV_PID.null_bias.y = BOP.CS.LPT1_BV_PID.null_bias.k;

  // Component BOP.CS.LPT1_BV_PID.I
  // class TRANSFORM.Blocks.IntegratorWithReset
  equation
    der(BOP.CS.LPT1_BV_PID.I.y) = BOP.CS.LPT1_BV_PID.I.k*BOP.CS.LPT1_BV_PID.I.u;
    if (BOP.CS.LPT1_BV_PID.I.reset <> TRANSFORM.Types.Reset.Input) then 
      BOP.CS.LPT1_BV_PID.I.y_reset_internal = BOP.CS.LPT1_BV_PID.I.y_reset;
    end if;
    if (BOP.CS.LPT1_BV_PID.I.reset == TRANSFORM.Types.Reset.Disabled) then 
      BOP.CS.LPT1_BV_PID.I.trigger_internal = false;
    else
      when BOP.CS.LPT1_BV_PID.I.trigger_internal then
        reinit(BOP.CS.LPT1_BV_PID.I.y, BOP.CS.LPT1_BV_PID.I.y_reset_internal);
      end when;
    end if;

  // Component BOP.CS.LPT1_BV_PID.addI
  // class Modelica.Blocks.Math.Add3
  equation
    BOP.CS.LPT1_BV_PID.addI.y = BOP.CS.LPT1_BV_PID.addI.k1*BOP.CS.LPT1_BV_PID.addI.u1
      +BOP.CS.LPT1_BV_PID.addI.k2*BOP.CS.LPT1_BV_PID.addI.u2+BOP.CS.LPT1_BV_PID.addI.k3
      *BOP.CS.LPT1_BV_PID.addI.u3;

  // Component BOP.CS.LPT1_BV_PID.addSat
  // class Modelica.Blocks.Math.Add
  equation
    BOP.CS.LPT1_BV_PID.addSat.y = BOP.CS.LPT1_BV_PID.addSat.k1*BOP.CS.LPT1_BV_PID.addSat.u1
      +BOP.CS.LPT1_BV_PID.addSat.k2*BOP.CS.LPT1_BV_PID.addSat.u2;

  // Component BOP.CS.LPT1_BV_PID.gainTrack
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.LPT1_BV_PID.gainTrack.y = BOP.CS.LPT1_BV_PID.gainTrack.k*
      BOP.CS.LPT1_BV_PID.gainTrack.u;

  // Component BOP.CS.LPT1_BV_PID.Dzero
  // class Modelica.Blocks.Sources.Constant
  equation
    BOP.CS.LPT1_BV_PID.Dzero.y = BOP.CS.LPT1_BV_PID.Dzero.k;

  // Component BOP.CS.LPT1_BV_PID
  // class TRANSFORM.Controls.LimPID
  equation
    assert(BOP.CS.LPT1_BV_PID.yMax >= BOP.CS.LPT1_BV_PID.yMin, "LimPID: Limits must be consistent. However, yMax (="
      +       String(BOP.CS.LPT1_BV_PID.yMax, true, 0)+") < yMin (="+
             String(BOP.CS.LPT1_BV_PID.yMin, true, 0)+")");
    if (BOP.CS.LPT1_BV_PID.initType == Modelica.Blocks.Types.Init.InitialOutput
       and (BOP.CS.LPT1_BV_PID.y_start < BOP.CS.LPT1_BV_PID.yMin or 
      BOP.CS.LPT1_BV_PID.y_start > BOP.CS.LPT1_BV_PID.yMax)) then 
      ModelicaError("LimPID: Start value y_start (="+       String(
        BOP.CS.LPT1_BV_PID.y_start, true, 0)+") is outside of the limits of yMin (="
        +       String(BOP.CS.LPT1_BV_PID.yMin, true, 0)+") and yMax (="+
               String(BOP.CS.LPT1_BV_PID.yMax, true, 0)+")");
    end if;
    if (BOP.CS.LPT1_BV_PID.reset <> TRANSFORM.Types.Reset.Input) then 
      BOP.CS.LPT1_BV_PID.y_reset_internal = BOP.CS.LPT1_BV_PID.y_reset;
    end if;
    BOP.CS.LPT1_BV_PID.addPID.u2 = BOP.CS.LPT1_BV_PID.Dzero.y;
    BOP.CS.LPT1_BV_PID.addFF.u1 = BOP.CS.LPT1_BV_PID.Fzero.y;
    BOP.CS.LPT1_BV_PID.addI.y = BOP.CS.LPT1_BV_PID.I.u;
    BOP.CS.LPT1_BV_PID.addPID.u3 = BOP.CS.LPT1_BV_PID.I.y;
    BOP.CS.LPT1_BV_PID.addP.y = BOP.CS.LPT1_BV_PID.P.u;
    BOP.CS.LPT1_BV_PID.addPID.u1 = BOP.CS.LPT1_BV_PID.P.y;
    BOP.CS.LPT1_BV_PID.gainPID.y = BOP.CS.LPT1_BV_PID.addFF.u2;
    BOP.CS.LPT1_BV_PID.null_bias.y = BOP.CS.LPT1_BV_PID.addFF.u3;
    BOP.CS.LPT1_BV_PID.addSat.u2 = BOP.CS.LPT1_BV_PID.addFF.y;
    BOP.CS.LPT1_BV_PID.limiter.u = BOP.CS.LPT1_BV_PID.addFF.y;
    BOP.CS.LPT1_BV_PID.addP.u1 = BOP.CS.LPT1_BV_PID.addI.u1;
    BOP.CS.LPT1_BV_PID.gain_u_s.y = BOP.CS.LPT1_BV_PID.addI.u1;
    BOP.CS.LPT1_BV_PID.addP.u2 = BOP.CS.LPT1_BV_PID.addI.u2;
    BOP.CS.LPT1_BV_PID.gain_u_m.y = BOP.CS.LPT1_BV_PID.addI.u2;
    BOP.CS.LPT1_BV_PID.gainTrack.y = BOP.CS.LPT1_BV_PID.addI.u3;
    BOP.CS.LPT1_BV_PID.gainPID.u = BOP.CS.LPT1_BV_PID.addPID.y;
    BOP.CS.LPT1_BV_PID.limiter.y = BOP.CS.LPT1_BV_PID.addSat.u1;
    BOP.CS.LPT1_BV_PID.y = BOP.CS.LPT1_BV_PID.addSat.u1;
    BOP.CS.LPT1_BV_PID.gainTrack.u = BOP.CS.LPT1_BV_PID.addSat.y;
    BOP.CS.LPT1_BV_PID.u_m = BOP.CS.LPT1_BV_PID.gain_u_m.u;
    BOP.CS.LPT1_BV_PID.u_s = BOP.CS.LPT1_BV_PID.gain_u_s.u;

  // Component BOP.CS.LPT2_BV_PID.addP
  // class Modelica.Blocks.Math.Add
  equation
    BOP.CS.LPT2_BV_PID.addP.y = BOP.CS.LPT2_BV_PID.addP.k1*BOP.CS.LPT2_BV_PID.addP.u1
      +BOP.CS.LPT2_BV_PID.addP.k2*BOP.CS.LPT2_BV_PID.addP.u2;

  // Component BOP.CS.LPT2_BV_PID.P
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.LPT2_BV_PID.P.y = BOP.CS.LPT2_BV_PID.P.k*BOP.CS.LPT2_BV_PID.P.u;

  // Component BOP.CS.LPT2_BV_PID.gainPID
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.LPT2_BV_PID.gainPID.y = BOP.CS.LPT2_BV_PID.gainPID.k*BOP.CS.LPT2_BV_PID.gainPID.u;

  // Component BOP.CS.LPT2_BV_PID.addPID
  // class Modelica.Blocks.Math.Add3
  equation
    BOP.CS.LPT2_BV_PID.addPID.y = BOP.CS.LPT2_BV_PID.addPID.k1*BOP.CS.LPT2_BV_PID.addPID.u1
      +BOP.CS.LPT2_BV_PID.addPID.k2*BOP.CS.LPT2_BV_PID.addPID.u2+
      BOP.CS.LPT2_BV_PID.addPID.k3*BOP.CS.LPT2_BV_PID.addPID.u3;

  // Component BOP.CS.LPT2_BV_PID.limiter
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(BOP.CS.LPT2_BV_PID.limiter.uMax >= BOP.CS.LPT2_BV_PID.limiter.uMin, 
      "Limiter: Limits must be consistent. However, uMax (="+       String(
      BOP.CS.LPT2_BV_PID.limiter.uMax, true, 0)+") < uMin (="+       String(
      BOP.CS.LPT2_BV_PID.limiter.uMin, true, 0)+")");
    BOP.CS.LPT2_BV_PID.limiter.simplifiedExpr = (if BOP.CS.LPT2_BV_PID.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.Linear then BOP.CS.LPT2_BV_PID.limiter.u
       else (if BOP.CS.LPT2_BV_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then BOP.CS.LPT2_BV_PID.limiter.uMax else (if BOP.CS.LPT2_BV_PID.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then BOP.CS.LPT2_BV_PID.limiter.uMin
       else 0)));
    if (BOP.CS.LPT2_BV_PID.limiter.strict) then 
      if (BOP.CS.LPT2_BV_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.CS.LPT2_BV_PID.limiter.y = smooth(0, noEvent((if BOP.CS.LPT2_BV_PID.limiter.u
           > BOP.CS.LPT2_BV_PID.limiter.uMax then BOP.CS.LPT2_BV_PID.limiter.uMax
           else (if BOP.CS.LPT2_BV_PID.limiter.u < BOP.CS.LPT2_BV_PID.limiter.uMin
           then BOP.CS.LPT2_BV_PID.limiter.uMin else BOP.CS.LPT2_BV_PID.limiter.u))));
      else
        BOP.CS.LPT2_BV_PID.limiter.y = homotopy(smooth(0, noEvent((if 
          BOP.CS.LPT2_BV_PID.limiter.u > BOP.CS.LPT2_BV_PID.limiter.uMax then 
          BOP.CS.LPT2_BV_PID.limiter.uMax else (if BOP.CS.LPT2_BV_PID.limiter.u
           < BOP.CS.LPT2_BV_PID.limiter.uMin then BOP.CS.LPT2_BV_PID.limiter.uMin
           else BOP.CS.LPT2_BV_PID.limiter.u)))), BOP.CS.LPT2_BV_PID.limiter.simplifiedExpr);
      end if;
    else
      if (BOP.CS.LPT2_BV_PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.CS.LPT2_BV_PID.limiter.y = smooth(0, (if BOP.CS.LPT2_BV_PID.limiter.u
           > BOP.CS.LPT2_BV_PID.limiter.uMax then BOP.CS.LPT2_BV_PID.limiter.uMax
           else (if BOP.CS.LPT2_BV_PID.limiter.u < BOP.CS.LPT2_BV_PID.limiter.uMin
           then BOP.CS.LPT2_BV_PID.limiter.uMin else BOP.CS.LPT2_BV_PID.limiter.u)));
      else
        BOP.CS.LPT2_BV_PID.limiter.y = homotopy(smooth(0, (if BOP.CS.LPT2_BV_PID.limiter.u
           > BOP.CS.LPT2_BV_PID.limiter.uMax then BOP.CS.LPT2_BV_PID.limiter.uMax
           else (if BOP.CS.LPT2_BV_PID.limiter.u < BOP.CS.LPT2_BV_PID.limiter.uMin
           then BOP.CS.LPT2_BV_PID.limiter.uMin else BOP.CS.LPT2_BV_PID.limiter.u))),
           BOP.CS.LPT2_BV_PID.limiter.simplifiedExpr);
      end if;
    end if;

  // Component BOP.CS.LPT2_BV_PID.Fzero
  // class Modelica.Blocks.Sources.Constant
  equation
    BOP.CS.LPT2_BV_PID.Fzero.y = BOP.CS.LPT2_BV_PID.Fzero.k;

  // Component BOP.CS.LPT2_BV_PID.addFF
  // class Modelica.Blocks.Math.Add3
  equation
    BOP.CS.LPT2_BV_PID.addFF.y = BOP.CS.LPT2_BV_PID.addFF.k1*BOP.CS.LPT2_BV_PID.addFF.u1
      +BOP.CS.LPT2_BV_PID.addFF.k2*BOP.CS.LPT2_BV_PID.addFF.u2+BOP.CS.LPT2_BV_PID.addFF.k3
      *BOP.CS.LPT2_BV_PID.addFF.u3;

  // Component BOP.CS.LPT2_BV_PID.gain_u_s
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.LPT2_BV_PID.gain_u_s.y = BOP.CS.LPT2_BV_PID.gain_u_s.k*
      BOP.CS.LPT2_BV_PID.gain_u_s.u;

  // Component BOP.CS.LPT2_BV_PID.gain_u_m
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.LPT2_BV_PID.gain_u_m.y = BOP.CS.LPT2_BV_PID.gain_u_m.k*
      BOP.CS.LPT2_BV_PID.gain_u_m.u;

  // Component BOP.CS.LPT2_BV_PID.null_bias
  // class Modelica.Blocks.Sources.Constant
  equation
    BOP.CS.LPT2_BV_PID.null_bias.y = BOP.CS.LPT2_BV_PID.null_bias.k;

  // Component BOP.CS.LPT2_BV_PID.I
  // class TRANSFORM.Blocks.IntegratorWithReset
  equation
    der(BOP.CS.LPT2_BV_PID.I.y) = BOP.CS.LPT2_BV_PID.I.k*BOP.CS.LPT2_BV_PID.I.u;
    if (BOP.CS.LPT2_BV_PID.I.reset <> TRANSFORM.Types.Reset.Input) then 
      BOP.CS.LPT2_BV_PID.I.y_reset_internal = BOP.CS.LPT2_BV_PID.I.y_reset;
    end if;
    if (BOP.CS.LPT2_BV_PID.I.reset == TRANSFORM.Types.Reset.Disabled) then 
      BOP.CS.LPT2_BV_PID.I.trigger_internal = false;
    else
      when BOP.CS.LPT2_BV_PID.I.trigger_internal then
        reinit(BOP.CS.LPT2_BV_PID.I.y, BOP.CS.LPT2_BV_PID.I.y_reset_internal);
      end when;
    end if;

  // Component BOP.CS.LPT2_BV_PID.addI
  // class Modelica.Blocks.Math.Add3
  equation
    BOP.CS.LPT2_BV_PID.addI.y = BOP.CS.LPT2_BV_PID.addI.k1*BOP.CS.LPT2_BV_PID.addI.u1
      +BOP.CS.LPT2_BV_PID.addI.k2*BOP.CS.LPT2_BV_PID.addI.u2+BOP.CS.LPT2_BV_PID.addI.k3
      *BOP.CS.LPT2_BV_PID.addI.u3;

  // Component BOP.CS.LPT2_BV_PID.addSat
  // class Modelica.Blocks.Math.Add
  equation
    BOP.CS.LPT2_BV_PID.addSat.y = BOP.CS.LPT2_BV_PID.addSat.k1*BOP.CS.LPT2_BV_PID.addSat.u1
      +BOP.CS.LPT2_BV_PID.addSat.k2*BOP.CS.LPT2_BV_PID.addSat.u2;

  // Component BOP.CS.LPT2_BV_PID.gainTrack
  // class Modelica.Blocks.Math.Gain
  equation
    BOP.CS.LPT2_BV_PID.gainTrack.y = BOP.CS.LPT2_BV_PID.gainTrack.k*
      BOP.CS.LPT2_BV_PID.gainTrack.u;

  // Component BOP.CS.LPT2_BV_PID.Dzero
  // class Modelica.Blocks.Sources.Constant
  equation
    BOP.CS.LPT2_BV_PID.Dzero.y = BOP.CS.LPT2_BV_PID.Dzero.k;

  // Component BOP.CS.LPT2_BV_PID
  // class TRANSFORM.Controls.LimPID
  equation
    assert(BOP.CS.LPT2_BV_PID.yMax >= BOP.CS.LPT2_BV_PID.yMin, "LimPID: Limits must be consistent. However, yMax (="
      +       String(BOP.CS.LPT2_BV_PID.yMax, true, 0)+") < yMin (="+
             String(BOP.CS.LPT2_BV_PID.yMin, true, 0)+")");
    if (BOP.CS.LPT2_BV_PID.initType == Modelica.Blocks.Types.Init.InitialOutput
       and (BOP.CS.LPT2_BV_PID.y_start < BOP.CS.LPT2_BV_PID.yMin or 
      BOP.CS.LPT2_BV_PID.y_start > BOP.CS.LPT2_BV_PID.yMax)) then 
      ModelicaError("LimPID: Start value y_start (="+       String(
        BOP.CS.LPT2_BV_PID.y_start, true, 0)+") is outside of the limits of yMin (="
        +       String(BOP.CS.LPT2_BV_PID.yMin, true, 0)+") and yMax (="+
               String(BOP.CS.LPT2_BV_PID.yMax, true, 0)+")");
    end if;
    if (BOP.CS.LPT2_BV_PID.reset <> TRANSFORM.Types.Reset.Input) then 
      BOP.CS.LPT2_BV_PID.y_reset_internal = BOP.CS.LPT2_BV_PID.y_reset;
    end if;
    BOP.CS.LPT2_BV_PID.addPID.u2 = BOP.CS.LPT2_BV_PID.Dzero.y;
    BOP.CS.LPT2_BV_PID.addFF.u1 = BOP.CS.LPT2_BV_PID.Fzero.y;
    BOP.CS.LPT2_BV_PID.addI.y = BOP.CS.LPT2_BV_PID.I.u;
    BOP.CS.LPT2_BV_PID.addPID.u3 = BOP.CS.LPT2_BV_PID.I.y;
    BOP.CS.LPT2_BV_PID.addP.y = BOP.CS.LPT2_BV_PID.P.u;
    BOP.CS.LPT2_BV_PID.addPID.u1 = BOP.CS.LPT2_BV_PID.P.y;
    BOP.CS.LPT2_BV_PID.gainPID.y = BOP.CS.LPT2_BV_PID.addFF.u2;
    BOP.CS.LPT2_BV_PID.null_bias.y = BOP.CS.LPT2_BV_PID.addFF.u3;
    BOP.CS.LPT2_BV_PID.addSat.u2 = BOP.CS.LPT2_BV_PID.addFF.y;
    BOP.CS.LPT2_BV_PID.limiter.u = BOP.CS.LPT2_BV_PID.addFF.y;
    BOP.CS.LPT2_BV_PID.addP.u1 = BOP.CS.LPT2_BV_PID.addI.u1;
    BOP.CS.LPT2_BV_PID.gain_u_s.y = BOP.CS.LPT2_BV_PID.addI.u1;
    BOP.CS.LPT2_BV_PID.addP.u2 = BOP.CS.LPT2_BV_PID.addI.u2;
    BOP.CS.LPT2_BV_PID.gain_u_m.y = BOP.CS.LPT2_BV_PID.addI.u2;
    BOP.CS.LPT2_BV_PID.gainTrack.y = BOP.CS.LPT2_BV_PID.addI.u3;
    BOP.CS.LPT2_BV_PID.gainPID.u = BOP.CS.LPT2_BV_PID.addPID.y;
    BOP.CS.LPT2_BV_PID.limiter.y = BOP.CS.LPT2_BV_PID.addSat.u1;
    BOP.CS.LPT2_BV_PID.y = BOP.CS.LPT2_BV_PID.addSat.u1;
    BOP.CS.LPT2_BV_PID.gainTrack.u = BOP.CS.LPT2_BV_PID.addSat.y;
    BOP.CS.LPT2_BV_PID.u_m = BOP.CS.LPT2_BV_PID.gain_u_m.u;
    BOP.CS.LPT2_BV_PID.u_s = BOP.CS.LPT2_BV_PID.gain_u_s.u;

  // Component BOP.CS.hysteresis
  // class Modelica.Blocks.Logical.Hysteresis
  equation
    assert(BOP.CS.hysteresis.uHigh > BOP.CS.hysteresis.uLow, "Hysteresis limits wrong (uHigh <= uLow)");
    BOP.CS.hysteresis.y =  not pre(BOP.CS.hysteresis.y) and BOP.CS.hysteresis.u
       > BOP.CS.hysteresis.uHigh or pre(BOP.CS.hysteresis.y) and 
      BOP.CS.hysteresis.u >= BOP.CS.hysteresis.uLow;

  // Component BOP.CS.switch1
  // class Modelica.Blocks.Logical.Switch
  equation
    BOP.CS.switch1.y = (if BOP.CS.switch1.u2 then BOP.CS.switch1.u1 else 
      BOP.CS.switch1.u3);

  // Component BOP.CS.ramp
  // class Modelica.Blocks.Sources.Ramp
  equation
    BOP.CS.ramp.y = BOP.CS.ramp.offset+(if time < BOP.CS.ramp.startTime then 0
       else (if time < BOP.CS.ramp.startTime+BOP.CS.ramp.duration then (time-
      BOP.CS.ramp.startTime)*BOP.CS.ramp.height/BOP.CS.ramp.duration else 
      BOP.CS.ramp.height));

  // Component BOP.CS.product1
  // class Modelica.Blocks.Math.Product
  equation
    BOP.CS.product1.y = BOP.CS.product1.u1*BOP.CS.product1.u2;

  // Component BOP.CS.switch2
  // class Modelica.Blocks.Logical.Switch
  equation
    BOP.CS.switch2.y = (if BOP.CS.switch2.u2 then BOP.CS.switch2.u1 else 
      BOP.CS.switch2.u3);

  // Component BOP.CS.booleanStep
  // class Modelica.Blocks.Sources.BooleanStep
  equation
    BOP.CS.booleanStep.y = (if time >= BOP.CS.booleanStep.startTime then  not 
      BOP.CS.booleanStep.startValue else BOP.CS.booleanStep.startValue);

  // Component BOP.CS.switch3
  // class Modelica.Blocks.Logical.Switch
  equation
    BOP.CS.switch3.y = (if BOP.CS.switch3.u2 then BOP.CS.switch3.u1 else 
      BOP.CS.switch3.u3);

  // Component BOP.CS.switch4
  // class Modelica.Blocks.Logical.Switch
  equation
    BOP.CS.switch4.y = (if BOP.CS.switch4.u2 then BOP.CS.switch4.u1 else 
      BOP.CS.switch4.u3);

  // Component BOP.CS.booleanStep1
  // class Modelica.Blocks.Sources.BooleanStep
  equation
    BOP.CS.booleanStep1.y = (if time >= BOP.CS.booleanStep1.startTime then  not 
      BOP.CS.booleanStep1.startValue else BOP.CS.booleanStep1.startValue);

  // Component BOP.CS.switch5
  // class Modelica.Blocks.Logical.Switch
  equation
    BOP.CS.switch5.y = (if BOP.CS.switch5.u2 then BOP.CS.switch5.u1 else 
      BOP.CS.switch5.u3);

  // Component BOP.CS.switch6
  // class Modelica.Blocks.Logical.Switch
  equation
    BOP.CS.switch6.y = (if BOP.CS.switch6.u2 then BOP.CS.switch6.u1 else 
      BOP.CS.switch6.u3);

  // Component BOP.CS.booleanStep2
  // class Modelica.Blocks.Sources.BooleanStep
  equation
    BOP.CS.booleanStep2.y = (if time >= BOP.CS.booleanStep2.startTime then  not 
      BOP.CS.booleanStep2.startValue else BOP.CS.booleanStep2.startValue);

  // Component BOP.CS.switch7
  // class Modelica.Blocks.Logical.Switch
  equation
    BOP.CS.switch7.y = (if BOP.CS.switch7.u2 then BOP.CS.switch7.u1 else 
      BOP.CS.switch7.u3);

  // Component BOP.CS.ext_pos_start
  // class Modelica.Blocks.Sources.Ramp
  equation
    BOP.CS.ext_pos_start.y = BOP.CS.ext_pos_start.offset+(if time < 
      BOP.CS.ext_pos_start.startTime then 0 else (if time < BOP.CS.ext_pos_start.startTime
      +BOP.CS.ext_pos_start.duration then (time-BOP.CS.ext_pos_start.startTime)*
      BOP.CS.ext_pos_start.height/BOP.CS.ext_pos_start.duration else 
      BOP.CS.ext_pos_start.height));

  // Component BOP.CS
  // class NHES.Systems.BalanceOfPlant.RankineCycle.ControlSystems.CS_L3_HTGR_extraction_logan_newDataPackage4Turbines
  equation
    BOP.CS.switch3.y = BOP.CS.FeedPump_PID.u_m;
    BOP.CS.T_in_set.y = BOP.CS.FeedPump_PID.u_s;
    BOP.CS.switch3.u3 = BOP.CS.FeedPump_PID.u_s;
    BOP.CS.switch2.u1 = BOP.CS.FeedPump_PID.y;
    BOP.CS.switch6.y = BOP.CS.LPT1_BV_PID.u_m;
    BOP.CS.Steam_Extraction.y = BOP.CS.LPT1_BV_PID.u_s;
    BOP.CS.switch6.u3 = BOP.CS.LPT1_BV_PID.u_s;
    BOP.CS.switch7.u1 = BOP.CS.LPT1_BV_PID.y;
    BOP.CS.switch4.y = BOP.CS.LPT2_BV_PID.u_m;
    BOP.CS.T_feed_set.y = BOP.CS.LPT2_BV_PID.u_s;
    BOP.CS.switch4.u3 = BOP.CS.LPT2_BV_PID.u_s;
    BOP.CS.switch5.u1 = BOP.CS.LPT2_BV_PID.y;
    BOP.CS.switch1.u3 = BOP.CS.P_dump_open0.y;
    BOP.CS.switch1.u1 = BOP.CS.P_dump_open1.y;
    BOP.CS.TCV_PID.u_s = BOP.CS.P_in_set.y;
    BOP.CS.hysteresis.u = BOP.CS.TCV_PID.u_m;
    BOP.CS.sensorBus.Steam_Pressure = BOP.CS.TCV_PID.u_m;
    BOP.CS.actuatorBus.opening_TCV = BOP.CS.TCV_PID.y;
    BOP.CS.switch2.u3 = BOP.CS.T_in_set1.y;
    BOP.CS.switch5.u3 = BOP.CS.T_in_set2.y;
    BOP.CS.switch2.y = BOP.CS.actuatorBus.Feed_Pump_Speed;
    BOP.CS.switch7.y = BOP.CS.actuatorBus.LPT1_BV;
    BOP.CS.switch5.y = BOP.CS.actuatorBus.LPT2_BV;
    BOP.CS.product1.y = BOP.CS.actuatorBus.TBV;
    BOP.CS.switch2.u2 = BOP.CS.booleanStep.y;
    BOP.CS.switch3.u2 = BOP.CS.booleanStep.y;
    BOP.CS.switch4.u2 = BOP.CS.booleanStep1.y;
    BOP.CS.switch5.u2 = BOP.CS.booleanStep1.y;
    BOP.CS.switch6.u2 = BOP.CS.booleanStep2.y;
    BOP.CS.switch7.u2 = BOP.CS.booleanStep2.y;
    BOP.CS.switch7.u3 = BOP.CS.ext_pos_start.y;
    BOP.CS.switch1.u2 = BOP.CS.hysteresis.y;
    BOP.CS.switch1.y = BOP.CS.product1.u1;
    BOP.CS.ramp.y = BOP.CS.product1.u2;
    BOP.CS.switch6.u1 = BOP.CS.sensorBus.Extract_flow;
    BOP.CS.switch4.u1 = BOP.CS.sensorBus.Feedwater_Temp;
    BOP.CS.switch3.u1 = BOP.CS.sensorBus.Steam_Temperature;

  // Component BOP.HPT.eta_wetSteam
  // class NHES.Systems.BalanceOfPlant.RankineCycle.Models.SteamTurbine_L3_HPOFWHsimplified_sec_RealExpressionswitch_FWHExtractionLPT.Eta_wetSteam
    // extends TRANSFORM.Fluid.Machines.BaseClasses.WetSteamEfficiency.eta_Constant
    equation
      BOP.HPT.eta_wetSteam.eta = BOP.HPT.eta_wetSteam.eta_nominal;
    // end of extends 

  // Component BOP.HPT
  // class TRANSFORM.Fluid.Machines.SteamTurbine
    // extends TRANSFORM.Fluid.Machines.BaseClasses.SteamTurbineBase
    equation
      BOP.HPT.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(
        BOP.HPT.portHP.p, inStream(BOP.HPT.portHP.h_outflow), inStream(
        BOP.HPT.portHP.Xi_outflow), 0, 0);
      BOP.HPT.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(
        BOP.HPT.portLP.p, inStream(BOP.HPT.portLP.h_outflow), inStream(
        BOP.HPT.portLP.Xi_outflow), 0, 0);
      BOP.HPT.p_ratio = BOP.HPT.p_out/BOP.HPT.p_in;
      if (cardinality(BOP.HPT.partialArc) == 0) then 
        BOP.HPT.partialArc = 1.0;
      end if;
      BOP.HPT.h_is = Modelica.Media.Water.WaterIF97_ph.isentropicEnthalpy_Unique17
        (
        BOP.HPT.portLP.p, 
        BOP.HPT.state_a);
      BOP.HPT.eta_is = BOP.HPT.eta_wetSteam.eta;
      BOP.HPT.h_in-BOP.HPT.h_out = BOP.HPT.eta_is*(BOP.HPT.h_in-BOP.HPT.h_is);
      BOP.HPT.Q_mech = BOP.HPT.eta_mech*BOP.HPT.m_flow*(BOP.HPT.h_in-
        BOP.HPT.h_out);
      sum(BOP.HPT.Q_units) =  -BOP.HPT.omega*BOP.HPT.tau;
      BOP.HPT.Qbs = BOP.HPT.Q_mech*BOP.HPT.Q_fracs-BOP.HPT.Q_units;
      if (BOP.HPT.energyDynamics == TRANSFORM.Types.Dynamics.SteadyState) then 
        for i in (1:BOP.HPT.nUnits) loop
          0 = BOP.HPT.Qbs[i];
        end for;
      else
        for i in (1:BOP.HPT.nUnits) loop
          BOP.HPT.taus[i]*der(BOP.HPT.Q_units[i]) = BOP.HPT.Qbs[i];
        end for;
      end if;
      BOP.HPT.portHP.m_flow+BOP.HPT.portLP.m_flow = 0;
      BOP.HPT.tau = BOP.HPT.shaft_a.tau+BOP.HPT.shaft_b.tau;
      BOP.HPT.shaft_a.phi = BOP.HPT.phi;
      BOP.HPT.shaft_b.phi = BOP.HPT.phi;
      der(BOP.HPT.phi) = BOP.HPT.omega;
      BOP.HPT.h_in = inStream(BOP.HPT.portHP.h_outflow);
      BOP.HPT.m_flow = BOP.HPT.portHP.m_flow;
      BOP.HPT.portHP.p = BOP.HPT.p_in;
      BOP.HPT.portLP.p = BOP.HPT.p_out;
      BOP.HPT.portHP.h_outflow = inStream(BOP.HPT.portLP.h_outflow)+BOP.HPT.h_in
        -BOP.HPT.h_out;
      BOP.HPT.portHP.Xi_outflow = inStream(BOP.HPT.portLP.Xi_outflow);
      BOP.HPT.portHP.C_outflow = inStream(BOP.HPT.portLP.C_outflow);
      BOP.HPT.portLP.h_outflow = inStream(BOP.HPT.portHP.h_outflow)+
        BOP.HPT.h_out-BOP.HPT.h_in;
      BOP.HPT.portLP.Xi_outflow = inStream(BOP.HPT.portHP.Xi_outflow);
      BOP.HPT.portLP.C_outflow = inStream(BOP.HPT.portHP.C_outflow);
      BOP.HPT.x_th_in = (BOP.HPT.h_in-BOP.HPT.h_fsat_in)/max(BOP.HPT.h_gsat_in-
        BOP.HPT.h_fsat_in, 1E-06);
      BOP.HPT.x_th_out = (BOP.HPT.h_out-BOP.HPT.h_fsat_out)/max(BOP.HPT.h_gsat_out
        -BOP.HPT.h_fsat_out, 1E-06);
      BOP.HPT.x_abs_in = noEvent((if BOP.HPT.p_in/BOP.HPT.p_crit < 1.0 then max(
        0.0, min(1.0, BOP.HPT.x_th_in)) else 1.0));
      BOP.HPT.x_abs_out = noEvent((if BOP.HPT.p_out/BOP.HPT.p_crit < 1.0 then 
        max(0.0, min(1.0, BOP.HPT.x_th_out)) else 1.0));
    // end of extends 
  equation
    if (BOP.HPT.use_Stodola) then 
      BOP.HPT.m_flow = homotopy(BOP.HPT.Kt*BOP.HPT.partialArc*sqrt(BOP.HPT.p_in*
        Modelica.Media.Water.WaterIF97_ph.density_Unique30(
        BOP.HPT.state_a))*Modelica.Fluid.Utilities.regRoot(1-BOP.HPT.p_ratio^2, 
        0.01), BOP.HPT.partialArc/BOP.HPT.partialArc_nominal*BOP.HPT.m_flow_nominal
        /BOP.HPT.p_inlet_nominal*BOP.HPT.p_in);
    else
      BOP.HPT.m_flow = homotopy(BOP.HPT.portHP.p*BOP.HPT.partialArc*
        BOP.HPT.m_flow_nominal/BOP.HPT.p_inlet_nominal, BOP.HPT.partialArc/
        BOP.HPT.partialArc_nominal*BOP.HPT.m_flow_nominal/BOP.HPT.p_inlet_nominal
        *BOP.HPT.p_in);
    end if;

  // Component BOP.LPT1.eta_wetSteam
  // class NHES.Systems.BalanceOfPlant.RankineCycle.Models.SteamTurbine_L3_HPOFWHsimplified_sec_RealExpressionswitch_FWHExtractionLPT.Eta_wetSteam
    // extends TRANSFORM.Fluid.Machines.BaseClasses.WetSteamEfficiency.eta_Constant
    equation
      BOP.LPT1.eta_wetSteam.eta = BOP.LPT1.eta_wetSteam.eta_nominal;
    // end of extends 

  // Component BOP.LPT1
  // class TRANSFORM.Fluid.Machines.SteamTurbine
    // extends TRANSFORM.Fluid.Machines.BaseClasses.SteamTurbineBase
    equation
      BOP.LPT1.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19
        (BOP.LPT1.portHP.p, inStream(BOP.LPT1.portHP.h_outflow), inStream(
        BOP.LPT1.portHP.Xi_outflow), 0, 0);
      BOP.LPT1.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19
        (BOP.LPT1.portLP.p, inStream(BOP.LPT1.portLP.h_outflow), inStream(
        BOP.LPT1.portLP.Xi_outflow), 0, 0);
      BOP.LPT1.p_ratio = BOP.LPT1.p_out/BOP.LPT1.p_in;
      if (cardinality(BOP.LPT1.partialArc) == 0) then 
        BOP.LPT1.partialArc = 1.0;
      end if;
      BOP.LPT1.h_is = Modelica.Media.Water.WaterIF97_ph.isentropicEnthalpy_Unique17
        (
        BOP.LPT1.portLP.p, 
        BOP.LPT1.state_a);
      BOP.LPT1.eta_is = BOP.LPT1.eta_wetSteam.eta;
      BOP.LPT1.h_in-BOP.LPT1.h_out = BOP.LPT1.eta_is*(BOP.LPT1.h_in-
        BOP.LPT1.h_is);
      BOP.LPT1.Q_mech = BOP.LPT1.eta_mech*BOP.LPT1.m_flow*(BOP.LPT1.h_in-
        BOP.LPT1.h_out);
      sum(BOP.LPT1.Q_units) =  -BOP.LPT1.omega*BOP.LPT1.tau;
      BOP.LPT1.Qbs = BOP.LPT1.Q_mech*BOP.LPT1.Q_fracs-BOP.LPT1.Q_units;
      if (BOP.LPT1.energyDynamics == TRANSFORM.Types.Dynamics.SteadyState) then 
        for i in (1:BOP.LPT1.nUnits) loop
          0 = BOP.LPT1.Qbs[i];
        end for;
      else
        for i in (1:BOP.LPT1.nUnits) loop
          BOP.LPT1.taus[i]*der(BOP.LPT1.Q_units[i]) = BOP.LPT1.Qbs[i];
        end for;
      end if;
      BOP.LPT1.portHP.m_flow+BOP.LPT1.portLP.m_flow = 0;
      BOP.LPT1.tau = BOP.LPT1.shaft_a.tau+BOP.LPT1.shaft_b.tau;
      BOP.LPT1.shaft_a.phi = BOP.LPT1.phi;
      BOP.LPT1.shaft_b.phi = BOP.LPT1.phi;
      der(BOP.LPT1.phi) = BOP.LPT1.omega;
      BOP.LPT1.h_in = inStream(BOP.LPT1.portHP.h_outflow);
      BOP.LPT1.m_flow = BOP.LPT1.portHP.m_flow;
      BOP.LPT1.portHP.p = BOP.LPT1.p_in;
      BOP.LPT1.portLP.p = BOP.LPT1.p_out;
      BOP.LPT1.portHP.h_outflow = inStream(BOP.LPT1.portLP.h_outflow)+
        BOP.LPT1.h_in-BOP.LPT1.h_out;
      BOP.LPT1.portHP.Xi_outflow = inStream(BOP.LPT1.portLP.Xi_outflow);
      BOP.LPT1.portHP.C_outflow = inStream(BOP.LPT1.portLP.C_outflow);
      BOP.LPT1.portLP.h_outflow = inStream(BOP.LPT1.portHP.h_outflow)+
        BOP.LPT1.h_out-BOP.LPT1.h_in;
      BOP.LPT1.portLP.Xi_outflow = inStream(BOP.LPT1.portHP.Xi_outflow);
      BOP.LPT1.portLP.C_outflow = inStream(BOP.LPT1.portHP.C_outflow);
      BOP.LPT1.x_th_in = (BOP.LPT1.h_in-BOP.LPT1.h_fsat_in)/max(BOP.LPT1.h_gsat_in
        -BOP.LPT1.h_fsat_in, 1E-06);
      BOP.LPT1.x_th_out = (BOP.LPT1.h_out-BOP.LPT1.h_fsat_out)/max(
        BOP.LPT1.h_gsat_out-BOP.LPT1.h_fsat_out, 1E-06);
      BOP.LPT1.x_abs_in = noEvent((if BOP.LPT1.p_in/BOP.LPT1.p_crit < 1.0 then 
        max(0.0, min(1.0, BOP.LPT1.x_th_in)) else 1.0));
      BOP.LPT1.x_abs_out = noEvent((if BOP.LPT1.p_out/BOP.LPT1.p_crit < 1.0
         then max(0.0, min(1.0, BOP.LPT1.x_th_out)) else 1.0));
    // end of extends 
  equation
    if (BOP.LPT1.use_Stodola) then 
      BOP.LPT1.m_flow = homotopy(BOP.LPT1.Kt*BOP.LPT1.partialArc*sqrt(
        BOP.LPT1.p_in*Modelica.Media.Water.WaterIF97_ph.density_Unique30(
        BOP.LPT1.state_a))*Modelica.Fluid.Utilities.regRoot(1-BOP.LPT1.p_ratio^2,
         0.01), BOP.LPT1.partialArc/BOP.LPT1.partialArc_nominal*BOP.LPT1.m_flow_nominal
        /BOP.LPT1.p_inlet_nominal*BOP.LPT1.p_in);
    else
      BOP.LPT1.m_flow = homotopy(BOP.LPT1.portHP.p*BOP.LPT1.partialArc*
        BOP.LPT1.m_flow_nominal/BOP.LPT1.p_inlet_nominal, BOP.LPT1.partialArc/
        BOP.LPT1.partialArc_nominal*BOP.LPT1.m_flow_nominal/BOP.LPT1.p_inlet_nominal
        *BOP.LPT1.p_in);
    end if;

  // Component BOP.LPT2.eta_wetSteam
  // class NHES.Systems.BalanceOfPlant.RankineCycle.Models.SteamTurbine_L3_HPOFWHsimplified_sec_RealExpressionswitch_FWHExtractionLPT.Eta_wetSteam
    // extends TRANSFORM.Fluid.Machines.BaseClasses.WetSteamEfficiency.eta_Constant
    equation
      BOP.LPT2.eta_wetSteam.eta = BOP.LPT2.eta_wetSteam.eta_nominal;
    // end of extends 

  // Component BOP.LPT2
  // class TRANSFORM.Fluid.Machines.SteamTurbine
    // extends TRANSFORM.Fluid.Machines.BaseClasses.SteamTurbineBase
    equation
      BOP.LPT2.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19
        (BOP.LPT2.portHP.p, inStream(BOP.LPT2.portHP.h_outflow), inStream(
        BOP.LPT2.portHP.Xi_outflow), 0, 0);
      BOP.LPT2.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19
        (BOP.LPT2.portLP.p, inStream(BOP.LPT2.portLP.h_outflow), inStream(
        BOP.LPT2.portLP.Xi_outflow), 0, 0);
      BOP.LPT2.p_ratio = BOP.LPT2.p_out/BOP.LPT2.p_in;
      if (cardinality(BOP.LPT2.partialArc) == 0) then 
        BOP.LPT2.partialArc = 1.0;
      end if;
      BOP.LPT2.h_is = Modelica.Media.Water.WaterIF97_ph.isentropicEnthalpy_Unique17
        (
        BOP.LPT2.portLP.p, 
        BOP.LPT2.state_a);
      BOP.LPT2.eta_is = BOP.LPT2.eta_wetSteam.eta;
      BOP.LPT2.h_in-BOP.LPT2.h_out = BOP.LPT2.eta_is*(BOP.LPT2.h_in-
        BOP.LPT2.h_is);
      BOP.LPT2.Q_mech = BOP.LPT2.eta_mech*BOP.LPT2.m_flow*(BOP.LPT2.h_in-
        BOP.LPT2.h_out);
      sum(BOP.LPT2.Q_units) =  -BOP.LPT2.omega*BOP.LPT2.tau;
      BOP.LPT2.Qbs = BOP.LPT2.Q_mech*BOP.LPT2.Q_fracs-BOP.LPT2.Q_units;
      if (BOP.LPT2.energyDynamics == TRANSFORM.Types.Dynamics.SteadyState) then 
        for i in (1:BOP.LPT2.nUnits) loop
          0 = BOP.LPT2.Qbs[i];
        end for;
      else
        for i in (1:BOP.LPT2.nUnits) loop
          BOP.LPT2.taus[i]*der(BOP.LPT2.Q_units[i]) = BOP.LPT2.Qbs[i];
        end for;
      end if;
      BOP.LPT2.portHP.m_flow+BOP.LPT2.portLP.m_flow = 0;
      BOP.LPT2.tau = BOP.LPT2.shaft_a.tau+BOP.LPT2.shaft_b.tau;
      BOP.LPT2.shaft_a.phi = BOP.LPT2.phi;
      BOP.LPT2.shaft_b.phi = BOP.LPT2.phi;
      der(BOP.LPT2.phi) = BOP.LPT2.omega;
      BOP.LPT2.h_in = inStream(BOP.LPT2.portHP.h_outflow);
      BOP.LPT2.m_flow = BOP.LPT2.portHP.m_flow;
      BOP.LPT2.portHP.p = BOP.LPT2.p_in;
      BOP.LPT2.portLP.p = BOP.LPT2.p_out;
      BOP.LPT2.portHP.h_outflow = inStream(BOP.LPT2.portLP.h_outflow)+
        BOP.LPT2.h_in-BOP.LPT2.h_out;
      BOP.LPT2.portHP.Xi_outflow = inStream(BOP.LPT2.portLP.Xi_outflow);
      BOP.LPT2.portHP.C_outflow = inStream(BOP.LPT2.portLP.C_outflow);
      BOP.LPT2.portLP.h_outflow = inStream(BOP.LPT2.portHP.h_outflow)+
        BOP.LPT2.h_out-BOP.LPT2.h_in;
      BOP.LPT2.portLP.Xi_outflow = inStream(BOP.LPT2.portHP.Xi_outflow);
      BOP.LPT2.portLP.C_outflow = inStream(BOP.LPT2.portHP.C_outflow);
      BOP.LPT2.x_th_in = (BOP.LPT2.h_in-BOP.LPT2.h_fsat_in)/max(BOP.LPT2.h_gsat_in
        -BOP.LPT2.h_fsat_in, 1E-06);
      BOP.LPT2.x_th_out = (BOP.LPT2.h_out-BOP.LPT2.h_fsat_out)/max(
        BOP.LPT2.h_gsat_out-BOP.LPT2.h_fsat_out, 1E-06);
      BOP.LPT2.x_abs_in = noEvent((if BOP.LPT2.p_in/BOP.LPT2.p_crit < 1.0 then 
        max(0.0, min(1.0, BOP.LPT2.x_th_in)) else 1.0));
      BOP.LPT2.x_abs_out = noEvent((if BOP.LPT2.p_out/BOP.LPT2.p_crit < 1.0
         then max(0.0, min(1.0, BOP.LPT2.x_th_out)) else 1.0));
    // end of extends 
  equation
    if (BOP.LPT2.use_Stodola) then 
      BOP.LPT2.m_flow = homotopy(BOP.LPT2.Kt*BOP.LPT2.partialArc*sqrt(
        BOP.LPT2.p_in*Modelica.Media.Water.WaterIF97_ph.density_Unique30(
        BOP.LPT2.state_a))*Modelica.Fluid.Utilities.regRoot(1-BOP.LPT2.p_ratio^2,
         0.01), BOP.LPT2.partialArc/BOP.LPT2.partialArc_nominal*BOP.LPT2.m_flow_nominal
        /BOP.LPT2.p_inlet_nominal*BOP.LPT2.p_in);
    else
      BOP.LPT2.m_flow = homotopy(BOP.LPT2.portHP.p*BOP.LPT2.partialArc*
        BOP.LPT2.m_flow_nominal/BOP.LPT2.p_inlet_nominal, BOP.LPT2.partialArc/
        BOP.LPT2.partialArc_nominal*BOP.LPT2.m_flow_nominal/BOP.LPT2.p_inlet_nominal
        *BOP.LPT2.p_in);
    end if;

  // Component BOP.moistureSeperator.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (BOP.moistureSeperator.medium.standardOrderComponents) then 
        BOP.moistureSeperator.medium.Xi = BOP.moistureSeperator.medium.X[1:0];
        BOP.moistureSeperator.medium.X = {1.0};
        for i in (1:1) loop
          assert(BOP.moistureSeperator.medium.X[i] >= -1E-05 and 
            BOP.moistureSeperator.medium.X[i] <= 1.00001, "Mass fraction X["+
                   String(i, true, 0)+"] = "+       String(BOP.moistureSeperator.medium.X
            [i], true, 0)+"of substance "+({"water"})[i]+"\nof medium "+
            "WaterIF97"+" is not in the range 0..1");
        end for;
      end if;
      assert(BOP.moistureSeperator.medium.p >= 0.0, "Pressure (= "+       String
        (BOP.moistureSeperator.medium.p, true, 0)+" Pa) of medium \""+
        "WaterIF97"+"\" is negative\n(Temperature = "+       String(
        BOP.moistureSeperator.medium.T, true, 0)+" K)");
    // end of extends 
  equation
    BOP.moistureSeperator.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    BOP.moistureSeperator.medium.phase = (if BOP.moistureSeperator.medium.h < 
      Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique25(
      BOP.moistureSeperator.medium.sat) or BOP.moistureSeperator.medium.h > 
      Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique28(
      BOP.moistureSeperator.medium.sat) or BOP.moistureSeperator.medium.p > 
      _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].
      criticalPressure then 1 else 2);
    BOP.moistureSeperator.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique20
      (BOP.moistureSeperator.medium.p, BOP.moistureSeperator.medium.h, 
      BOP.moistureSeperator.medium.phase, 0);
    BOP.moistureSeperator.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique21
      (BOP.moistureSeperator.medium.p, BOP.moistureSeperator.medium.h, 
      BOP.moistureSeperator.medium.phase, 0);
    BOP.moistureSeperator.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique23
      (BOP.moistureSeperator.medium.p);
    BOP.moistureSeperator.medium.sat.psat = BOP.moistureSeperator.medium.p;
    BOP.moistureSeperator.medium.u = BOP.moistureSeperator.medium.h-
      BOP.moistureSeperator.medium.p/BOP.moistureSeperator.medium.d;
    BOP.moistureSeperator.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    BOP.moistureSeperator.medium.h = BOP.moistureSeperator.medium.state.h;
    BOP.moistureSeperator.medium.p = BOP.moistureSeperator.medium.state.p;
    BOP.moistureSeperator.medium.T = BOP.moistureSeperator.medium.state.T;
    BOP.moistureSeperator.medium.d = BOP.moistureSeperator.medium.state.d;
    BOP.moistureSeperator.medium.phase = BOP.moistureSeperator.medium.state.phase;

  // Component BOP.moistureSeperator
  // class TRANSFORM.Fluid.Volumes.Separator
    // extends TRANSFORM.Fluid.Volumes.BaseClasses.PartialVolume
    equation
      assert( not (BOP.moistureSeperator.energyDynamics <> Modelica.Fluid.Types.Dynamics.
        SteadyState and BOP.moistureSeperator.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) or false, "If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState' or Medium not conserving mass if volume is fixed.");
      BOP.moistureSeperator.m = BOP.moistureSeperator.V*BOP.moistureSeperator.medium.d;
      BOP.moistureSeperator.U = BOP.moistureSeperator.m*BOP.moistureSeperator.medium.u;
      BOP.moistureSeperator.mXi = BOP.moistureSeperator.m*BOP.moistureSeperator.medium.Xi;
      BOP.moistureSeperator.mC = BOP.moistureSeperator.m*BOP.moistureSeperator.C;
      if (BOP.moistureSeperator.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) then 
        0 = BOP.moistureSeperator.mb;
      else
        der(BOP.moistureSeperator.m) = BOP.moistureSeperator.mb;
      end if;
      if (BOP.moistureSeperator.energyDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) then 
        0 = BOP.moistureSeperator.Ub;
      else
        der(BOP.moistureSeperator.U) = BOP.moistureSeperator.Ub;
      end if;
      if (BOP.moistureSeperator.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) then 
        zeros(0) = BOP.moistureSeperator.mXib;
      else
        der(BOP.moistureSeperator.mXi) = BOP.moistureSeperator.mXib;
      end if;
      if (BOP.moistureSeperator.traceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) then 
        zeros(0) = BOP.moistureSeperator.mCb;
      else
        der(BOP.moistureSeperator.mC_scaled) = BOP.moistureSeperator.mCb./{};
        BOP.moistureSeperator.mC = BOP.moistureSeperator.mC_scaled.*{};
      end if;
    // extends TRANSFORM.Fluid.Volumes.MixingVolume
    equation
      if ( not BOP.moistureSeperator.use_HeatPort) then 
        BOP.moistureSeperator.Q_flow_internal = 0;
      end if;
      if ( not BOP.moistureSeperator.use_TraceMassPort) then 
        BOP.moistureSeperator.mC_flow_internal = zeros(0);
      end if;
      BOP.moistureSeperator.port_a.p = fill(BOP.moistureSeperator.medium.p+
        BOP.moistureSeperator.medium.d*BOP.moistureSeperator.g_n*0.5*
        BOP.moistureSeperator.geometry.dheight, BOP.moistureSeperator.nPorts_a);
      BOP.moistureSeperator.port_b.p = fill(BOP.moistureSeperator.medium.p-
        BOP.moistureSeperator.medium.d*BOP.moistureSeperator.g_n*0.5*
        BOP.moistureSeperator.geometry.dheight, BOP.moistureSeperator.nPorts_b);
      BOP.moistureSeperator.port_a.h_outflow = fill(BOP.moistureSeperator.medium.h,
         BOP.moistureSeperator.nPorts_a);
      BOP.moistureSeperator.port_b.h_outflow = fill(BOP.moistureSeperator.medium.h,
         BOP.moistureSeperator.nPorts_b);
      BOP.moistureSeperator.port_a.Xi_outflow = fill(BOP.moistureSeperator.medium.Xi,
         BOP.moistureSeperator.nPorts_a);
      BOP.moistureSeperator.port_b.Xi_outflow = fill(BOP.moistureSeperator.medium.Xi,
         BOP.moistureSeperator.nPorts_b);
      BOP.moistureSeperator.port_a.C_outflow = fill(BOP.moistureSeperator.C, 
        BOP.moistureSeperator.nPorts_a);
      BOP.moistureSeperator.port_b.C_outflow = fill(BOP.moistureSeperator.C, 
        BOP.moistureSeperator.nPorts_b);
      for i in (1:BOP.moistureSeperator.nPorts_a) loop
        BOP.moistureSeperator.H_flows_a[i] = BOP.moistureSeperator.port_a[i].
          m_flow*actualStream(BOP.moistureSeperator.port_a[i].h_outflow);
        BOP.moistureSeperator.mXi_flows_a[i, :] = BOP.moistureSeperator.port_a[i]
          .m_flow*actualStream(BOP.moistureSeperator.port_a[i].Xi_outflow);
        BOP.moistureSeperator.mC_flows_a[i, :] = BOP.moistureSeperator.port_a[i]
          .m_flow*actualStream(BOP.moistureSeperator.port_a[i].C_outflow);
      end for;
      for i in (1:BOP.moistureSeperator.nPorts_b) loop
        BOP.moistureSeperator.H_flows_b[i] = BOP.moistureSeperator.port_b[i].
          m_flow*actualStream(BOP.moistureSeperator.port_b[i].h_outflow);
        BOP.moistureSeperator.mXi_flows_b[i, :] = BOP.moistureSeperator.port_b[i]
          .m_flow*actualStream(BOP.moistureSeperator.port_b[i].Xi_outflow);
        BOP.moistureSeperator.mC_flows_b[i, :] = BOP.moistureSeperator.port_b[i]
          .m_flow*actualStream(BOP.moistureSeperator.port_b[i].C_outflow);
      end for;
    // end of extends 
  equation
    BOP.moistureSeperator.x_abs = noEvent((if BOP.moistureSeperator.medium.p/
      BOP.moistureSeperator.p_crit < 1.0 then max(0.0, min(1.0, (
      BOP.moistureSeperator.medium.h-BOP.moistureSeperator.h_lsat)/max(
      BOP.moistureSeperator.h_vsat-BOP.moistureSeperator.h_lsat, 1E-06))) else 
      1.0));
    BOP.moistureSeperator.h_lsat = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_Unique12
      (
      Modelica.Media.Water.WaterIF97_ph.setBubbleState_Unique24(
        Modelica.Media.Water.WaterIF97_ph.setSat_p_Unique22(BOP.moistureSeperator.medium.p),
           
        1));
    BOP.moistureSeperator.h_vsat = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_Unique12
      (
      Modelica.Media.Water.WaterIF97_ph.setDewState_Unique27(
        Modelica.Media.Water.WaterIF97_ph.setSat_p_Unique22(BOP.moistureSeperator.medium.p),
           
        1));
    if (BOP.moistureSeperator.portMixed) then 
      BOP.moistureSeperator.m_flow_a_inflow = max(sum(BOP.moistureSeperator.port_a
        .m_flow), 0);
      BOP.moistureSeperator.m_flow_b_inflow = max(sum(BOP.moistureSeperator.port_b
        .m_flow), 0);
    else
      BOP.moistureSeperator.m_flow_a_inflow = sum(array(max(BOP.moistureSeperator.port_a
        [i].m_flow, 0) for i in 1:BOP.moistureSeperator.nPorts_a));
      BOP.moistureSeperator.m_flow_b_inflow = sum(array(max(BOP.moistureSeperator.port_b
        [i].m_flow, 0) for i in 1:BOP.moistureSeperator.nPorts_b));
    end if;
    BOP.moistureSeperator.m_flow_liquid =  -(1-BOP.moistureSeperator.x_abs)*(
      BOP.moistureSeperator.m_flow_a_inflow+BOP.moistureSeperator.m_flow_b_inflow)
      *BOP.moistureSeperator.eta_sep;
    BOP.moistureSeperator.port_Liquid.m_flow = BOP.moistureSeperator.m_flow_liquid;
    BOP.moistureSeperator.port_Liquid.h_outflow = noEvent((if BOP.moistureSeperator.x_abs
       > 0 then BOP.moistureSeperator.h_lsat else BOP.moistureSeperator.medium.h));
    BOP.moistureSeperator.port_Liquid.Xi_outflow = BOP.moistureSeperator.medium.Xi;
    BOP.moistureSeperator.port_Liquid.C_outflow = BOP.moistureSeperator.C;

  // Component BOP.LPT1_bypass.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (BOP.LPT1_bypass.medium.standardOrderComponents) then 
        BOP.LPT1_bypass.medium.Xi = BOP.LPT1_bypass.medium.X[1:0];
        BOP.LPT1_bypass.medium.X = {1.0};
        for i in (1:1) loop
          assert(BOP.LPT1_bypass.medium.X[i] >= -1E-05 and BOP.LPT1_bypass.medium.X
            [i] <= 1.00001, "Mass fraction X["+       String(i, true, 0)+"] = "+
                   String(BOP.LPT1_bypass.medium.X[i], true, 0)+"of substance "+
            ({"water"})[i]+"\nof medium "+"WaterIF97"+" is not in the range 0..1");
        end for;
      end if;
      assert(BOP.LPT1_bypass.medium.p >= 0.0, "Pressure (= "+       String(
        BOP.LPT1_bypass.medium.p, true, 0)+" Pa) of medium \""+"WaterIF97"+
        "\" is negative\n(Temperature = "+       String(BOP.LPT1_bypass.medium.T,
         true, 0)+" K)");
    // end of extends 
  equation
    BOP.LPT1_bypass.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    BOP.LPT1_bypass.medium.phase = (if BOP.LPT1_bypass.medium.h < 
      Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique25(
      BOP.LPT1_bypass.medium.sat) or BOP.LPT1_bypass.medium.h > Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique28
      (
      BOP.LPT1_bypass.medium.sat) or BOP.LPT1_bypass.medium.p > _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .criticalPressure then 1 else 2);
    BOP.LPT1_bypass.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique20
      (BOP.LPT1_bypass.medium.p, BOP.LPT1_bypass.medium.h, BOP.LPT1_bypass.medium.phase,
       0);
    BOP.LPT1_bypass.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique21
      (BOP.LPT1_bypass.medium.p, BOP.LPT1_bypass.medium.h, BOP.LPT1_bypass.medium.phase,
       0);
    BOP.LPT1_bypass.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique23
      (BOP.LPT1_bypass.medium.p);
    BOP.LPT1_bypass.medium.sat.psat = BOP.LPT1_bypass.medium.p;
    BOP.LPT1_bypass.medium.u = BOP.LPT1_bypass.medium.h-BOP.LPT1_bypass.medium.p
      /BOP.LPT1_bypass.medium.d;
    BOP.LPT1_bypass.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    BOP.LPT1_bypass.medium.h = BOP.LPT1_bypass.medium.state.h;
    BOP.LPT1_bypass.medium.p = BOP.LPT1_bypass.medium.state.p;
    BOP.LPT1_bypass.medium.T = BOP.LPT1_bypass.medium.state.T;
    BOP.LPT1_bypass.medium.d = BOP.LPT1_bypass.medium.state.d;
    BOP.LPT1_bypass.medium.phase = BOP.LPT1_bypass.medium.state.phase;

  // Component BOP.LPT1_bypass
  // class TRANSFORM.Fluid.FittingsAndResistances.TeeJunctionVolume
    // extends TRANSFORM.Fluid.Volumes.BaseClasses.PartialVolume
    equation
      assert( not (BOP.LPT1_bypass.energyDynamics <> Modelica.Fluid.Types.Dynamics.
        SteadyState and BOP.LPT1_bypass.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) or false, "If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState' or Medium not conserving mass if volume is fixed.");
      BOP.LPT1_bypass.m = BOP.LPT1_bypass.V*BOP.LPT1_bypass.medium.d;
      BOP.LPT1_bypass.U = BOP.LPT1_bypass.m*BOP.LPT1_bypass.medium.u;
      BOP.LPT1_bypass.mXi = BOP.LPT1_bypass.m*BOP.LPT1_bypass.medium.Xi;
      BOP.LPT1_bypass.mC = BOP.LPT1_bypass.m*BOP.LPT1_bypass.C;
      if (BOP.LPT1_bypass.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) then 
        0 = BOP.LPT1_bypass.mb;
      else
        der(BOP.LPT1_bypass.m) = BOP.LPT1_bypass.mb;
      end if;
      if (BOP.LPT1_bypass.energyDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) then 
        0 = BOP.LPT1_bypass.Ub;
      else
        der(BOP.LPT1_bypass.U) = BOP.LPT1_bypass.Ub;
      end if;
      if (BOP.LPT1_bypass.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) then 
        zeros(0) = BOP.LPT1_bypass.mXib;
      else
        der(BOP.LPT1_bypass.mXi) = BOP.LPT1_bypass.mXib;
      end if;
      if (BOP.LPT1_bypass.traceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) then 
        zeros(0) = BOP.LPT1_bypass.mCb;
      else
        der(BOP.LPT1_bypass.mC_scaled) = BOP.LPT1_bypass.mCb./{};
        BOP.LPT1_bypass.mC = BOP.LPT1_bypass.mC_scaled.*{};
      end if;
    // end of extends 
  equation
    assert(cardinality(BOP.LPT1_bypass.port_1) <= 1, "
port_1 of volume can at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections which is usually not the intention
of the modeller.
");
    assert(cardinality(BOP.LPT1_bypass.port_2) <= 1, "
port_2 of volume can at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections which is usually not the intention
of the modeller.
");
    assert(cardinality(BOP.LPT1_bypass.port_3) <= 1, "
port_3 of volume can at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections which is usually not the intention
of the modeller.
");
    BOP.LPT1_bypass.port_1.h_outflow = BOP.LPT1_bypass.medium.h;
    BOP.LPT1_bypass.port_2.h_outflow = BOP.LPT1_bypass.medium.h;
    BOP.LPT1_bypass.port_3.h_outflow = BOP.LPT1_bypass.medium.h;
    BOP.LPT1_bypass.port_1.Xi_outflow = BOP.LPT1_bypass.medium.Xi;
    BOP.LPT1_bypass.port_2.Xi_outflow = BOP.LPT1_bypass.medium.Xi;
    BOP.LPT1_bypass.port_3.Xi_outflow = BOP.LPT1_bypass.medium.Xi;
    BOP.LPT1_bypass.port_1.C_outflow = BOP.LPT1_bypass.C;
    BOP.LPT1_bypass.port_2.C_outflow = BOP.LPT1_bypass.C;
    BOP.LPT1_bypass.port_3.C_outflow = BOP.LPT1_bypass.C;
    BOP.LPT1_bypass.port_1.p = BOP.LPT1_bypass.medium.p;
    BOP.LPT1_bypass.port_2.p = BOP.LPT1_bypass.medium.p;
    BOP.LPT1_bypass.port_3.p = BOP.LPT1_bypass.medium.p;

  // Component BOP.LPT1_bypass_valve
  // class TRANSFORM.Fluid.Valves.ValveLinear
    // extends TRANSFORM.Fluid.Valves.BaseClasses.PartialTwoPortTransport
    equation
      BOP.LPT1_bypass_valve.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19
        (BOP.LPT1_bypass_valve.port_a.p, inStream(BOP.LPT1_bypass_valve.port_a.h_outflow),
         inStream(BOP.LPT1_bypass_valve.port_a.Xi_outflow), 0, 0);
      BOP.LPT1_bypass_valve.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19
        (BOP.LPT1_bypass_valve.port_b.p, inStream(BOP.LPT1_bypass_valve.port_b.h_outflow),
         inStream(BOP.LPT1_bypass_valve.port_b.Xi_outflow), 0, 0);
      BOP.LPT1_bypass_valve.dp = BOP.LPT1_bypass_valve.port_a.p-BOP.LPT1_bypass_valve.port_b.p;
      BOP.LPT1_bypass_valve.m_flow = BOP.LPT1_bypass_valve.port_a.m_flow;
      assert(BOP.LPT1_bypass_valve.m_flow >  -BOP.LPT1_bypass_valve.m_flow_small
         or BOP.LPT1_bypass_valve.allowFlowReversal, "Reverting flow occurs even though allowFlowReversal is false");
      BOP.LPT1_bypass_valve.port_a.m_flow+BOP.LPT1_bypass_valve.port_b.m_flow = 0;
      BOP.LPT1_bypass_valve.port_a.Xi_outflow = inStream(BOP.LPT1_bypass_valve.port_b.Xi_outflow);
      BOP.LPT1_bypass_valve.port_b.Xi_outflow = inStream(BOP.LPT1_bypass_valve.port_a.Xi_outflow);
      BOP.LPT1_bypass_valve.port_a.C_outflow = inStream(BOP.LPT1_bypass_valve.port_b.C_outflow);
      BOP.LPT1_bypass_valve.port_b.C_outflow = inStream(BOP.LPT1_bypass_valve.port_a.C_outflow);
    // end of extends 
  equation
    BOP.LPT1_bypass_valve.m_flow = BOP.LPT1_bypass_valve.opening*
      BOP.LPT1_bypass_valve.k*BOP.LPT1_bypass_valve.dp;
    BOP.LPT1_bypass_valve.port_a.h_outflow = inStream(BOP.LPT1_bypass_valve.port_b.h_outflow);
    BOP.LPT1_bypass_valve.port_b.h_outflow = inStream(BOP.LPT1_bypass_valve.port_a.h_outflow);

  // Component BOP.TBV
  // class TRANSFORM.Fluid.Valves.ValveLinear
    // extends TRANSFORM.Fluid.Valves.BaseClasses.PartialTwoPortTransport
    equation
      BOP.TBV.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(
        BOP.TBV.port_a.p, inStream(BOP.TBV.port_a.h_outflow), inStream(
        BOP.TBV.port_a.Xi_outflow), 0, 0);
      BOP.TBV.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(
        BOP.TBV.port_b.p, inStream(BOP.TBV.port_b.h_outflow), inStream(
        BOP.TBV.port_b.Xi_outflow), 0, 0);
      BOP.TBV.dp = BOP.TBV.port_a.p-BOP.TBV.port_b.p;
      BOP.TBV.m_flow = BOP.TBV.port_a.m_flow;
      assert(BOP.TBV.m_flow >  -BOP.TBV.m_flow_small or BOP.TBV.allowFlowReversal,
         "Reverting flow occurs even though allowFlowReversal is false");
      BOP.TBV.port_a.m_flow+BOP.TBV.port_b.m_flow = 0;
      BOP.TBV.port_a.Xi_outflow = inStream(BOP.TBV.port_b.Xi_outflow);
      BOP.TBV.port_b.Xi_outflow = inStream(BOP.TBV.port_a.Xi_outflow);
      BOP.TBV.port_a.C_outflow = inStream(BOP.TBV.port_b.C_outflow);
      BOP.TBV.port_b.C_outflow = inStream(BOP.TBV.port_a.C_outflow);
    // end of extends 
  equation
    BOP.TBV.m_flow = BOP.TBV.opening*BOP.TBV.k*BOP.TBV.dp;
    BOP.TBV.port_a.h_outflow = inStream(BOP.TBV.port_b.h_outflow);
    BOP.TBV.port_b.h_outflow = inStream(BOP.TBV.port_a.h_outflow);

  // Component BOP.condenser
  // class TRANSFORM.Fluid.Volumes.IdealCondenser
  equation
    assert(BOP.condenser.V_liquid < BOP.condenser.V_total, "Liquid volume has exceed the total condenser volume.");
    BOP.condenser.sat.psat = BOP.condenser.p;
    BOP.condenser.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique23
      (BOP.condenser.p);
    BOP.condenser.m_liquid = BOP.condenser.V_liquid*BOP.condenser.rho_fsat;
    BOP.condenser.m_vapor = BOP.condenser.V_vapor*BOP.condenser.rho_gsat;
    BOP.condenser.V_total = BOP.condenser.V_vapor+BOP.condenser.V_liquid;
    BOP.condenser.m_total = BOP.condenser.m_liquid+BOP.condenser.m_vapor;
    BOP.condenser.E = BOP.condenser.m_liquid*BOP.condenser.h_fsat+
      BOP.condenser.m_vapor*inStream(BOP.condenser.port_a.h_outflow)-
      BOP.condenser.p*BOP.condenser.V_total;
    der(BOP.condenser.m_total) = BOP.condenser.port_a.m_flow+BOP.condenser.port_b.m_flow;
    der(BOP.condenser.E) = BOP.condenser.port_a.m_flow*actualStream(
      BOP.condenser.port_a.h_outflow)+BOP.condenser.port_b.m_flow*actualStream(
      BOP.condenser.port_b.h_outflow)+BOP.condenser.Q_total;
    BOP.condenser.port_a.p = BOP.condenser.p;
    if (BOP.condenser.set_m_flow) then 
      BOP.condenser.port_b.m_flow =  -BOP.condenser.port_a.m_flow;
    else
      BOP.condenser.port_b.p = BOP.condenser.p;
    end if;
    BOP.condenser.port_a.h_outflow = BOP.condenser.h_gsat;
    BOP.condenser.port_b.h_outflow = BOP.condenser.h_fsat;

  // Component BOP.generator
  // class TRANSFORM.Electrical.PowerConverters.Generator
  equation
    BOP.generator.omega_m = der(BOP.generator.shaft.phi);
    BOP.generator.omega_e = BOP.generator.omega_m*BOP.generator.nPoles;
    BOP.generator.f = BOP.generator.omega_e/6.283185307179586;
    BOP.generator.Q_mech = BOP.generator.omega_m*BOP.generator.tau;
    if (BOP.generator.J > 0) then 
      BOP.generator.Q_loss = BOP.generator.J*der(BOP.generator.omega_m)*
        BOP.generator.omega_m;
    else
      BOP.generator.Q_loss = 0;
    end if;
    BOP.generator.Q_mech = BOP.generator.Q_elec/BOP.generator.eta+
      BOP.generator.Q_loss;
    BOP.generator.f = BOP.generator.port.f;
    BOP.generator.Q_elec =  -BOP.generator.port.W;
    BOP.generator.tau = BOP.generator.shaft.tau;

  // Component BOP.pump
  // class NHES.Fluid.Machines.Pump_Pressure
    // extends TRANSFORM.Fluid.Machines.BaseClasses.PartialPump_Simple
    equation
      BOP.pump.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19
        (BOP.pump.port_a.p, inStream(BOP.pump.port_a.h_outflow), inStream(
        BOP.pump.port_a.Xi_outflow), 0, 0);
      BOP.pump.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19
        (BOP.pump.port_b.p, inStream(BOP.pump.port_b.h_outflow), inStream(
        BOP.pump.port_b.Xi_outflow), 0, 0);
      BOP.pump.dp = BOP.pump.port_b.p-BOP.pump.port_a.p;
      BOP.pump.port_a.m_flow+BOP.pump.port_b.m_flow = 0;
      BOP.pump.dh_ideal = BOP.pump.dp/Modelica.Media.Water.WaterIF97_ph.density_Unique30
        (
        BOP.pump.state_a);
      BOP.pump.dh*BOP.pump.eta_is = BOP.pump.dh_ideal;
      BOP.pump.Ub = BOP.pump.port_a.m_flow*actualStream(BOP.pump.port_a.h_outflow)
        +BOP.pump.port_b.m_flow*actualStream(BOP.pump.port_b.h_outflow)+
        BOP.pump.W*BOP.pump.nParallel;
      0 = BOP.pump.Ub;
      BOP.pump.m_flow = BOP.pump.port_a.m_flow/BOP.pump.nParallel;
      BOP.pump.port_a.h_outflow = inStream(BOP.pump.port_b.h_outflow)+
        BOP.pump.dh;
      BOP.pump.port_a.Xi_outflow = inStream(BOP.pump.port_b.Xi_outflow);
      BOP.pump.port_a.C_outflow = inStream(BOP.pump.port_b.C_outflow);
      BOP.pump.port_b.h_outflow = inStream(BOP.pump.port_a.h_outflow)+
        BOP.pump.dh;
      BOP.pump.port_b.Xi_outflow = inStream(BOP.pump.port_a.Xi_outflow);
      BOP.pump.port_b.C_outflow = inStream(BOP.pump.port_a.C_outflow);
    // end of extends 
  equation
    BOP.pump.eta_is = BOP.pump.eta;
    if ( not BOP.pump.use_input) then 
      BOP.pump.p_internal = BOP.pump.p_nominal;
    end if;
    BOP.pump.p = BOP.pump.p_internal;
    BOP.pump.port_b.p = BOP.pump.p;
    BOP.pump.port_a.Xi_outflow = inStream(BOP.pump.port_b.Xi_outflow);
    BOP.pump.port_b.Xi_outflow = inStream(BOP.pump.port_a.Xi_outflow);
    BOP.pump.port_a.C_outflow = inStream(BOP.pump.port_b.C_outflow);
    BOP.pump.port_b.C_outflow = inStream(BOP.pump.port_a.C_outflow);

  // Component BOP.pump1
  // class NHES.Fluid.Machines.Pump_Pressure
    // extends TRANSFORM.Fluid.Machines.BaseClasses.PartialPump_Simple
    equation
      BOP.pump1.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19
        (BOP.pump1.port_a.p, inStream(BOP.pump1.port_a.h_outflow), inStream(
        BOP.pump1.port_a.Xi_outflow), 0, 0);
      BOP.pump1.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19
        (BOP.pump1.port_b.p, inStream(BOP.pump1.port_b.h_outflow), inStream(
        BOP.pump1.port_b.Xi_outflow), 0, 0);
      BOP.pump1.dp = BOP.pump1.port_b.p-BOP.pump1.port_a.p;
      BOP.pump1.port_a.m_flow+BOP.pump1.port_b.m_flow = 0;
      BOP.pump1.dh_ideal = BOP.pump1.dp/Modelica.Media.Water.WaterIF97_ph.density_Unique30
        (
        BOP.pump1.state_a);
      BOP.pump1.dh*BOP.pump1.eta_is = BOP.pump1.dh_ideal;
      BOP.pump1.Ub = BOP.pump1.port_a.m_flow*actualStream(BOP.pump1.port_a.h_outflow)
        +BOP.pump1.port_b.m_flow*actualStream(BOP.pump1.port_b.h_outflow)+
        BOP.pump1.W*BOP.pump1.nParallel;
      0 = BOP.pump1.Ub;
      BOP.pump1.m_flow = BOP.pump1.port_a.m_flow/BOP.pump1.nParallel;
      BOP.pump1.port_a.h_outflow = inStream(BOP.pump1.port_b.h_outflow)+
        BOP.pump1.dh;
      BOP.pump1.port_a.Xi_outflow = inStream(BOP.pump1.port_b.Xi_outflow);
      BOP.pump1.port_a.C_outflow = inStream(BOP.pump1.port_b.C_outflow);
      BOP.pump1.port_b.h_outflow = inStream(BOP.pump1.port_a.h_outflow)+
        BOP.pump1.dh;
      BOP.pump1.port_b.Xi_outflow = inStream(BOP.pump1.port_a.Xi_outflow);
      BOP.pump1.port_b.C_outflow = inStream(BOP.pump1.port_a.C_outflow);
    // end of extends 
  equation
    BOP.pump1.eta_is = BOP.pump1.eta;
    if ( not BOP.pump1.use_input) then 
      BOP.pump1.p_internal = BOP.pump1.p_nominal;
    end if;
    BOP.pump1.p = BOP.pump1.p_internal;
    BOP.pump1.port_b.p = BOP.pump1.p;
    BOP.pump1.port_a.Xi_outflow = inStream(BOP.pump1.port_b.Xi_outflow);
    BOP.pump1.port_b.Xi_outflow = inStream(BOP.pump1.port_a.Xi_outflow);
    BOP.pump1.port_a.C_outflow = inStream(BOP.pump1.port_b.C_outflow);
    BOP.pump1.port_b.C_outflow = inStream(BOP.pump1.port_a.C_outflow);

  // Component BOP.OFWH_1.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (BOP.OFWH_1.medium.standardOrderComponents) then 
        BOP.OFWH_1.medium.Xi = BOP.OFWH_1.medium.X[1:0];
        BOP.OFWH_1.medium.X = {1.0};
        for i in (1:1) loop
          assert(BOP.OFWH_1.medium.X[i] >= -1E-05 and BOP.OFWH_1.medium.X[i] <= 
            1.00001, "Mass fraction X["+       String(i, true, 0)+"] = "+
                   String(BOP.OFWH_1.medium.X[i], true, 0)+"of substance "+({
            "water"})[i]+"\nof medium "+"WaterIF97"+" is not in the range 0..1");
        end for;
      end if;
      assert(BOP.OFWH_1.medium.p >= 0.0, "Pressure (= "+       String(
        BOP.OFWH_1.medium.p, true, 0)+" Pa) of medium \""+"WaterIF97"+
        "\" is negative\n(Temperature = "+       String(BOP.OFWH_1.medium.T, 
        true, 0)+" K)");
    // end of extends 
  equation
    BOP.OFWH_1.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    BOP.OFWH_1.medium.phase = (if BOP.OFWH_1.medium.h < Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique25
      (
      BOP.OFWH_1.medium.sat) or BOP.OFWH_1.medium.h > Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique28
      (
      BOP.OFWH_1.medium.sat) or BOP.OFWH_1.medium.p > _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .criticalPressure then 1 else 2);
    BOP.OFWH_1.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique20(
      BOP.OFWH_1.medium.p, BOP.OFWH_1.medium.h, BOP.OFWH_1.medium.phase, 0);
    BOP.OFWH_1.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique21
      (BOP.OFWH_1.medium.p, BOP.OFWH_1.medium.h, BOP.OFWH_1.medium.phase, 0);
    BOP.OFWH_1.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique23
      (BOP.OFWH_1.medium.p);
    BOP.OFWH_1.medium.sat.psat = BOP.OFWH_1.medium.p;
    BOP.OFWH_1.medium.u = BOP.OFWH_1.medium.h-BOP.OFWH_1.medium.p/
      BOP.OFWH_1.medium.d;
    BOP.OFWH_1.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    BOP.OFWH_1.medium.h = BOP.OFWH_1.medium.state.h;
    BOP.OFWH_1.medium.p = BOP.OFWH_1.medium.state.p;
    BOP.OFWH_1.medium.T = BOP.OFWH_1.medium.state.T;
    BOP.OFWH_1.medium.d = BOP.OFWH_1.medium.state.d;
    BOP.OFWH_1.medium.phase = BOP.OFWH_1.medium.state.phase;

  // Component BOP.OFWH_1
  // class TRANSFORM.Fluid.Volumes.SimpleVolume
    // extends TRANSFORM.Fluid.Volumes.BaseClasses.PartialVolume
    equation
      assert( not (BOP.OFWH_1.energyDynamics <> Modelica.Fluid.Types.Dynamics.
        SteadyState and BOP.OFWH_1.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) or false, "If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState' or Medium not conserving mass if volume is fixed.");
      BOP.OFWH_1.m = BOP.OFWH_1.V*BOP.OFWH_1.medium.d;
      BOP.OFWH_1.U = BOP.OFWH_1.m*BOP.OFWH_1.medium.u;
      BOP.OFWH_1.mXi = BOP.OFWH_1.m*BOP.OFWH_1.medium.Xi;
      BOP.OFWH_1.mC = BOP.OFWH_1.m*BOP.OFWH_1.C;
      if (BOP.OFWH_1.massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        0 = BOP.OFWH_1.mb;
      else
        der(BOP.OFWH_1.m) = BOP.OFWH_1.mb;
      end if;
      if (BOP.OFWH_1.energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        0 = BOP.OFWH_1.Ub;
      else
        der(BOP.OFWH_1.U) = BOP.OFWH_1.Ub;
      end if;
      if (BOP.OFWH_1.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) then 
        zeros(0) = BOP.OFWH_1.mXib;
      else
        der(BOP.OFWH_1.mXi) = BOP.OFWH_1.mXib;
      end if;
      if (BOP.OFWH_1.traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        zeros(0) = BOP.OFWH_1.mCb;
      else
        der(BOP.OFWH_1.mC_scaled) = BOP.OFWH_1.mCb./{};
        BOP.OFWH_1.mC = BOP.OFWH_1.mC_scaled.*{};
      end if;
    // end of extends 
  equation
    if ( not BOP.OFWH_1.use_HeatPort) then 
      BOP.OFWH_1.Q_flow_internal = 0;
    end if;
    if ( not BOP.OFWH_1.use_TraceMassPort) then 
      BOP.OFWH_1.mC_flow_internal = zeros(0);
    end if;
    BOP.OFWH_1.port_a.p = BOP.OFWH_1.medium.p+BOP.OFWH_1.medium.d*BOP.OFWH_1.g_n
      *0.5*BOP.OFWH_1.geometry.dheight;
    BOP.OFWH_1.port_b.p = BOP.OFWH_1.medium.p-BOP.OFWH_1.medium.d*BOP.OFWH_1.g_n
      *0.5*BOP.OFWH_1.geometry.dheight;
    BOP.OFWH_1.port_a.h_outflow = BOP.OFWH_1.medium.h;
    BOP.OFWH_1.port_b.h_outflow = BOP.OFWH_1.medium.h;
    BOP.OFWH_1.port_a.Xi_outflow = BOP.OFWH_1.medium.Xi;
    BOP.OFWH_1.port_b.Xi_outflow = BOP.OFWH_1.medium.Xi;
    BOP.OFWH_1.port_a.C_outflow = BOP.OFWH_1.C;
    BOP.OFWH_1.port_b.C_outflow = BOP.OFWH_1.C;

  // Component BOP.HPT_bypass_valve
  // class TRANSFORM.Fluid.Valves.ValveLinear
    // extends TRANSFORM.Fluid.Valves.BaseClasses.PartialTwoPortTransport
    equation
      BOP.HPT_bypass_valve.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19
        (BOP.HPT_bypass_valve.port_a.p, inStream(BOP.HPT_bypass_valve.port_a.h_outflow),
         inStream(BOP.HPT_bypass_valve.port_a.Xi_outflow), 0, 0);
      BOP.HPT_bypass_valve.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19
        (BOP.HPT_bypass_valve.port_b.p, inStream(BOP.HPT_bypass_valve.port_b.h_outflow),
         inStream(BOP.HPT_bypass_valve.port_b.Xi_outflow), 0, 0);
      BOP.HPT_bypass_valve.dp = BOP.HPT_bypass_valve.port_a.p-BOP.HPT_bypass_valve.port_b.p;
      BOP.HPT_bypass_valve.m_flow = BOP.HPT_bypass_valve.port_a.m_flow;
      assert(BOP.HPT_bypass_valve.m_flow >  -BOP.HPT_bypass_valve.m_flow_small
         or BOP.HPT_bypass_valve.allowFlowReversal, "Reverting flow occurs even though allowFlowReversal is false");
      BOP.HPT_bypass_valve.port_a.m_flow+BOP.HPT_bypass_valve.port_b.m_flow = 0;
      BOP.HPT_bypass_valve.port_a.Xi_outflow = inStream(BOP.HPT_bypass_valve.port_b.Xi_outflow);
      BOP.HPT_bypass_valve.port_b.Xi_outflow = inStream(BOP.HPT_bypass_valve.port_a.Xi_outflow);
      BOP.HPT_bypass_valve.port_a.C_outflow = inStream(BOP.HPT_bypass_valve.port_b.C_outflow);
      BOP.HPT_bypass_valve.port_b.C_outflow = inStream(BOP.HPT_bypass_valve.port_a.C_outflow);
    // end of extends 
  equation
    BOP.HPT_bypass_valve.m_flow = BOP.HPT_bypass_valve.opening*BOP.HPT_bypass_valve.k
      *BOP.HPT_bypass_valve.dp;
    BOP.HPT_bypass_valve.port_a.h_outflow = inStream(BOP.HPT_bypass_valve.port_b.h_outflow);
    BOP.HPT_bypass_valve.port_b.h_outflow = inStream(BOP.HPT_bypass_valve.port_a.h_outflow);

  // Component BOP.OFWH_2.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (BOP.OFWH_2.medium.standardOrderComponents) then 
        BOP.OFWH_2.medium.Xi = BOP.OFWH_2.medium.X[1:0];
        BOP.OFWH_2.medium.X = {1.0};
        for i in (1:1) loop
          assert(BOP.OFWH_2.medium.X[i] >= -1E-05 and BOP.OFWH_2.medium.X[i] <= 
            1.00001, "Mass fraction X["+       String(i, true, 0)+"] = "+
                   String(BOP.OFWH_2.medium.X[i], true, 0)+"of substance "+({
            "water"})[i]+"\nof medium "+"WaterIF97"+" is not in the range 0..1");
        end for;
      end if;
      assert(BOP.OFWH_2.medium.p >= 0.0, "Pressure (= "+       String(
        BOP.OFWH_2.medium.p, true, 0)+" Pa) of medium \""+"WaterIF97"+
        "\" is negative\n(Temperature = "+       String(BOP.OFWH_2.medium.T, 
        true, 0)+" K)");
    // end of extends 
  equation
    BOP.OFWH_2.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    BOP.OFWH_2.medium.phase = (if BOP.OFWH_2.medium.h < Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique25
      (
      BOP.OFWH_2.medium.sat) or BOP.OFWH_2.medium.h > Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique28
      (
      BOP.OFWH_2.medium.sat) or BOP.OFWH_2.medium.p > _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .criticalPressure then 1 else 2);
    BOP.OFWH_2.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique20(
      BOP.OFWH_2.medium.p, BOP.OFWH_2.medium.h, BOP.OFWH_2.medium.phase, 0);
    BOP.OFWH_2.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique21
      (BOP.OFWH_2.medium.p, BOP.OFWH_2.medium.h, BOP.OFWH_2.medium.phase, 0);
    BOP.OFWH_2.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique23
      (BOP.OFWH_2.medium.p);
    BOP.OFWH_2.medium.sat.psat = BOP.OFWH_2.medium.p;
    BOP.OFWH_2.medium.u = BOP.OFWH_2.medium.h-BOP.OFWH_2.medium.p/
      BOP.OFWH_2.medium.d;
    BOP.OFWH_2.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    BOP.OFWH_2.medium.h = BOP.OFWH_2.medium.state.h;
    BOP.OFWH_2.medium.p = BOP.OFWH_2.medium.state.p;
    BOP.OFWH_2.medium.T = BOP.OFWH_2.medium.state.T;
    BOP.OFWH_2.medium.d = BOP.OFWH_2.medium.state.d;
    BOP.OFWH_2.medium.phase = BOP.OFWH_2.medium.state.phase;

  // Component BOP.OFWH_2
  // class TRANSFORM.Fluid.Volumes.SimpleVolume
    // extends TRANSFORM.Fluid.Volumes.BaseClasses.PartialVolume
    equation
      assert( not (BOP.OFWH_2.energyDynamics <> Modelica.Fluid.Types.Dynamics.
        SteadyState and BOP.OFWH_2.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) or false, "If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState' or Medium not conserving mass if volume is fixed.");
      BOP.OFWH_2.m = BOP.OFWH_2.V*BOP.OFWH_2.medium.d;
      BOP.OFWH_2.U = BOP.OFWH_2.m*BOP.OFWH_2.medium.u;
      BOP.OFWH_2.mXi = BOP.OFWH_2.m*BOP.OFWH_2.medium.Xi;
      BOP.OFWH_2.mC = BOP.OFWH_2.m*BOP.OFWH_2.C;
      if (BOP.OFWH_2.massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        0 = BOP.OFWH_2.mb;
      else
        der(BOP.OFWH_2.m) = BOP.OFWH_2.mb;
      end if;
      if (BOP.OFWH_2.energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        0 = BOP.OFWH_2.Ub;
      else
        der(BOP.OFWH_2.U) = BOP.OFWH_2.Ub;
      end if;
      if (BOP.OFWH_2.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) then 
        zeros(0) = BOP.OFWH_2.mXib;
      else
        der(BOP.OFWH_2.mXi) = BOP.OFWH_2.mXib;
      end if;
      if (BOP.OFWH_2.traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        zeros(0) = BOP.OFWH_2.mCb;
      else
        der(BOP.OFWH_2.mC_scaled) = BOP.OFWH_2.mCb./{};
        BOP.OFWH_2.mC = BOP.OFWH_2.mC_scaled.*{};
      end if;
    // end of extends 
  equation
    if ( not BOP.OFWH_2.use_HeatPort) then 
      BOP.OFWH_2.Q_flow_internal = 0;
    end if;
    if ( not BOP.OFWH_2.use_TraceMassPort) then 
      BOP.OFWH_2.mC_flow_internal = zeros(0);
    end if;
    BOP.OFWH_2.port_a.p = BOP.OFWH_2.medium.p+BOP.OFWH_2.medium.d*BOP.OFWH_2.g_n
      *0.5*BOP.OFWH_2.geometry.dheight;
    BOP.OFWH_2.port_b.p = BOP.OFWH_2.medium.p-BOP.OFWH_2.medium.d*BOP.OFWH_2.g_n
      *0.5*BOP.OFWH_2.geometry.dheight;
    BOP.OFWH_2.port_a.h_outflow = BOP.OFWH_2.medium.h;
    BOP.OFWH_2.port_b.h_outflow = BOP.OFWH_2.medium.h;
    BOP.OFWH_2.port_a.Xi_outflow = BOP.OFWH_2.medium.Xi;
    BOP.OFWH_2.port_b.Xi_outflow = BOP.OFWH_2.medium.Xi;
    BOP.OFWH_2.port_a.C_outflow = BOP.OFWH_2.C;
    BOP.OFWH_2.port_b.C_outflow = BOP.OFWH_2.C;

  // Component BOP.FWCP
  // class NHES.Fluid.Machines.Pump_MassFlow
    // extends TRANSFORM.Fluid.Machines.BaseClasses.PartialPump_Simple
    equation
      BOP.FWCP.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19
        (BOP.FWCP.port_a.p, inStream(BOP.FWCP.port_a.h_outflow), inStream(
        BOP.FWCP.port_a.Xi_outflow), 0, 0);
      BOP.FWCP.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19
        (BOP.FWCP.port_b.p, inStream(BOP.FWCP.port_b.h_outflow), inStream(
        BOP.FWCP.port_b.Xi_outflow), 0, 0);
      BOP.FWCP.dp = BOP.FWCP.port_b.p-BOP.FWCP.port_a.p;
      BOP.FWCP.port_a.m_flow+BOP.FWCP.port_b.m_flow = 0;
      BOP.FWCP.dh_ideal = BOP.FWCP.dp/Modelica.Media.Water.WaterIF97_ph.density_Unique30
        (
        BOP.FWCP.state_a);
      BOP.FWCP.dh*BOP.FWCP.eta_is = BOP.FWCP.dh_ideal;
      BOP.FWCP.Ub = BOP.FWCP.port_a.m_flow*actualStream(BOP.FWCP.port_a.h_outflow)
        +BOP.FWCP.port_b.m_flow*actualStream(BOP.FWCP.port_b.h_outflow)+
        BOP.FWCP.W*BOP.FWCP.nParallel;
      0 = BOP.FWCP.Ub;
      BOP.FWCP.m_flow = BOP.FWCP.port_a.m_flow/BOP.FWCP.nParallel;
      BOP.FWCP.port_a.h_outflow = inStream(BOP.FWCP.port_b.h_outflow)+
        BOP.FWCP.dh;
      BOP.FWCP.port_a.Xi_outflow = inStream(BOP.FWCP.port_b.Xi_outflow);
      BOP.FWCP.port_a.C_outflow = inStream(BOP.FWCP.port_b.C_outflow);
      BOP.FWCP.port_b.h_outflow = inStream(BOP.FWCP.port_a.h_outflow)+
        BOP.FWCP.dh;
      BOP.FWCP.port_b.Xi_outflow = inStream(BOP.FWCP.port_a.Xi_outflow);
      BOP.FWCP.port_b.C_outflow = inStream(BOP.FWCP.port_a.C_outflow);
    // end of extends 
  equation
    BOP.FWCP.eta_is = BOP.FWCP.eta;
    if ( not BOP.FWCP.use_input) then 
      BOP.FWCP.m_flow_internal = BOP.FWCP.m_flow_nominal;
    end if;
    BOP.FWCP.m_flow = BOP.FWCP.m_flow_internal;
    BOP.FWCP.port_a.Xi_outflow = inStream(BOP.FWCP.port_b.Xi_outflow);
    BOP.FWCP.port_b.Xi_outflow = inStream(BOP.FWCP.port_a.Xi_outflow);
    BOP.FWCP.port_a.C_outflow = inStream(BOP.FWCP.port_b.C_outflow);
    BOP.FWCP.port_b.C_outflow = inStream(BOP.FWCP.port_a.C_outflow);

  // Component BOP.TCV
  // class TRANSFORM.Fluid.Valves.ValveLinear
    // extends TRANSFORM.Fluid.Valves.BaseClasses.PartialTwoPortTransport
    equation
      BOP.TCV.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(
        BOP.TCV.port_a.p, inStream(BOP.TCV.port_a.h_outflow), inStream(
        BOP.TCV.port_a.Xi_outflow), 0, 0);
      BOP.TCV.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19(
        BOP.TCV.port_b.p, inStream(BOP.TCV.port_b.h_outflow), inStream(
        BOP.TCV.port_b.Xi_outflow), 0, 0);
      BOP.TCV.dp = BOP.TCV.port_a.p-BOP.TCV.port_b.p;
      BOP.TCV.m_flow = BOP.TCV.port_a.m_flow;
      assert(BOP.TCV.m_flow >  -BOP.TCV.m_flow_small or BOP.TCV.allowFlowReversal,
         "Reverting flow occurs even though allowFlowReversal is false");
      BOP.TCV.port_a.m_flow+BOP.TCV.port_b.m_flow = 0;
      BOP.TCV.port_a.Xi_outflow = inStream(BOP.TCV.port_b.Xi_outflow);
      BOP.TCV.port_b.Xi_outflow = inStream(BOP.TCV.port_a.Xi_outflow);
      BOP.TCV.port_a.C_outflow = inStream(BOP.TCV.port_b.C_outflow);
      BOP.TCV.port_b.C_outflow = inStream(BOP.TCV.port_a.C_outflow);
    // end of extends 
  equation
    BOP.TCV.m_flow = BOP.TCV.opening*BOP.TCV.k*BOP.TCV.dp;
    BOP.TCV.port_a.h_outflow = inStream(BOP.TCV.port_b.h_outflow);
    BOP.TCV.port_b.h_outflow = inStream(BOP.TCV.port_a.h_outflow);

  // Component BOP.Feed_T
  // class TRANSFORM.Fluid.Sensors.Temperature
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      BOP.Feed_T.port.m_flow = 0;
      BOP.Feed_T.port.h_outflow = 84013.0581525969;
      BOP.Feed_T.port.Xi_outflow = {};
      BOP.Feed_T.port.C_outflow = zeros(0);
    // end of extends 
  equation
    BOP.Feed_T.T = Modelica.Media.Water.WaterIF97_ph.temperature_Unique7(
      Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique8(BOP.Feed_T.port.p, 
        inStream(BOP.Feed_T.port.h_outflow), inStream(BOP.Feed_T.port.Xi_outflow),
         0, 0));

  // Component BOP.Steam_T
  // class TRANSFORM.Fluid.Sensors.Temperature
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      BOP.Steam_T.port.m_flow = 0;
      BOP.Steam_T.port.h_outflow = 84013.0581525969;
      BOP.Steam_T.port.Xi_outflow = {};
      BOP.Steam_T.port.C_outflow = zeros(0);
    // end of extends 
  equation
    BOP.Steam_T.T = Modelica.Media.Water.WaterIF97_ph.temperature_Unique7(
      Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique8(BOP.Steam_T.port.p,
         inStream(BOP.Steam_T.port.h_outflow), inStream(BOP.Steam_T.port.Xi_outflow),
         0, 0));

  // Component BOP.sensor_p
  // class TRANSFORM.Fluid.Sensors.Pressure
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      BOP.sensor_p.port.m_flow = 0;
      BOP.sensor_p.port.h_outflow = 84013.0581525969;
      BOP.sensor_p.port.Xi_outflow = {};
      BOP.sensor_p.port.C_outflow = zeros(0);
    // end of extends 
  equation
    BOP.sensor_p.p = BOP.sensor_p.port.p;

  // Component BOP.sensorW
  // class TRANSFORM.Electrical.Sensors.PowerSensor
  equation
    BOP.sensorW.port_a.W+BOP.sensorW.port_b.W = 0;
    BOP.sensorW.port_a.f = BOP.sensorW.port_b.f;
    BOP.sensorW.W = BOP.sensorW.port_a.W;

  // Component BOP.delay2.sensor_p
  // class TRANSFORM.Fluid.Sensors.Pressure
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      BOP.delay2.sensor_p.port.m_flow = 0;
      BOP.delay2.sensor_p.port.h_outflow = 84013.0581525969;
      BOP.delay2.sensor_p.port.Xi_outflow = {};
      BOP.delay2.sensor_p.port.C_outflow = zeros(0);
    // end of extends 
  equation
    BOP.delay2.sensor_p.p = BOP.delay2.sensor_p.port.p;

  // Component BOP.delay2.sensor_m_flow
  // class TRANSFORM.Fluid.Sensors.MassFlowRate
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialTwoPortSensor
    equation
      0 = BOP.delay2.sensor_m_flow.port_a.m_flow+BOP.delay2.sensor_m_flow.port_b.m_flow;
      BOP.delay2.sensor_m_flow.port_a.p = BOP.delay2.sensor_m_flow.port_b.p;
      BOP.delay2.sensor_m_flow.port_a.h_outflow = inStream(BOP.delay2.sensor_m_flow.port_b.h_outflow);
      BOP.delay2.sensor_m_flow.port_b.h_outflow = inStream(BOP.delay2.sensor_m_flow.port_a.h_outflow);
      BOP.delay2.sensor_m_flow.port_a.Xi_outflow = inStream(BOP.delay2.sensor_m_flow.port_b.Xi_outflow);
      BOP.delay2.sensor_m_flow.port_b.Xi_outflow = inStream(BOP.delay2.sensor_m_flow.port_a.Xi_outflow);
      BOP.delay2.sensor_m_flow.port_a.C_outflow = inStream(BOP.delay2.sensor_m_flow.port_b.C_outflow);
      BOP.delay2.sensor_m_flow.port_b.C_outflow = inStream(BOP.delay2.sensor_m_flow.port_a.C_outflow);
    // end of extends 
  equation
    BOP.delay2.sensor_m_flow.m_flow = BOP.delay2.sensor_m_flow.port_a.m_flow;

  // Component BOP.delay2.sensor_h
  // class TRANSFORM.Fluid.Sensors.SpecificEnthalpy
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      BOP.delay2.sensor_h.port.m_flow = 0;
      BOP.delay2.sensor_h.port.h_outflow = 84013.0581525969;
      BOP.delay2.sensor_h.port.Xi_outflow = {};
      BOP.delay2.sensor_h.port.C_outflow = zeros(0);
    // end of extends 
  equation
    BOP.delay2.sensor_h.h_out = inStream(BOP.delay2.sensor_h.port.h_outflow);

  // Component BOP.delay2.boundary.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (BOP.delay2.boundary.medium.standardOrderComponents) then 
        BOP.delay2.boundary.medium.Xi = BOP.delay2.boundary.medium.X[1:0];
        BOP.delay2.boundary.medium.X = {1.0};
        for i in (1:1) loop
          assert(BOP.delay2.boundary.medium.X[i] >= -1E-05 and BOP.delay2.boundary.medium.X
            [i] <= 1.00001, "Mass fraction X["+       String(i, true, 0)+"] = "+
                   String(BOP.delay2.boundary.medium.X[i], true, 0)+
            "of substance "+({"water"})[i]+"\nof medium "+"WaterIF97"+
            " is not in the range 0..1");
        end for;
      end if;
      assert(BOP.delay2.boundary.medium.p >= 0.0, "Pressure (= "+       String(
        BOP.delay2.boundary.medium.p, true, 0)+" Pa) of medium \""+"WaterIF97"+
        "\" is negative\n(Temperature = "+       String(BOP.delay2.boundary.medium.T,
         true, 0)+" K)");
    // end of extends 
  equation
    BOP.delay2.boundary.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    BOP.delay2.boundary.medium.phase = (if BOP.delay2.boundary.medium.h < 
      Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique25(
      BOP.delay2.boundary.medium.sat) or BOP.delay2.boundary.medium.h > 
      Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique28(
      BOP.delay2.boundary.medium.sat) or BOP.delay2.boundary.medium.p > 
      _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].
      criticalPressure then 1 else 2);
    BOP.delay2.boundary.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique20
      (BOP.delay2.boundary.medium.p, BOP.delay2.boundary.medium.h, 
      BOP.delay2.boundary.medium.phase, 0);
    BOP.delay2.boundary.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique21
      (BOP.delay2.boundary.medium.p, BOP.delay2.boundary.medium.h, 
      BOP.delay2.boundary.medium.phase, 0);
    BOP.delay2.boundary.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique23
      (BOP.delay2.boundary.medium.p);
    BOP.delay2.boundary.medium.sat.psat = BOP.delay2.boundary.medium.p;
    BOP.delay2.boundary.medium.u = BOP.delay2.boundary.medium.h-BOP.delay2.boundary.medium.p
      /BOP.delay2.boundary.medium.d;
    BOP.delay2.boundary.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    BOP.delay2.boundary.medium.h = BOP.delay2.boundary.medium.state.h;
    BOP.delay2.boundary.medium.p = BOP.delay2.boundary.medium.state.p;
    BOP.delay2.boundary.medium.T = BOP.delay2.boundary.medium.state.T;
    BOP.delay2.boundary.medium.d = BOP.delay2.boundary.medium.state.d;
    BOP.delay2.boundary.medium.phase = BOP.delay2.boundary.medium.state.phase;

  // Component BOP.delay2.boundary
  // class TRANSFORM.Fluid.BoundaryConditions.Boundary_ph
    // extends TRANSFORM.Fluid.BoundaryConditions.BaseClasses.PartialSource
    equation
      for i in (1:BOP.delay2.boundary.nPorts) loop
        assert(cardinality(BOP.delay2.boundary.ports[i]) <= 1, "
each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
        BOP.delay2.boundary.ports[i].p = BOP.delay2.boundary.medium.p;
        BOP.delay2.boundary.ports[i].h_outflow = BOP.delay2.boundary.medium.h;
        BOP.delay2.boundary.ports[i].Xi_outflow = BOP.delay2.boundary.medium.Xi;
      end for;
    // end of extends 
  equation
    Modelica.Fluid.Utilities.checkBoundary("WaterIF97", {"water"}, false, true, 
      BOP.delay2.boundary.X_in_internal, "Boundary_ph");
    if ( not BOP.delay2.boundary.use_p_in) then 
      BOP.delay2.boundary.p_in_internal = BOP.delay2.boundary.p;
    end if;
    if ( not BOP.delay2.boundary.use_h_in) then 
      BOP.delay2.boundary.h_in_internal = BOP.delay2.boundary.h;
    end if;
    if ( not BOP.delay2.boundary.use_X_in) then 
      BOP.delay2.boundary.X_in_internal = BOP.delay2.boundary.X;
    end if;
    if ( not BOP.delay2.boundary.use_C_in) then 
      BOP.delay2.boundary.C_in_internal = BOP.delay2.boundary.C;
    end if;
    BOP.delay2.boundary.medium.p = BOP.delay2.boundary.p_in_internal;
    BOP.delay2.boundary.medium.h = BOP.delay2.boundary.h_in_internal;
    BOP.delay2.boundary.medium.Xi = BOP.delay2.boundary.X_in_internal[1:0];
    BOP.delay2.boundary.ports.C_outflow = fill(BOP.delay2.boundary.C_in_internal,
       BOP.delay2.boundary.nPorts);
    BOP.delay2.boundary.p_in_internal = BOP.delay2.boundary.p_in;

  // Component BOP.delay2.boundary1.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (BOP.delay2.boundary1.medium.standardOrderComponents) then 
        BOP.delay2.boundary1.medium.Xi = BOP.delay2.boundary1.medium.X[1:0];
        BOP.delay2.boundary1.medium.X = {1.0};
        for i in (1:1) loop
          assert(BOP.delay2.boundary1.medium.X[i] >= -1E-05 and BOP.delay2.boundary1.medium.X
            [i] <= 1.00001, "Mass fraction X["+       String(i, true, 0)+"] = "+
                   String(BOP.delay2.boundary1.medium.X[i], true, 0)+
            "of substance "+({"water"})[i]+"\nof medium "+"WaterIF97"+
            " is not in the range 0..1");
        end for;
      end if;
      assert(BOP.delay2.boundary1.medium.p >= 0.0, "Pressure (= "+       String(
        BOP.delay2.boundary1.medium.p, true, 0)+" Pa) of medium \""+"WaterIF97"+
        "\" is negative\n(Temperature = "+       String(BOP.delay2.boundary1.medium.T,
         true, 0)+" K)");
    // end of extends 
  equation
    BOP.delay2.boundary1.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    BOP.delay2.boundary1.medium.phase = (if BOP.delay2.boundary1.medium.h < 
      Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique25(
      BOP.delay2.boundary1.medium.sat) or BOP.delay2.boundary1.medium.h > 
      Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique28(
      BOP.delay2.boundary1.medium.sat) or BOP.delay2.boundary1.medium.p > 
      _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].
      criticalPressure then 1 else 2);
    BOP.delay2.boundary1.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique20
      (BOP.delay2.boundary1.medium.p, BOP.delay2.boundary1.medium.h, 
      BOP.delay2.boundary1.medium.phase, 0);
    BOP.delay2.boundary1.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique21
      (BOP.delay2.boundary1.medium.p, BOP.delay2.boundary1.medium.h, 
      BOP.delay2.boundary1.medium.phase, 0);
    BOP.delay2.boundary1.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique23
      (BOP.delay2.boundary1.medium.p);
    BOP.delay2.boundary1.medium.sat.psat = BOP.delay2.boundary1.medium.p;
    BOP.delay2.boundary1.medium.u = BOP.delay2.boundary1.medium.h-
      BOP.delay2.boundary1.medium.p/BOP.delay2.boundary1.medium.d;
    BOP.delay2.boundary1.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    BOP.delay2.boundary1.medium.h = BOP.delay2.boundary1.medium.state.h;
    BOP.delay2.boundary1.medium.p = BOP.delay2.boundary1.medium.state.p;
    BOP.delay2.boundary1.medium.T = BOP.delay2.boundary1.medium.state.T;
    BOP.delay2.boundary1.medium.d = BOP.delay2.boundary1.medium.state.d;
    BOP.delay2.boundary1.medium.phase = BOP.delay2.boundary1.medium.state.phase;

  // Component BOP.delay2.boundary1
  // class TRANSFORM.Fluid.BoundaryConditions.MassFlowSource_h
    // extends TRANSFORM.Fluid.BoundaryConditions.BaseClasses.PartialFlowSource
    equation
      assert(abs(sum(abs(BOP.delay2.boundary1.ports.m_flow))-max(abs(
        BOP.delay2.boundary1.ports.m_flow))) <= 1E-60, "FlowSource only supports one connection with flow");
      for i in (1:BOP.delay2.boundary1.nPorts) loop
        assert(cardinality(BOP.delay2.boundary1.ports[i]) <= 1, "
each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
        BOP.delay2.boundary1.ports[i].p = BOP.delay2.boundary1.medium.p;
        BOP.delay2.boundary1.ports[i].h_outflow = BOP.delay2.boundary1.medium.h;
        BOP.delay2.boundary1.ports[i].Xi_outflow = BOP.delay2.boundary1.medium.Xi;
      end for;
    // end of extends 
  equation
    Modelica.Fluid.Utilities.checkBoundary("WaterIF97", {"water"}, false, true, 
      BOP.delay2.boundary1.X_in_internal, "MassFlowSource_h");
    if ( not BOP.delay2.boundary1.use_m_flow_in) then 
      BOP.delay2.boundary1.m_flow_in_internal = BOP.delay2.boundary1.m_flow;
    end if;
    if ( not BOP.delay2.boundary1.use_h_in) then 
      BOP.delay2.boundary1.h_in_internal = BOP.delay2.boundary1.h;
    end if;
    if ( not BOP.delay2.boundary1.use_X_in) then 
      BOP.delay2.boundary1.X_in_internal = BOP.delay2.boundary1.X;
    end if;
    if ( not BOP.delay2.boundary1.use_C_in) then 
      BOP.delay2.boundary1.C_in_internal = BOP.delay2.boundary1.C;
    end if;
    BOP.delay2.boundary1.medium.h = BOP.delay2.boundary1.h_in_internal;
    sum(BOP.delay2.boundary1.ports.m_flow) =  -BOP.delay2.boundary1.m_flow_in_internal;
    BOP.delay2.boundary1.medium.Xi = BOP.delay2.boundary1.X_in_internal[1:0];
    BOP.delay2.boundary1.ports.C_outflow = fill(BOP.delay2.boundary1.C_in_internal,
       BOP.delay2.boundary1.nPorts);
    BOP.delay2.boundary1.h_in_internal = BOP.delay2.boundary1.h_in;
    BOP.delay2.boundary1.m_flow_in_internal = BOP.delay2.boundary1.m_flow_in;

  // Component BOP.delay2.limiter1
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(BOP.delay2.limiter1.uMax >= BOP.delay2.limiter1.uMin, 
      "Limiter: Limits must be consistent. However, uMax (="+       String(
      BOP.delay2.limiter1.uMax, true, 0)+") < uMin (="+       String(
      BOP.delay2.limiter1.uMin, true, 0)+")");
    BOP.delay2.limiter1.simplifiedExpr = (if BOP.delay2.limiter1.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.Linear then BOP.delay2.limiter1.u
       else (if BOP.delay2.limiter1.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then BOP.delay2.limiter1.uMax else (if BOP.delay2.limiter1.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then BOP.delay2.limiter1.uMin
       else 0)));
    if (BOP.delay2.limiter1.strict) then 
      if (BOP.delay2.limiter1.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.delay2.limiter1.y = smooth(0, noEvent((if BOP.delay2.limiter1.u > 
          BOP.delay2.limiter1.uMax then BOP.delay2.limiter1.uMax else (if 
          BOP.delay2.limiter1.u < BOP.delay2.limiter1.uMin then BOP.delay2.limiter1.uMin
           else BOP.delay2.limiter1.u))));
      else
        BOP.delay2.limiter1.y = homotopy(smooth(0, noEvent((if BOP.delay2.limiter1.u
           > BOP.delay2.limiter1.uMax then BOP.delay2.limiter1.uMax else (if 
          BOP.delay2.limiter1.u < BOP.delay2.limiter1.uMin then BOP.delay2.limiter1.uMin
           else BOP.delay2.limiter1.u)))), BOP.delay2.limiter1.simplifiedExpr);
      end if;
    else
      if (BOP.delay2.limiter1.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.delay2.limiter1.y = smooth(0, (if BOP.delay2.limiter1.u > 
          BOP.delay2.limiter1.uMax then BOP.delay2.limiter1.uMax else (if 
          BOP.delay2.limiter1.u < BOP.delay2.limiter1.uMin then BOP.delay2.limiter1.uMin
           else BOP.delay2.limiter1.u)));
      else
        BOP.delay2.limiter1.y = homotopy(smooth(0, (if BOP.delay2.limiter1.u > 
          BOP.delay2.limiter1.uMax then BOP.delay2.limiter1.uMax else (if 
          BOP.delay2.limiter1.u < BOP.delay2.limiter1.uMin then BOP.delay2.limiter1.uMin
           else BOP.delay2.limiter1.u))), BOP.delay2.limiter1.simplifiedExpr);
      end if;
    end if;

  // Component BOP.delay2.limiter2
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(BOP.delay2.limiter2.uMax >= BOP.delay2.limiter2.uMin, 
      "Limiter: Limits must be consistent. However, uMax (="+       String(
      BOP.delay2.limiter2.uMax, true, 0)+") < uMin (="+       String(
      BOP.delay2.limiter2.uMin, true, 0)+")");
    BOP.delay2.limiter2.simplifiedExpr = (if BOP.delay2.limiter2.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.Linear then BOP.delay2.limiter2.u
       else (if BOP.delay2.limiter2.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then BOP.delay2.limiter2.uMax else (if BOP.delay2.limiter2.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then BOP.delay2.limiter2.uMin
       else 0)));
    if (BOP.delay2.limiter2.strict) then 
      if (BOP.delay2.limiter2.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.delay2.limiter2.y = smooth(0, noEvent((if BOP.delay2.limiter2.u > 
          BOP.delay2.limiter2.uMax then BOP.delay2.limiter2.uMax else (if 
          BOP.delay2.limiter2.u < BOP.delay2.limiter2.uMin then BOP.delay2.limiter2.uMin
           else BOP.delay2.limiter2.u))));
      else
        BOP.delay2.limiter2.y = homotopy(smooth(0, noEvent((if BOP.delay2.limiter2.u
           > BOP.delay2.limiter2.uMax then BOP.delay2.limiter2.uMax else (if 
          BOP.delay2.limiter2.u < BOP.delay2.limiter2.uMin then BOP.delay2.limiter2.uMin
           else BOP.delay2.limiter2.u)))), BOP.delay2.limiter2.simplifiedExpr);
      end if;
    else
      if (BOP.delay2.limiter2.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.delay2.limiter2.y = smooth(0, (if BOP.delay2.limiter2.u > 
          BOP.delay2.limiter2.uMax then BOP.delay2.limiter2.uMax else (if 
          BOP.delay2.limiter2.u < BOP.delay2.limiter2.uMin then BOP.delay2.limiter2.uMin
           else BOP.delay2.limiter2.u)));
      else
        BOP.delay2.limiter2.y = homotopy(smooth(0, (if BOP.delay2.limiter2.u > 
          BOP.delay2.limiter2.uMax then BOP.delay2.limiter2.uMax else (if 
          BOP.delay2.limiter2.u < BOP.delay2.limiter2.uMin then BOP.delay2.limiter2.uMin
           else BOP.delay2.limiter2.u))), BOP.delay2.limiter2.simplifiedExpr);
      end if;
    end if;

  // Component BOP.delay2.limiter
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(BOP.delay2.limiter.uMax >= BOP.delay2.limiter.uMin, "Limiter: Limits must be consistent. However, uMax (="
      +       String(BOP.delay2.limiter.uMax, true, 0)+") < uMin (="+
             String(BOP.delay2.limiter.uMin, true, 0)+")");
    BOP.delay2.limiter.simplifiedExpr = (if BOP.delay2.limiter.homotopyType == 
      Modelica.Blocks.Types.LimiterHomotopy.Linear then BOP.delay2.limiter.u
       else (if BOP.delay2.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then BOP.delay2.limiter.uMax else (if BOP.delay2.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then BOP.delay2.limiter.uMin
       else 0)));
    if (BOP.delay2.limiter.strict) then 
      if (BOP.delay2.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.delay2.limiter.y = smooth(0, noEvent((if BOP.delay2.limiter.u > 
          BOP.delay2.limiter.uMax then BOP.delay2.limiter.uMax else (if 
          BOP.delay2.limiter.u < BOP.delay2.limiter.uMin then BOP.delay2.limiter.uMin
           else BOP.delay2.limiter.u))));
      else
        BOP.delay2.limiter.y = homotopy(smooth(0, noEvent((if BOP.delay2.limiter.u
           > BOP.delay2.limiter.uMax then BOP.delay2.limiter.uMax else (if 
          BOP.delay2.limiter.u < BOP.delay2.limiter.uMin then BOP.delay2.limiter.uMin
           else BOP.delay2.limiter.u)))), BOP.delay2.limiter.simplifiedExpr);
      end if;
    else
      if (BOP.delay2.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.delay2.limiter.y = smooth(0, (if BOP.delay2.limiter.u > 
          BOP.delay2.limiter.uMax then BOP.delay2.limiter.uMax else (if 
          BOP.delay2.limiter.u < BOP.delay2.limiter.uMin then BOP.delay2.limiter.uMin
           else BOP.delay2.limiter.u)));
      else
        BOP.delay2.limiter.y = homotopy(smooth(0, (if BOP.delay2.limiter.u > 
          BOP.delay2.limiter.uMax then BOP.delay2.limiter.uMax else (if 
          BOP.delay2.limiter.u < BOP.delay2.limiter.uMin then BOP.delay2.limiter.uMin
           else BOP.delay2.limiter.u))), BOP.delay2.limiter.simplifiedExpr);
      end if;
    end if;

  // Component BOP.delay2
  // class NHES.Fluid.Utilities.NonLinear_Break
  equation
    BOP.delay2.limiter2.y = BOP.delay2.boundary.p_in;
    BOP.delay2.boundary.ports[1].m_flow+BOP.delay2.sensor_m_flow.port_b.m_flow
       = 0.0;
    BOP.delay2.sensor_m_flow.port_b.p = BOP.delay2.boundary.ports[1].p;
    BOP.delay2.limiter1.y = BOP.delay2.boundary1.h_in;
    BOP.delay2.limiter.y = BOP.delay2.boundary1.m_flow_in;
    BOP.delay2.port_b.m_flow-BOP.delay2.boundary1.ports[1].m_flow-
      BOP.delay2.sensor_p.port.m_flow = 0.0;
    BOP.delay2.port_b.p = BOP.delay2.boundary1.ports[1].p;
    BOP.delay2.sensor_p.port.p = BOP.delay2.boundary1.ports[1].p;
    BOP.delay2.sensor_m_flow.m_flow = BOP.delay2.limiter.u;
    BOP.delay2.sensor_h.h_out = BOP.delay2.limiter1.u;
    BOP.delay2.sensor_p.p = BOP.delay2.limiter2.u;
    BOP.delay2.port_a.m_flow-BOP.delay2.sensor_h.port.m_flow-BOP.delay2.sensor_m_flow.port_a.m_flow
       = 0.0;
    BOP.delay2.sensor_h.port.p = BOP.delay2.port_a.p;
    BOP.delay2.sensor_m_flow.port_a.p = BOP.delay2.port_a.p;

  // Component BOP.delay2_2.sensor_p
  // class TRANSFORM.Fluid.Sensors.Pressure
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      BOP.delay2_2.sensor_p.port.m_flow = 0;
      BOP.delay2_2.sensor_p.port.h_outflow = 84013.0581525969;
      BOP.delay2_2.sensor_p.port.Xi_outflow = {};
      BOP.delay2_2.sensor_p.port.C_outflow = zeros(0);
    // end of extends 
  equation
    BOP.delay2_2.sensor_p.p = BOP.delay2_2.sensor_p.port.p;

  // Component BOP.delay2_2.sensor_m_flow
  // class TRANSFORM.Fluid.Sensors.MassFlowRate
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialTwoPortSensor
    equation
      0 = BOP.delay2_2.sensor_m_flow.port_a.m_flow+BOP.delay2_2.sensor_m_flow.port_b.m_flow;
      BOP.delay2_2.sensor_m_flow.port_a.p = BOP.delay2_2.sensor_m_flow.port_b.p;
      BOP.delay2_2.sensor_m_flow.port_a.h_outflow = inStream(BOP.delay2_2.sensor_m_flow.port_b.h_outflow);
      BOP.delay2_2.sensor_m_flow.port_b.h_outflow = inStream(BOP.delay2_2.sensor_m_flow.port_a.h_outflow);
      BOP.delay2_2.sensor_m_flow.port_a.Xi_outflow = inStream(BOP.delay2_2.sensor_m_flow.port_b.Xi_outflow);
      BOP.delay2_2.sensor_m_flow.port_b.Xi_outflow = inStream(BOP.delay2_2.sensor_m_flow.port_a.Xi_outflow);
      BOP.delay2_2.sensor_m_flow.port_a.C_outflow = inStream(BOP.delay2_2.sensor_m_flow.port_b.C_outflow);
      BOP.delay2_2.sensor_m_flow.port_b.C_outflow = inStream(BOP.delay2_2.sensor_m_flow.port_a.C_outflow);
    // end of extends 
  equation
    BOP.delay2_2.sensor_m_flow.m_flow = BOP.delay2_2.sensor_m_flow.port_a.m_flow;

  // Component BOP.delay2_2.sensor_h
  // class TRANSFORM.Fluid.Sensors.SpecificEnthalpy
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor
    equation
      BOP.delay2_2.sensor_h.port.m_flow = 0;
      BOP.delay2_2.sensor_h.port.h_outflow = 84013.0581525969;
      BOP.delay2_2.sensor_h.port.Xi_outflow = {};
      BOP.delay2_2.sensor_h.port.C_outflow = zeros(0);
    // end of extends 
  equation
    BOP.delay2_2.sensor_h.h_out = inStream(BOP.delay2_2.sensor_h.port.h_outflow);

  // Component BOP.delay2_2.boundary.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (BOP.delay2_2.boundary.medium.standardOrderComponents) then 
        BOP.delay2_2.boundary.medium.Xi = BOP.delay2_2.boundary.medium.X[1:0];
        BOP.delay2_2.boundary.medium.X = {1.0};
        for i in (1:1) loop
          assert(BOP.delay2_2.boundary.medium.X[i] >= -1E-05 and 
            BOP.delay2_2.boundary.medium.X[i] <= 1.00001, "Mass fraction X["+
                   String(i, true, 0)+"] = "+       String(BOP.delay2_2.boundary.medium.X
            [i], true, 0)+"of substance "+({"water"})[i]+"\nof medium "+
            "WaterIF97"+" is not in the range 0..1");
        end for;
      end if;
      assert(BOP.delay2_2.boundary.medium.p >= 0.0, "Pressure (= "+       String
        (BOP.delay2_2.boundary.medium.p, true, 0)+" Pa) of medium \""+
        "WaterIF97"+"\" is negative\n(Temperature = "+       String(
        BOP.delay2_2.boundary.medium.T, true, 0)+" K)");
    // end of extends 
  equation
    BOP.delay2_2.boundary.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    BOP.delay2_2.boundary.medium.phase = (if BOP.delay2_2.boundary.medium.h < 
      Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique25(
      BOP.delay2_2.boundary.medium.sat) or BOP.delay2_2.boundary.medium.h > 
      Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique28(
      BOP.delay2_2.boundary.medium.sat) or BOP.delay2_2.boundary.medium.p > 
      _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].
      criticalPressure then 1 else 2);
    BOP.delay2_2.boundary.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique20
      (BOP.delay2_2.boundary.medium.p, BOP.delay2_2.boundary.medium.h, 
      BOP.delay2_2.boundary.medium.phase, 0);
    BOP.delay2_2.boundary.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique21
      (BOP.delay2_2.boundary.medium.p, BOP.delay2_2.boundary.medium.h, 
      BOP.delay2_2.boundary.medium.phase, 0);
    BOP.delay2_2.boundary.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique23
      (BOP.delay2_2.boundary.medium.p);
    BOP.delay2_2.boundary.medium.sat.psat = BOP.delay2_2.boundary.medium.p;
    BOP.delay2_2.boundary.medium.u = BOP.delay2_2.boundary.medium.h-
      BOP.delay2_2.boundary.medium.p/BOP.delay2_2.boundary.medium.d;
    BOP.delay2_2.boundary.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    BOP.delay2_2.boundary.medium.h = BOP.delay2_2.boundary.medium.state.h;
    BOP.delay2_2.boundary.medium.p = BOP.delay2_2.boundary.medium.state.p;
    BOP.delay2_2.boundary.medium.T = BOP.delay2_2.boundary.medium.state.T;
    BOP.delay2_2.boundary.medium.d = BOP.delay2_2.boundary.medium.state.d;
    BOP.delay2_2.boundary.medium.phase = BOP.delay2_2.boundary.medium.state.phase;

  // Component BOP.delay2_2.boundary
  // class TRANSFORM.Fluid.BoundaryConditions.Boundary_ph
    // extends TRANSFORM.Fluid.BoundaryConditions.BaseClasses.PartialSource
    equation
      for i in (1:BOP.delay2_2.boundary.nPorts) loop
        assert(cardinality(BOP.delay2_2.boundary.ports[i]) <= 1, 
          "
each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
        BOP.delay2_2.boundary.ports[i].p = BOP.delay2_2.boundary.medium.p;
        BOP.delay2_2.boundary.ports[i].h_outflow = BOP.delay2_2.boundary.medium.h;
        BOP.delay2_2.boundary.ports[i].Xi_outflow = BOP.delay2_2.boundary.medium.Xi;
      end for;
    // end of extends 
  equation
    Modelica.Fluid.Utilities.checkBoundary("WaterIF97", {"water"}, false, true, 
      BOP.delay2_2.boundary.X_in_internal, "Boundary_ph");
    if ( not BOP.delay2_2.boundary.use_p_in) then 
      BOP.delay2_2.boundary.p_in_internal = BOP.delay2_2.boundary.p;
    end if;
    if ( not BOP.delay2_2.boundary.use_h_in) then 
      BOP.delay2_2.boundary.h_in_internal = BOP.delay2_2.boundary.h;
    end if;
    if ( not BOP.delay2_2.boundary.use_X_in) then 
      BOP.delay2_2.boundary.X_in_internal = BOP.delay2_2.boundary.X;
    end if;
    if ( not BOP.delay2_2.boundary.use_C_in) then 
      BOP.delay2_2.boundary.C_in_internal = BOP.delay2_2.boundary.C;
    end if;
    BOP.delay2_2.boundary.medium.p = BOP.delay2_2.boundary.p_in_internal;
    BOP.delay2_2.boundary.medium.h = BOP.delay2_2.boundary.h_in_internal;
    BOP.delay2_2.boundary.medium.Xi = BOP.delay2_2.boundary.X_in_internal[1:0];
    BOP.delay2_2.boundary.ports.C_outflow = fill(BOP.delay2_2.boundary.C_in_internal,
       BOP.delay2_2.boundary.nPorts);
    BOP.delay2_2.boundary.p_in_internal = BOP.delay2_2.boundary.p_in;

  // Component BOP.delay2_2.boundary1.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (BOP.delay2_2.boundary1.medium.standardOrderComponents) then 
        BOP.delay2_2.boundary1.medium.Xi = BOP.delay2_2.boundary1.medium.X[1:0];
        BOP.delay2_2.boundary1.medium.X = {1.0};
        for i in (1:1) loop
          assert(BOP.delay2_2.boundary1.medium.X[i] >= -1E-05 and 
            BOP.delay2_2.boundary1.medium.X[i] <= 1.00001, "Mass fraction X["+
                   String(i, true, 0)+"] = "+       String(BOP.delay2_2.boundary1.medium.X
            [i], true, 0)+"of substance "+({"water"})[i]+"\nof medium "+
            "WaterIF97"+" is not in the range 0..1");
        end for;
      end if;
      assert(BOP.delay2_2.boundary1.medium.p >= 0.0, "Pressure (= "+
               String(BOP.delay2_2.boundary1.medium.p, true, 0)+" Pa) of medium \""
        +"WaterIF97"+"\" is negative\n(Temperature = "+       String(
        BOP.delay2_2.boundary1.medium.T, true, 0)+" K)");
    // end of extends 
  equation
    BOP.delay2_2.boundary1.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    BOP.delay2_2.boundary1.medium.phase = (if BOP.delay2_2.boundary1.medium.h < 
      Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique25(
      BOP.delay2_2.boundary1.medium.sat) or BOP.delay2_2.boundary1.medium.h > 
      Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique28(
      BOP.delay2_2.boundary1.medium.sat) or BOP.delay2_2.boundary1.medium.p > 
      _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1].
      criticalPressure then 1 else 2);
    BOP.delay2_2.boundary1.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique20
      (BOP.delay2_2.boundary1.medium.p, BOP.delay2_2.boundary1.medium.h, 
      BOP.delay2_2.boundary1.medium.phase, 0);
    BOP.delay2_2.boundary1.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique21
      (BOP.delay2_2.boundary1.medium.p, BOP.delay2_2.boundary1.medium.h, 
      BOP.delay2_2.boundary1.medium.phase, 0);
    BOP.delay2_2.boundary1.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique23
      (BOP.delay2_2.boundary1.medium.p);
    BOP.delay2_2.boundary1.medium.sat.psat = BOP.delay2_2.boundary1.medium.p;
    BOP.delay2_2.boundary1.medium.u = BOP.delay2_2.boundary1.medium.h-
      BOP.delay2_2.boundary1.medium.p/BOP.delay2_2.boundary1.medium.d;
    BOP.delay2_2.boundary1.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    BOP.delay2_2.boundary1.medium.h = BOP.delay2_2.boundary1.medium.state.h;
    BOP.delay2_2.boundary1.medium.p = BOP.delay2_2.boundary1.medium.state.p;
    BOP.delay2_2.boundary1.medium.T = BOP.delay2_2.boundary1.medium.state.T;
    BOP.delay2_2.boundary1.medium.d = BOP.delay2_2.boundary1.medium.state.d;
    BOP.delay2_2.boundary1.medium.phase = BOP.delay2_2.boundary1.medium.state.phase;

  // Component BOP.delay2_2.boundary1
  // class TRANSFORM.Fluid.BoundaryConditions.MassFlowSource_h
    // extends TRANSFORM.Fluid.BoundaryConditions.BaseClasses.PartialFlowSource
    equation
      assert(abs(sum(abs(BOP.delay2_2.boundary1.ports.m_flow))-max(abs(
        BOP.delay2_2.boundary1.ports.m_flow))) <= 1E-60, "FlowSource only supports one connection with flow");
      for i in (1:BOP.delay2_2.boundary1.nPorts) loop
        assert(cardinality(BOP.delay2_2.boundary1.ports[i]) <= 1, 
          "
each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
        BOP.delay2_2.boundary1.ports[i].p = BOP.delay2_2.boundary1.medium.p;
        BOP.delay2_2.boundary1.ports[i].h_outflow = BOP.delay2_2.boundary1.medium.h;
        BOP.delay2_2.boundary1.ports[i].Xi_outflow = BOP.delay2_2.boundary1.medium.Xi;
      end for;
    // end of extends 
  equation
    Modelica.Fluid.Utilities.checkBoundary("WaterIF97", {"water"}, false, true, 
      BOP.delay2_2.boundary1.X_in_internal, "MassFlowSource_h");
    if ( not BOP.delay2_2.boundary1.use_m_flow_in) then 
      BOP.delay2_2.boundary1.m_flow_in_internal = BOP.delay2_2.boundary1.m_flow;
    end if;
    if ( not BOP.delay2_2.boundary1.use_h_in) then 
      BOP.delay2_2.boundary1.h_in_internal = BOP.delay2_2.boundary1.h;
    end if;
    if ( not BOP.delay2_2.boundary1.use_X_in) then 
      BOP.delay2_2.boundary1.X_in_internal = BOP.delay2_2.boundary1.X;
    end if;
    if ( not BOP.delay2_2.boundary1.use_C_in) then 
      BOP.delay2_2.boundary1.C_in_internal = BOP.delay2_2.boundary1.C;
    end if;
    BOP.delay2_2.boundary1.medium.h = BOP.delay2_2.boundary1.h_in_internal;
    sum(BOP.delay2_2.boundary1.ports.m_flow) =  -BOP.delay2_2.boundary1.m_flow_in_internal;
    BOP.delay2_2.boundary1.medium.Xi = BOP.delay2_2.boundary1.X_in_internal[1:0];
    BOP.delay2_2.boundary1.ports.C_outflow = fill(BOP.delay2_2.boundary1.C_in_internal,
       BOP.delay2_2.boundary1.nPorts);
    BOP.delay2_2.boundary1.h_in_internal = BOP.delay2_2.boundary1.h_in;
    BOP.delay2_2.boundary1.m_flow_in_internal = BOP.delay2_2.boundary1.m_flow_in;

  // Component BOP.delay2_2.limiter1
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(BOP.delay2_2.limiter1.uMax >= BOP.delay2_2.limiter1.uMin, 
      "Limiter: Limits must be consistent. However, uMax (="+       String(
      BOP.delay2_2.limiter1.uMax, true, 0)+") < uMin (="+       String(
      BOP.delay2_2.limiter1.uMin, true, 0)+")");
    BOP.delay2_2.limiter1.simplifiedExpr = (if BOP.delay2_2.limiter1.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.Linear then BOP.delay2_2.limiter1.u
       else (if BOP.delay2_2.limiter1.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then BOP.delay2_2.limiter1.uMax else (if BOP.delay2_2.limiter1.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then BOP.delay2_2.limiter1.uMin
       else 0)));
    if (BOP.delay2_2.limiter1.strict) then 
      if (BOP.delay2_2.limiter1.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.delay2_2.limiter1.y = smooth(0, noEvent((if BOP.delay2_2.limiter1.u
           > BOP.delay2_2.limiter1.uMax then BOP.delay2_2.limiter1.uMax else (
          if BOP.delay2_2.limiter1.u < BOP.delay2_2.limiter1.uMin then 
          BOP.delay2_2.limiter1.uMin else BOP.delay2_2.limiter1.u))));
      else
        BOP.delay2_2.limiter1.y = homotopy(smooth(0, noEvent((if 
          BOP.delay2_2.limiter1.u > BOP.delay2_2.limiter1.uMax then 
          BOP.delay2_2.limiter1.uMax else (if BOP.delay2_2.limiter1.u < 
          BOP.delay2_2.limiter1.uMin then BOP.delay2_2.limiter1.uMin else 
          BOP.delay2_2.limiter1.u)))), BOP.delay2_2.limiter1.simplifiedExpr);
      end if;
    else
      if (BOP.delay2_2.limiter1.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.delay2_2.limiter1.y = smooth(0, (if BOP.delay2_2.limiter1.u > 
          BOP.delay2_2.limiter1.uMax then BOP.delay2_2.limiter1.uMax else (if 
          BOP.delay2_2.limiter1.u < BOP.delay2_2.limiter1.uMin then 
          BOP.delay2_2.limiter1.uMin else BOP.delay2_2.limiter1.u)));
      else
        BOP.delay2_2.limiter1.y = homotopy(smooth(0, (if BOP.delay2_2.limiter1.u
           > BOP.delay2_2.limiter1.uMax then BOP.delay2_2.limiter1.uMax else (
          if BOP.delay2_2.limiter1.u < BOP.delay2_2.limiter1.uMin then 
          BOP.delay2_2.limiter1.uMin else BOP.delay2_2.limiter1.u))), 
          BOP.delay2_2.limiter1.simplifiedExpr);
      end if;
    end if;

  // Component BOP.delay2_2.limiter2
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(BOP.delay2_2.limiter2.uMax >= BOP.delay2_2.limiter2.uMin, 
      "Limiter: Limits must be consistent. However, uMax (="+       String(
      BOP.delay2_2.limiter2.uMax, true, 0)+") < uMin (="+       String(
      BOP.delay2_2.limiter2.uMin, true, 0)+")");
    BOP.delay2_2.limiter2.simplifiedExpr = (if BOP.delay2_2.limiter2.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.Linear then BOP.delay2_2.limiter2.u
       else (if BOP.delay2_2.limiter2.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then BOP.delay2_2.limiter2.uMax else (if BOP.delay2_2.limiter2.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then BOP.delay2_2.limiter2.uMin
       else 0)));
    if (BOP.delay2_2.limiter2.strict) then 
      if (BOP.delay2_2.limiter2.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.delay2_2.limiter2.y = smooth(0, noEvent((if BOP.delay2_2.limiter2.u
           > BOP.delay2_2.limiter2.uMax then BOP.delay2_2.limiter2.uMax else (
          if BOP.delay2_2.limiter2.u < BOP.delay2_2.limiter2.uMin then 
          BOP.delay2_2.limiter2.uMin else BOP.delay2_2.limiter2.u))));
      else
        BOP.delay2_2.limiter2.y = homotopy(smooth(0, noEvent((if 
          BOP.delay2_2.limiter2.u > BOP.delay2_2.limiter2.uMax then 
          BOP.delay2_2.limiter2.uMax else (if BOP.delay2_2.limiter2.u < 
          BOP.delay2_2.limiter2.uMin then BOP.delay2_2.limiter2.uMin else 
          BOP.delay2_2.limiter2.u)))), BOP.delay2_2.limiter2.simplifiedExpr);
      end if;
    else
      if (BOP.delay2_2.limiter2.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.delay2_2.limiter2.y = smooth(0, (if BOP.delay2_2.limiter2.u > 
          BOP.delay2_2.limiter2.uMax then BOP.delay2_2.limiter2.uMax else (if 
          BOP.delay2_2.limiter2.u < BOP.delay2_2.limiter2.uMin then 
          BOP.delay2_2.limiter2.uMin else BOP.delay2_2.limiter2.u)));
      else
        BOP.delay2_2.limiter2.y = homotopy(smooth(0, (if BOP.delay2_2.limiter2.u
           > BOP.delay2_2.limiter2.uMax then BOP.delay2_2.limiter2.uMax else (
          if BOP.delay2_2.limiter2.u < BOP.delay2_2.limiter2.uMin then 
          BOP.delay2_2.limiter2.uMin else BOP.delay2_2.limiter2.u))), 
          BOP.delay2_2.limiter2.simplifiedExpr);
      end if;
    end if;

  // Component BOP.delay2_2.limiter
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(BOP.delay2_2.limiter.uMax >= BOP.delay2_2.limiter.uMin, 
      "Limiter: Limits must be consistent. However, uMax (="+       String(
      BOP.delay2_2.limiter.uMax, true, 0)+") < uMin (="+       String(
      BOP.delay2_2.limiter.uMin, true, 0)+")");
    BOP.delay2_2.limiter.simplifiedExpr = (if BOP.delay2_2.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.Linear then BOP.delay2_2.limiter.u
       else (if BOP.delay2_2.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then BOP.delay2_2.limiter.uMax else (if BOP.delay2_2.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then BOP.delay2_2.limiter.uMin
       else 0)));
    if (BOP.delay2_2.limiter.strict) then 
      if (BOP.delay2_2.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.delay2_2.limiter.y = smooth(0, noEvent((if BOP.delay2_2.limiter.u > 
          BOP.delay2_2.limiter.uMax then BOP.delay2_2.limiter.uMax else (if 
          BOP.delay2_2.limiter.u < BOP.delay2_2.limiter.uMin then 
          BOP.delay2_2.limiter.uMin else BOP.delay2_2.limiter.u))));
      else
        BOP.delay2_2.limiter.y = homotopy(smooth(0, noEvent((if BOP.delay2_2.limiter.u
           > BOP.delay2_2.limiter.uMax then BOP.delay2_2.limiter.uMax else (if 
          BOP.delay2_2.limiter.u < BOP.delay2_2.limiter.uMin then 
          BOP.delay2_2.limiter.uMin else BOP.delay2_2.limiter.u)))), 
          BOP.delay2_2.limiter.simplifiedExpr);
      end if;
    else
      if (BOP.delay2_2.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        BOP.delay2_2.limiter.y = smooth(0, (if BOP.delay2_2.limiter.u > 
          BOP.delay2_2.limiter.uMax then BOP.delay2_2.limiter.uMax else (if 
          BOP.delay2_2.limiter.u < BOP.delay2_2.limiter.uMin then 
          BOP.delay2_2.limiter.uMin else BOP.delay2_2.limiter.u)));
      else
        BOP.delay2_2.limiter.y = homotopy(smooth(0, (if BOP.delay2_2.limiter.u
           > BOP.delay2_2.limiter.uMax then BOP.delay2_2.limiter.uMax else (if 
          BOP.delay2_2.limiter.u < BOP.delay2_2.limiter.uMin then 
          BOP.delay2_2.limiter.uMin else BOP.delay2_2.limiter.u))), 
          BOP.delay2_2.limiter.simplifiedExpr);
      end if;
    end if;

  // Component BOP.delay2_2
  // class NHES.Fluid.Utilities.NonLinear_Break
  equation
    BOP.delay2_2.limiter2.y = BOP.delay2_2.boundary.p_in;
    BOP.delay2_2.boundary.ports[1].m_flow+BOP.delay2_2.sensor_m_flow.port_b.m_flow
       = 0.0;
    BOP.delay2_2.sensor_m_flow.port_b.p = BOP.delay2_2.boundary.ports[1].p;
    BOP.delay2_2.limiter1.y = BOP.delay2_2.boundary1.h_in;
    BOP.delay2_2.limiter.y = BOP.delay2_2.boundary1.m_flow_in;
    BOP.delay2_2.port_b.m_flow-BOP.delay2_2.boundary1.ports[1].m_flow-
      BOP.delay2_2.sensor_p.port.m_flow = 0.0;
    BOP.delay2_2.port_b.p = BOP.delay2_2.boundary1.ports[1].p;
    BOP.delay2_2.sensor_p.port.p = BOP.delay2_2.boundary1.ports[1].p;
    BOP.delay2_2.sensor_m_flow.m_flow = BOP.delay2_2.limiter.u;
    BOP.delay2_2.sensor_h.h_out = BOP.delay2_2.limiter1.u;
    BOP.delay2_2.sensor_p.p = BOP.delay2_2.limiter2.u;
    BOP.delay2_2.port_a.m_flow-BOP.delay2_2.sensor_h.port.m_flow-
      BOP.delay2_2.sensor_m_flow.port_a.m_flow = 0.0;
    BOP.delay2_2.sensor_h.port.p = BOP.delay2_2.port_a.p;
    BOP.delay2_2.sensor_m_flow.port_a.p = BOP.delay2_2.port_a.p;

  // Component BOP.sensor_m_flow
  // class TRANSFORM.Fluid.Sensors.MassFlowRate
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialTwoPortSensor
    equation
      0 = BOP.sensor_m_flow.port_a.m_flow+BOP.sensor_m_flow.port_b.m_flow;
      BOP.sensor_m_flow.port_a.p = BOP.sensor_m_flow.port_b.p;
      BOP.sensor_m_flow.port_a.h_outflow = inStream(BOP.sensor_m_flow.port_b.h_outflow);
      BOP.sensor_m_flow.port_b.h_outflow = inStream(BOP.sensor_m_flow.port_a.h_outflow);
      BOP.sensor_m_flow.port_a.Xi_outflow = inStream(BOP.sensor_m_flow.port_b.Xi_outflow);
      BOP.sensor_m_flow.port_b.Xi_outflow = inStream(BOP.sensor_m_flow.port_a.Xi_outflow);
      BOP.sensor_m_flow.port_a.C_outflow = inStream(BOP.sensor_m_flow.port_b.C_outflow);
      BOP.sensor_m_flow.port_b.C_outflow = inStream(BOP.sensor_m_flow.port_a.C_outflow);
    // end of extends 
  equation
    BOP.sensor_m_flow.m_flow = BOP.sensor_m_flow.port_a.m_flow;

  // Component BOP.switch1
  // class Modelica.Blocks.Logical.Switch
  equation
    BOP.switch1.y = (if BOP.switch1.u2 then BOP.switch1.u1 else BOP.switch1.u3);

  // Component BOP.booleanStep1
  // class Modelica.Blocks.Sources.BooleanStep
  equation
    BOP.booleanStep1.y = (if time >= BOP.booleanStep1.startTime then  not 
      BOP.booleanStep1.startValue else BOP.booleanStep1.startValue);

  // Component BOP
  // class NHES.Systems.BalanceOfPlant.RankineCycle.Models.SteamTurbine_L3_HPOFWHsimplified_sec_RealExpressionswitch_FWHExtractionLPT
  equation
    BOP.ED.actuatorBus.Feed_Pump_Speed = BOP.CS.actuatorBus.Feed_Pump_Speed;
    BOP.actuatorBus.Feed_Pump_Speed = BOP.CS.actuatorBus.Feed_Pump_Speed;
    BOP.ED.actuatorBus.LPT1_BV = BOP.CS.actuatorBus.LPT1_BV;
    BOP.LPT1_bypass_valve.opening = BOP.CS.actuatorBus.LPT1_BV;
    BOP.actuatorBus.LPT1_BV = BOP.CS.actuatorBus.LPT1_BV;
    BOP.ED.actuatorBus.LPT2_BV = BOP.CS.actuatorBus.LPT2_BV;
    BOP.actuatorBus.LPT2_BV = BOP.CS.actuatorBus.LPT2_BV;
    BOP.switch1.u1 = BOP.CS.actuatorBus.LPT2_BV;
    BOP.ED.actuatorBus.TBV = BOP.CS.actuatorBus.TBV;
    BOP.TBV.opening = BOP.CS.actuatorBus.TBV;
    BOP.actuatorBus.TBV = BOP.CS.actuatorBus.TBV;
    BOP.ED.actuatorBus.opening_BV = BOP.CS.actuatorBus.opening_BV;
    BOP.actuatorBus.opening_BV = BOP.CS.actuatorBus.opening_BV;
    BOP.ED.actuatorBus.opening_BV_TCV = BOP.CS.actuatorBus.opening_BV_TCV;
    BOP.actuatorBus.opening_BV_TCV = BOP.CS.actuatorBus.opening_BV_TCV;
    BOP.ED.actuatorBus.opening_TCV = BOP.CS.actuatorBus.opening_TCV;
    BOP.TCV.opening = BOP.CS.actuatorBus.opening_TCV;
    BOP.actuatorBus.opening_TCV = BOP.CS.actuatorBus.opening_TCV;
    BOP.ED.actuatorBus.opening_TDV = BOP.CS.actuatorBus.opening_TDV;
    BOP.actuatorBus.opening_TDV = BOP.CS.actuatorBus.opening_TDV;
    BOP.ED.sensorBus.Extract_flow = BOP.CS.sensorBus.Extract_flow;
    BOP.sensorBus.Extract_flow = BOP.CS.sensorBus.Extract_flow;
    BOP.sensor_m_flow.m_flow = BOP.CS.sensorBus.Extract_flow;
    BOP.ED.sensorBus.Feedwater_Temp = BOP.CS.sensorBus.Feedwater_Temp;
    BOP.Feed_T.T = BOP.CS.sensorBus.Feedwater_Temp;
    BOP.sensorBus.Feedwater_Temp = BOP.CS.sensorBus.Feedwater_Temp;
    BOP.ED.sensorBus.Q_balance = BOP.CS.sensorBus.Q_balance;
    BOP.Q_balance.y = BOP.CS.sensorBus.Q_balance;
    BOP.sensorBus.Q_balance = BOP.CS.sensorBus.Q_balance;
    BOP.ED.sensorBus.Steam_Pressure = BOP.CS.sensorBus.Steam_Pressure;
    BOP.sensorBus.Steam_Pressure = BOP.CS.sensorBus.Steam_Pressure;
    BOP.sensor_p.p = BOP.CS.sensorBus.Steam_Pressure;
    BOP.ED.sensorBus.Steam_Temperature = BOP.CS.sensorBus.Steam_Temperature;
    BOP.Steam_T.T = BOP.CS.sensorBus.Steam_Temperature;
    BOP.sensorBus.Steam_Temperature = BOP.CS.sensorBus.Steam_Temperature;
    BOP.ED.sensorBus.W_balance = BOP.CS.sensorBus.W_balance;
    BOP.W_balance.y = BOP.CS.sensorBus.W_balance;
    BOP.sensorBus.W_balance = BOP.CS.sensorBus.W_balance;
    BOP.ED.sensorBus.W_total = BOP.CS.sensorBus.W_total;
    BOP.sensorBus.W_total = BOP.CS.sensorBus.W_total;
    BOP.sensorW.W = BOP.CS.sensorBus.W_total;
    BOP.ED.sensorBus.W_totalSetpoint = BOP.CS.sensorBus.W_totalSetpoint;
    BOP.sensorBus.W_totalSetpoint = BOP.CS.sensorBus.W_totalSetpoint;
    BOP.ED.sensorBus.p_inlet_steamTurbine = BOP.CS.sensorBus.p_inlet_steamTurbine;
    BOP.sensorBus.p_inlet_steamTurbine = BOP.CS.sensorBus.p_inlet_steamTurbine;
    BOP.FWCP.port_a.m_flow+BOP.OFWH_2.port_a.m_flow = 0.0;
    BOP.OFWH_2.port_a.p = BOP.FWCP.port_a.p;
    BOP.port_b_feed.m_flow-(BOP.FWCP.port_b.m_flow+BOP.Feed_T.port.m_flow) = 0.0;
    BOP.Feed_T.port.p = BOP.FWCP.port_b.p;
    BOP.port_b_feed.p = BOP.FWCP.port_b.p;
    BOP.HPT.portHP.m_flow+BOP.TCV.port_b.m_flow = 0.0;
    BOP.TCV.port_b.p = BOP.HPT.portHP.p;
    BOP.HPT.portLP.m_flow+BOP.LPT1_bypass.port_1.m_flow = 0.0;
    BOP.LPT1_bypass.port_1.p = BOP.HPT.portLP.p;
    BOP.HPT.shaft_a.tau = 0.0;
    BOP.LPT1.shaft_a.phi = BOP.HPT.shaft_b.phi;
    BOP.HPT.shaft_b.tau+BOP.LPT1.shaft_a.tau = 0.0;
    BOP.switch1.y = BOP.HPT_bypass_valve.opening;
    BOP.HPT_bypass_valve.port_a.m_flow+BOP.LPT1_bypass.port_3.m_flow = 0.0;
    BOP.LPT1_bypass.port_3.p = BOP.HPT_bypass_valve.port_a.p;
    BOP.HPT_bypass_valve.port_b.m_flow+BOP.delay2.port_a.m_flow = 0.0;
    BOP.delay2.port_a.p = BOP.HPT_bypass_valve.port_b.p;
    BOP.LPT1.portHP.m_flow+BOP.LPT1_bypass.port_2.m_flow = 0.0;
    BOP.LPT1_bypass.port_2.p = BOP.LPT1.portHP.p;
    BOP.LPT1.portLP.m_flow+BOP.moistureSeperator.port_a[1].m_flow = 0.0;
    BOP.moistureSeperator.port_a[1].p = BOP.LPT1.portLP.p;
    BOP.LPT2.shaft_a.phi = BOP.LPT1.shaft_b.phi;
    BOP.LPT1.shaft_b.tau+BOP.LPT2.shaft_a.tau = 0.0;
    BOP.port_a_steam.m_flow-(BOP.LPT1_bypass_valve.port_a.m_flow+
      BOP.Steam_T.port.m_flow+BOP.TBV.port_a.m_flow+BOP.TCV.port_a.m_flow)-
      BOP.sensor_p.port.m_flow = 0.0;
    BOP.Steam_T.port.p = BOP.LPT1_bypass_valve.port_a.p;
    BOP.TBV.port_a.p = BOP.LPT1_bypass_valve.port_a.p;
    BOP.TCV.port_a.p = BOP.LPT1_bypass_valve.port_a.p;
    BOP.port_a_steam.p = BOP.LPT1_bypass_valve.port_a.p;
    BOP.sensor_p.port.p = BOP.LPT1_bypass_valve.port_a.p;
    BOP.LPT1_bypass_valve.port_b.m_flow+BOP.sensor_m_flow.port_a.m_flow = 0.0;
    BOP.sensor_m_flow.port_a.p = BOP.LPT1_bypass_valve.port_b.p;
    BOP.LPT2.portHP.m_flow+BOP.moistureSeperator.port_b[1].m_flow = 0.0;
    BOP.moistureSeperator.port_b[1].p = BOP.LPT2.portHP.p;
    BOP.LPT2.portLP.m_flow+BOP.condenser.port_a.m_flow = 0.0;
    BOP.condenser.port_a.p = BOP.LPT2.portLP.p;
    BOP.generator.shaft.phi = BOP.LPT2.shaft_b.phi;
    BOP.LPT2.shaft_b.tau+BOP.generator.shaft.tau = 0.0;
    BOP.OFWH_1.port_a.m_flow+BOP.pump1.port_a.m_flow = 0.0;
    BOP.pump1.port_a.p = BOP.OFWH_1.port_a.p;
    BOP.OFWH_1.port_b.m_flow+BOP.moistureSeperator.port_Liquid.m_flow+
      BOP.pump.port_b.m_flow = 0.0;
    BOP.moistureSeperator.port_Liquid.p = BOP.OFWH_1.port_b.p;
    BOP.pump.port_b.p = BOP.OFWH_1.port_b.p;
    BOP.OFWH_2.port_b.m_flow+BOP.delay2.port_b.m_flow+BOP.pump1.port_b.m_flow = 
      0.0;
    BOP.delay2.port_b.p = BOP.OFWH_2.port_b.p;
    BOP.pump1.port_b.p = BOP.OFWH_2.port_b.p;
    BOP.TBV.port_b.m_flow+BOP.delay2_2.port_a.m_flow = 0.0;
    BOP.delay2_2.port_a.p = BOP.TBV.port_b.p;
    BOP.switch1.u2 = BOP.booleanStep1.y;
    BOP.port_a_cond.m_flow-BOP.condenser.port_b.m_flow-BOP.pump.port_a.m_flow = 
      0.0;
    BOP.port_a_cond.p = BOP.condenser.port_b.p;
    BOP.pump.port_a.p = BOP.condenser.port_b.p;
    BOP.prt_b_steamdump.m_flow-BOP.delay2_2.port_b.m_flow = 0.0;
    BOP.prt_b_steamdump.p = BOP.delay2_2.port_b.p;
    BOP.generator.port.W+BOP.sensorW.port_a.W = 0.0;
    BOP.sensorW.port_a.f = BOP.generator.port.f;
    BOP.port_a_elec.W-BOP.sensorW.port_b.W = 0.0;
    BOP.sensorW.port_b.f = BOP.port_a_elec.f;
    BOP.port_b_bypass.m_flow-BOP.sensor_m_flow.port_b.m_flow = 0.0;
    BOP.sensor_m_flow.port_b.p = BOP.port_b_bypass.p;
    BOP.switch1.u3 = BOP.realExpression.y;

  // Component bypassdump.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (bypassdump.medium.standardOrderComponents) then 
        bypassdump.medium.Xi = bypassdump.medium.X[1:0];
        bypassdump.medium.X = {1.0};
        for i in (1:1) loop
          assert(bypassdump.medium.X[i] >= -1E-05 and bypassdump.medium.X[i] <= 
            1.00001, "Mass fraction X["+       String(i, true, 0)+"] = "+
                   String(bypassdump.medium.X[i], true, 0)+"of substance "+({
            "water"})[i]+"\nof medium "+"WaterIF97"+" is not in the range 0..1");
        end for;
      end if;
      assert(bypassdump.medium.p >= 0.0, "Pressure (= "+       String(
        bypassdump.medium.p, true, 0)+" Pa) of medium \""+"WaterIF97"+
        "\" is negative\n(Temperature = "+       String(bypassdump.medium.T, 
        true, 0)+" K)");
    // end of extends 
  equation
    bypassdump.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    bypassdump.medium.phase = (if bypassdump.medium.h < Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique25
      (
      bypassdump.medium.sat) or bypassdump.medium.h > Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique28
      (
      bypassdump.medium.sat) or bypassdump.medium.p > _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .criticalPressure then 1 else 2);
    bypassdump.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique20(
      bypassdump.medium.p, bypassdump.medium.h, bypassdump.medium.phase, 0);
    bypassdump.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique21
      (bypassdump.medium.p, bypassdump.medium.h, bypassdump.medium.phase, 0);
    bypassdump.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique23
      (bypassdump.medium.p);
    bypassdump.medium.sat.psat = bypassdump.medium.p;
    bypassdump.medium.u = bypassdump.medium.h-bypassdump.medium.p/
      bypassdump.medium.d;
    bypassdump.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    bypassdump.medium.h = bypassdump.medium.state.h;
    bypassdump.medium.p = bypassdump.medium.state.p;
    bypassdump.medium.T = bypassdump.medium.state.T;
    bypassdump.medium.d = bypassdump.medium.state.d;
    bypassdump.medium.phase = bypassdump.medium.state.phase;

  // Component bypassdump
  // class TRANSFORM.Fluid.BoundaryConditions.Boundary_pT
    // extends TRANSFORM.Fluid.BoundaryConditions.BaseClasses.PartialSource
    equation
      for i in (1:bypassdump.nPorts) loop
        assert(cardinality(bypassdump.ports[i]) <= 1, "
each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
        bypassdump.ports[i].p = bypassdump.medium.p;
        bypassdump.ports[i].h_outflow = bypassdump.medium.h;
        bypassdump.ports[i].Xi_outflow = bypassdump.medium.Xi;
      end for;
    // end of extends 
  equation
    Modelica.Fluid.Utilities.checkBoundary("WaterIF97", {"water"}, false, true, 
      bypassdump.X_in_internal, "Boundary_pT");
    if ( not bypassdump.use_p_in) then 
      bypassdump.p_in_internal = bypassdump.p;
    end if;
    if ( not bypassdump.use_T_in) then 
      bypassdump.T_in_internal = bypassdump.T;
    end if;
    if ( not bypassdump.use_X_in) then 
      bypassdump.X_in_internal = bypassdump.X;
    end if;
    if ( not bypassdump.use_C_in) then 
      bypassdump.C_in_internal = bypassdump.C;
    end if;
    bypassdump.medium.p = bypassdump.p_in_internal;
    bypassdump.medium.h = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_Unique12
      (
      Modelica.Media.Water.WaterIF97_ph.setState_pTX_Unique13(bypassdump.p_in_internal,
         bypassdump.T_in_internal, bypassdump.X_in_internal, 0, 0));
    bypassdump.medium.Xi = bypassdump.X_in_internal[1:0];
    bypassdump.ports.C_outflow = fill(bypassdump.C_in_internal, bypassdump.nPorts);
    bypassdump.p_in_internal = bypassdump.p_in;

  // Component steamdump.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (steamdump.medium.standardOrderComponents) then 
        steamdump.medium.Xi = steamdump.medium.X[1:0];
        steamdump.medium.X = {1.0};
        for i in (1:1) loop
          assert(steamdump.medium.X[i] >= -1E-05 and steamdump.medium.X[i] <= 
            1.00001, "Mass fraction X["+       String(i, true, 0)+"] = "+
                   String(steamdump.medium.X[i], true, 0)+"of substance "+({
            "water"})[i]+"\nof medium "+"WaterIF97"+" is not in the range 0..1");
        end for;
      end if;
      assert(steamdump.medium.p >= 0.0, "Pressure (= "+       String(
        steamdump.medium.p, true, 0)+" Pa) of medium \""+"WaterIF97"+
        "\" is negative\n(Temperature = "+       String(steamdump.medium.T, true,
         0)+" K)");
    // end of extends 
  equation
    steamdump.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    steamdump.medium.phase = (if steamdump.medium.h < Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique25
      (
      steamdump.medium.sat) or steamdump.medium.h > Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique28
      (
      steamdump.medium.sat) or steamdump.medium.p > _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .criticalPressure then 1 else 2);
    steamdump.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique20(
      steamdump.medium.p, steamdump.medium.h, steamdump.medium.phase, 0);
    steamdump.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique21
      (steamdump.medium.p, steamdump.medium.h, steamdump.medium.phase, 0);
    steamdump.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique23
      (steamdump.medium.p);
    steamdump.medium.sat.psat = steamdump.medium.p;
    steamdump.medium.u = steamdump.medium.h-steamdump.medium.p/steamdump.medium.d;
    steamdump.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    steamdump.medium.h = steamdump.medium.state.h;
    steamdump.medium.p = steamdump.medium.state.p;
    steamdump.medium.T = steamdump.medium.state.T;
    steamdump.medium.d = steamdump.medium.state.d;
    steamdump.medium.phase = steamdump.medium.state.phase;

  // Component steamdump
  // class TRANSFORM.Fluid.BoundaryConditions.Boundary_pT
    // extends TRANSFORM.Fluid.BoundaryConditions.BaseClasses.PartialSource
    equation
      for i in (1:steamdump.nPorts) loop
        assert(cardinality(steamdump.ports[i]) <= 1, "
each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
        steamdump.ports[i].p = steamdump.medium.p;
        steamdump.ports[i].h_outflow = steamdump.medium.h;
        steamdump.ports[i].Xi_outflow = steamdump.medium.Xi;
      end for;
    // end of extends 
  equation
    Modelica.Fluid.Utilities.checkBoundary("WaterIF97", {"water"}, false, true, 
      steamdump.X_in_internal, "Boundary_pT");
    if ( not steamdump.use_p_in) then 
      steamdump.p_in_internal = steamdump.p;
    end if;
    if ( not steamdump.use_T_in) then 
      steamdump.T_in_internal = steamdump.T;
    end if;
    if ( not steamdump.use_X_in) then 
      steamdump.X_in_internal = steamdump.X;
    end if;
    if ( not steamdump.use_C_in) then 
      steamdump.C_in_internal = steamdump.C;
    end if;
    steamdump.medium.p = steamdump.p_in_internal;
    steamdump.medium.h = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_Unique12
      (
      Modelica.Media.Water.WaterIF97_ph.setState_pTX_Unique13(steamdump.p_in_internal,
         steamdump.T_in_internal, steamdump.X_in_internal, 0, 0));
    steamdump.medium.Xi = steamdump.X_in_internal[1:0];
    steamdump.ports.C_outflow = fill(steamdump.C_in_internal, steamdump.nPorts);

  // Component boundary
  // class TRANSFORM.Electrical.Sources.FrequencySource
  equation
    if ( not boundary.use_port) then 
      boundary.f_internal = boundary.f;
    end if;
    boundary.port.f = boundary.f_internal;

  // Component bypassdump1.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (bypassdump1.medium.standardOrderComponents) then 
        bypassdump1.medium.Xi = bypassdump1.medium.X[1:0];
        bypassdump1.medium.X = {1.0};
        for i in (1:1) loop
          assert(bypassdump1.medium.X[i] >= -1E-05 and bypassdump1.medium.X[i]
             <= 1.00001, "Mass fraction X["+       String(i, true, 0)+"] = "+
                   String(bypassdump1.medium.X[i], true, 0)+"of substance "+({
            "water"})[i]+"\nof medium "+"WaterIF97"+" is not in the range 0..1");
        end for;
      end if;
      assert(bypassdump1.medium.p >= 0.0, "Pressure (= "+       String(
        bypassdump1.medium.p, true, 0)+" Pa) of medium \""+"WaterIF97"+
        "\" is negative\n(Temperature = "+       String(bypassdump1.medium.T, 
        true, 0)+" K)");
    // end of extends 
  equation
    bypassdump1.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    bypassdump1.medium.phase = (if bypassdump1.medium.h < Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique25
      (
      bypassdump1.medium.sat) or bypassdump1.medium.h > Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique28
      (
      bypassdump1.medium.sat) or bypassdump1.medium.p > _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .criticalPressure then 1 else 2);
    bypassdump1.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique20
      (bypassdump1.medium.p, bypassdump1.medium.h, bypassdump1.medium.phase, 0);
    bypassdump1.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique21
      (bypassdump1.medium.p, bypassdump1.medium.h, bypassdump1.medium.phase, 0);
    bypassdump1.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique23
      (bypassdump1.medium.p);
    bypassdump1.medium.sat.psat = bypassdump1.medium.p;
    bypassdump1.medium.u = bypassdump1.medium.h-bypassdump1.medium.p/
      bypassdump1.medium.d;
    bypassdump1.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    bypassdump1.medium.h = bypassdump1.medium.state.h;
    bypassdump1.medium.p = bypassdump1.medium.state.p;
    bypassdump1.medium.T = bypassdump1.medium.state.T;
    bypassdump1.medium.d = bypassdump1.medium.state.d;
    bypassdump1.medium.phase = bypassdump1.medium.state.phase;

  // Component bypassdump1
  // class TRANSFORM.Fluid.BoundaryConditions.MassFlowSource_h
    // extends TRANSFORM.Fluid.BoundaryConditions.BaseClasses.PartialFlowSource
    equation
      assert(abs(sum(abs(bypassdump1.ports.m_flow))-max(abs(bypassdump1.ports.
        m_flow))) <= 1E-60, "FlowSource only supports one connection with flow");
      for i in (1:bypassdump1.nPorts) loop
        assert(cardinality(bypassdump1.ports[i]) <= 1, "
each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
        bypassdump1.ports[i].p = bypassdump1.medium.p;
        bypassdump1.ports[i].h_outflow = bypassdump1.medium.h;
        bypassdump1.ports[i].Xi_outflow = bypassdump1.medium.Xi;
      end for;
    // end of extends 
  equation
    Modelica.Fluid.Utilities.checkBoundary("WaterIF97", {"water"}, false, true, 
      bypassdump1.X_in_internal, "MassFlowSource_h");
    if ( not bypassdump1.use_m_flow_in) then 
      bypassdump1.m_flow_in_internal = bypassdump1.m_flow;
    end if;
    if ( not bypassdump1.use_h_in) then 
      bypassdump1.h_in_internal = bypassdump1.h;
    end if;
    if ( not bypassdump1.use_X_in) then 
      bypassdump1.X_in_internal = bypassdump1.X;
    end if;
    if ( not bypassdump1.use_C_in) then 
      bypassdump1.C_in_internal = bypassdump1.C;
    end if;
    bypassdump1.medium.h = bypassdump1.h_in_internal;
    sum(bypassdump1.ports.m_flow) =  -bypassdump1.m_flow_in_internal;
    bypassdump1.medium.Xi = bypassdump1.X_in_internal[1:0];
    bypassdump1.ports.C_outflow = fill(bypassdump1.C_in_internal, 
      bypassdump1.nPorts);
    bypassdump1.m_flow_in_internal = bypassdump1.m_flow_in;

  // Component sensor_m_flow
  // class TRANSFORM.Fluid.Sensors.MassFlowRate
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialTwoPortSensor
    equation
      0 = sensor_m_flow.port_a.m_flow+sensor_m_flow.port_b.m_flow;
      sensor_m_flow.port_a.p = sensor_m_flow.port_b.p;
      sensor_m_flow.port_a.h_outflow = inStream(sensor_m_flow.port_b.h_outflow);
      sensor_m_flow.port_b.h_outflow = inStream(sensor_m_flow.port_a.h_outflow);
      sensor_m_flow.port_a.Xi_outflow = inStream(sensor_m_flow.port_b.Xi_outflow);
      sensor_m_flow.port_b.Xi_outflow = inStream(sensor_m_flow.port_a.Xi_outflow);
      sensor_m_flow.port_a.C_outflow = inStream(sensor_m_flow.port_b.C_outflow);
      sensor_m_flow.port_b.C_outflow = inStream(sensor_m_flow.port_a.C_outflow);
    // end of extends 
  equation
    sensor_m_flow.m_flow = sensor_m_flow.port_a.m_flow;

  // Component integrator
  // class Modelica.Blocks.Continuous.Integrator
  equation
    integrator.local_reset = false;
    integrator.local_set = 0;
    der(integrator.y) = integrator.k*integrator.u;

  // Component sensorW
  // class NHES.Electrical.PowerSensor
  equation
    sensorW.port_a.W+sensorW.port_b.W = 0;
    sensorW.port_a.f = sensorW.port_b.f;
    sensorW.W = sensorW.port_a.W;

  // Component volume.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (volume.medium.standardOrderComponents) then 
        volume.medium.Xi = volume.medium.X[1:0];
        volume.medium.X = {1.0};
        for i in (1:1) loop
          assert(volume.medium.X[i] >= -1E-05 and volume.medium.X[i] <= 1.00001,
             "Mass fraction X["+       String(i, true, 0)+"] = "+       String(
            volume.medium.X[i], true, 0)+"of substance "+({"water"})[i]+
            "\nof medium "+"WaterIF97"+" is not in the range 0..1");
        end for;
      end if;
      assert(volume.medium.p >= 0.0, "Pressure (= "+       String(
        volume.medium.p, true, 0)+" Pa) of medium \""+"WaterIF97"+
        "\" is negative\n(Temperature = "+       String(volume.medium.T, true, 0)
        +" K)");
    // end of extends 
  equation
    volume.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    volume.medium.phase = (if volume.medium.h < Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique25
      (
      volume.medium.sat) or volume.medium.h > Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique28
      (
      volume.medium.sat) or volume.medium.p > _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .criticalPressure then 1 else 2);
    volume.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique20(
      volume.medium.p, volume.medium.h, volume.medium.phase, 0);
    volume.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique21(
      volume.medium.p, volume.medium.h, volume.medium.phase, 0);
    volume.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique23
      (volume.medium.p);
    volume.medium.sat.psat = volume.medium.p;
    volume.medium.u = volume.medium.h-volume.medium.p/volume.medium.d;
    volume.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    volume.medium.h = volume.medium.state.h;
    volume.medium.p = volume.medium.state.p;
    volume.medium.T = volume.medium.state.T;
    volume.medium.d = volume.medium.state.d;
    volume.medium.phase = volume.medium.state.phase;

  // Component volume
  // class TRANSFORM.Fluid.Volumes.SimpleVolume
    // extends TRANSFORM.Fluid.Volumes.BaseClasses.PartialVolume
    equation
      assert( not (volume.energyDynamics <> Modelica.Fluid.Types.Dynamics.
        SteadyState and volume.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyState) or false, "If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState' or Medium not conserving mass if volume is fixed.");
      volume.m = volume.V*volume.medium.d;
      volume.U = volume.m*volume.medium.u;
      volume.mXi = volume.m*volume.medium.Xi;
      volume.mC = volume.m*volume.C;
      if (volume.massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        0 = volume.mb;
      else
        der(volume.m) = volume.mb;
      end if;
      if (volume.energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        0 = volume.Ub;
      else
        der(volume.U) = volume.Ub;
      end if;
      if (volume.substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        zeros(0) = volume.mXib;
      else
        der(volume.mXi) = volume.mXib;
      end if;
      if (volume.traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
         then 
        zeros(0) = volume.mCb;
      else
        der(volume.mC_scaled) = volume.mCb./{};
        volume.mC = volume.mC_scaled.*{};
      end if;
    // end of extends 
  equation
    if ( not volume.use_HeatPort) then 
      volume.Q_flow_internal = 0;
    end if;
    if ( not volume.use_TraceMassPort) then 
      volume.mC_flow_internal = zeros(0);
    end if;
    volume.port_a.p = volume.medium.p+volume.medium.d*volume.g_n*0.5*
      volume.geometry.dheight;
    volume.port_b.p = volume.medium.p-volume.medium.d*volume.g_n*0.5*
      volume.geometry.dheight;
    volume.port_a.h_outflow = volume.medium.h;
    volume.port_b.h_outflow = volume.medium.h;
    volume.port_a.Xi_outflow = volume.medium.Xi;
    volume.port_b.Xi_outflow = volume.medium.Xi;
    volume.port_a.C_outflow = volume.C;
    volume.port_b.C_outflow = volume.C;

  // Component resistance
  // class TRANSFORM.Fluid.FittingsAndResistances.PressureLoss
    // extends TRANSFORM.Fluid.FittingsAndResistances.BaseClasses.PartialResistance
    equation
      resistance.port_a.m_flow+resistance.port_b.m_flow = 0;
      resistance.dp = resistance.port_a.p-resistance.port_b.p;
      resistance.m_flow = resistance.port_a.m_flow;
      resistance.state = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19
        (resistance.port_a.p, inStream(resistance.port_a.h_outflow), inStream(
        resistance.port_a.Xi_outflow), 0, 0);
      resistance.port_a.h_outflow = inStream(resistance.port_b.h_outflow);
      resistance.port_b.h_outflow = inStream(resistance.port_a.h_outflow);
      resistance.port_a.Xi_outflow = inStream(resistance.port_b.Xi_outflow);
      resistance.port_b.Xi_outflow = inStream(resistance.port_a.Xi_outflow);
      resistance.port_a.C_outflow = inStream(resistance.port_b.C_outflow);
      resistance.port_b.C_outflow = inStream(resistance.port_a.C_outflow);
    // end of extends 
  equation
    resistance.dp = resistance.dp0;

  // Component boundary1
  // class TRANSFORM.HeatAndMassTransfer.BoundaryConditions.Heat.HeatFlow
  equation
    if ( not boundary1.use_port) then 
      boundary1.Q_flow_int = boundary1.Q_flow;
    end if;
    boundary1.port.Q_flow =  -boundary1.Q_flow_int;

  // Component flowCV.valveLinear
  // class TRANSFORM.Fluid.Valves.ValveLinear
    // extends TRANSFORM.Fluid.Valves.BaseClasses.PartialTwoPortTransport
    equation
      flowCV.valveLinear.state_a = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19
        (flowCV.valveLinear.port_a.p, inStream(flowCV.valveLinear.port_a.h_outflow),
         inStream(flowCV.valveLinear.port_a.Xi_outflow), 0, 0);
      flowCV.valveLinear.state_b = Modelica.Media.Water.WaterIF97_ph.setState_phX_Unique19
        (flowCV.valveLinear.port_b.p, inStream(flowCV.valveLinear.port_b.h_outflow),
         inStream(flowCV.valveLinear.port_b.Xi_outflow), 0, 0);
      flowCV.valveLinear.dp = flowCV.valveLinear.port_a.p-flowCV.valveLinear.port_b.p;
      flowCV.valveLinear.m_flow = flowCV.valveLinear.port_a.m_flow;
      assert(flowCV.valveLinear.m_flow >  -flowCV.valveLinear.m_flow_small or 
        flowCV.valveLinear.allowFlowReversal, "Reverting flow occurs even though allowFlowReversal is false");
      flowCV.valveLinear.port_a.m_flow+flowCV.valveLinear.port_b.m_flow = 0;
      flowCV.valveLinear.port_a.Xi_outflow = inStream(flowCV.valveLinear.port_b.Xi_outflow);
      flowCV.valveLinear.port_b.Xi_outflow = inStream(flowCV.valveLinear.port_a.Xi_outflow);
      flowCV.valveLinear.port_a.C_outflow = inStream(flowCV.valveLinear.port_b.C_outflow);
      flowCV.valveLinear.port_b.C_outflow = inStream(flowCV.valveLinear.port_a.C_outflow);
    // end of extends 
  equation
    flowCV.valveLinear.m_flow = flowCV.valveLinear.opening*flowCV.valveLinear.k*
      flowCV.valveLinear.dp;
    flowCV.valveLinear.port_a.h_outflow = inStream(flowCV.valveLinear.port_b.h_outflow);
    flowCV.valveLinear.port_b.h_outflow = inStream(flowCV.valveLinear.port_a.h_outflow);

  // Component flowCV.sensor_m_flow
  // class TRANSFORM.Fluid.Sensors.MassFlowRate
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialTwoPortSensor
    equation
      0 = flowCV.sensor_m_flow.port_a.m_flow+flowCV.sensor_m_flow.port_b.m_flow;
      flowCV.sensor_m_flow.port_a.p = flowCV.sensor_m_flow.port_b.p;
      flowCV.sensor_m_flow.port_a.h_outflow = inStream(flowCV.sensor_m_flow.port_b.h_outflow);
      flowCV.sensor_m_flow.port_b.h_outflow = inStream(flowCV.sensor_m_flow.port_a.h_outflow);
      flowCV.sensor_m_flow.port_a.Xi_outflow = inStream(flowCV.sensor_m_flow.port_b.Xi_outflow);
      flowCV.sensor_m_flow.port_b.Xi_outflow = inStream(flowCV.sensor_m_flow.port_a.Xi_outflow);
      flowCV.sensor_m_flow.port_a.C_outflow = inStream(flowCV.sensor_m_flow.port_b.C_outflow);
      flowCV.sensor_m_flow.port_b.C_outflow = inStream(flowCV.sensor_m_flow.port_a.C_outflow);
    // end of extends 
  equation
    flowCV.sensor_m_flow.m_flow = flowCV.sensor_m_flow.port_a.m_flow;

  // Component flowCV.PID.addP
  // class Modelica.Blocks.Math.Add
  equation
    flowCV.PID.addP.y = flowCV.PID.addP.k1*flowCV.PID.addP.u1+flowCV.PID.addP.k2
      *flowCV.PID.addP.u2;

  // Component flowCV.PID.P
  // class Modelica.Blocks.Math.Gain
  equation
    flowCV.PID.P.y = flowCV.PID.P.k*flowCV.PID.P.u;

  // Component flowCV.PID.gainPID
  // class Modelica.Blocks.Math.Gain
  equation
    flowCV.PID.gainPID.y = flowCV.PID.gainPID.k*flowCV.PID.gainPID.u;

  // Component flowCV.PID.addPID
  // class Modelica.Blocks.Math.Add3
  equation
    flowCV.PID.addPID.y = flowCV.PID.addPID.k1*flowCV.PID.addPID.u1+
      flowCV.PID.addPID.k2*flowCV.PID.addPID.u2+flowCV.PID.addPID.k3*
      flowCV.PID.addPID.u3;

  // Component flowCV.PID.limiter
  // class Modelica.Blocks.Nonlinear.Limiter
  equation
    assert(flowCV.PID.limiter.uMax >= flowCV.PID.limiter.uMin, "Limiter: Limits must be consistent. However, uMax (="
      +       String(flowCV.PID.limiter.uMax, true, 0)+") < uMin (="+
             String(flowCV.PID.limiter.uMin, true, 0)+")");
    flowCV.PID.limiter.simplifiedExpr = (if flowCV.PID.limiter.homotopyType == 
      Modelica.Blocks.Types.LimiterHomotopy.Linear then flowCV.PID.limiter.u
       else (if flowCV.PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
      UpperLimit then flowCV.PID.limiter.uMax else (if flowCV.PID.limiter.homotopyType
       == Modelica.Blocks.Types.LimiterHomotopy.LowerLimit then flowCV.PID.limiter.uMin
       else 0)));
    if (flowCV.PID.limiter.strict) then 
      if (flowCV.PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        flowCV.PID.limiter.y = smooth(0, noEvent((if flowCV.PID.limiter.u > 
          flowCV.PID.limiter.uMax then flowCV.PID.limiter.uMax else (if 
          flowCV.PID.limiter.u < flowCV.PID.limiter.uMin then flowCV.PID.limiter.uMin
           else flowCV.PID.limiter.u))));
      else
        flowCV.PID.limiter.y = homotopy(smooth(0, noEvent((if flowCV.PID.limiter.u
           > flowCV.PID.limiter.uMax then flowCV.PID.limiter.uMax else (if 
          flowCV.PID.limiter.u < flowCV.PID.limiter.uMin then flowCV.PID.limiter.uMin
           else flowCV.PID.limiter.u)))), flowCV.PID.limiter.simplifiedExpr);
      end if;
    else
      if (flowCV.PID.limiter.homotopyType == Modelica.Blocks.Types.LimiterHomotopy.
        NoHomotopy) then 
        flowCV.PID.limiter.y = smooth(0, (if flowCV.PID.limiter.u > 
          flowCV.PID.limiter.uMax then flowCV.PID.limiter.uMax else (if 
          flowCV.PID.limiter.u < flowCV.PID.limiter.uMin then flowCV.PID.limiter.uMin
           else flowCV.PID.limiter.u)));
      else
        flowCV.PID.limiter.y = homotopy(smooth(0, (if flowCV.PID.limiter.u > 
          flowCV.PID.limiter.uMax then flowCV.PID.limiter.uMax else (if 
          flowCV.PID.limiter.u < flowCV.PID.limiter.uMin then flowCV.PID.limiter.uMin
           else flowCV.PID.limiter.u))), flowCV.PID.limiter.simplifiedExpr);
      end if;
    end if;

  // Component flowCV.PID.Fzero
  // class Modelica.Blocks.Sources.Constant
  equation
    flowCV.PID.Fzero.y = flowCV.PID.Fzero.k;

  // Component flowCV.PID.addFF
  // class Modelica.Blocks.Math.Add3
  equation
    flowCV.PID.addFF.y = flowCV.PID.addFF.k1*flowCV.PID.addFF.u1+
      flowCV.PID.addFF.k2*flowCV.PID.addFF.u2+flowCV.PID.addFF.k3*
      flowCV.PID.addFF.u3;

  // Component flowCV.PID.gain_u_s
  // class Modelica.Blocks.Math.Gain
  equation
    flowCV.PID.gain_u_s.y = flowCV.PID.gain_u_s.k*flowCV.PID.gain_u_s.u;

  // Component flowCV.PID.gain_u_m
  // class Modelica.Blocks.Math.Gain
  equation
    flowCV.PID.gain_u_m.y = flowCV.PID.gain_u_m.k*flowCV.PID.gain_u_m.u;

  // Component flowCV.PID.null_bias
  // class Modelica.Blocks.Sources.Constant
  equation
    flowCV.PID.null_bias.y = flowCV.PID.null_bias.k;

  // Component flowCV.PID.delay_boolean
  // class Modelica.Blocks.Sources.BooleanStep
  equation
    flowCV.PID.delay_boolean.y = (if time >= flowCV.PID.delay_boolean.startTime
       then  not flowCV.PID.delay_boolean.startValue else flowCV.PID.delay_boolean.startValue);

  // Component flowCV.PID.input_switch
  // class Modelica.Blocks.Logical.Switch
  equation
    flowCV.PID.input_switch.y = (if flowCV.PID.input_switch.u2 then 
      flowCV.PID.input_switch.u1 else flowCV.PID.input_switch.u3);

  // Component flowCV.PID.output_switch
  // class Modelica.Blocks.Logical.Switch
  equation
    flowCV.PID.output_switch.y = (if flowCV.PID.output_switch.u2 then 
      flowCV.PID.output_switch.u1 else flowCV.PID.output_switch.u3);

  // Component flowCV.PID.add_offset
  // class Modelica.Blocks.Math.Add
  equation
    flowCV.PID.add_offset.y = flowCV.PID.add_offset.k1*flowCV.PID.add_offset.u1+
      flowCV.PID.add_offset.k2*flowCV.PID.add_offset.u2;

  // Component flowCV.PID.I
  // class TRANSFORM.Blocks.IntegratorWithReset
  equation
    der(flowCV.PID.I.y) = flowCV.PID.I.k*flowCV.PID.I.u;
    if (flowCV.PID.I.reset <> TRANSFORM.Types.Reset.Input) then 
      flowCV.PID.I.y_reset_internal = flowCV.PID.I.y_reset;
    end if;
    if (flowCV.PID.I.reset == TRANSFORM.Types.Reset.Disabled) then 
      flowCV.PID.I.trigger_internal = false;
    else
      when flowCV.PID.I.trigger_internal then
        reinit(flowCV.PID.I.y, flowCV.PID.I.y_reset_internal);
      end when;
    end if;

  // Component flowCV.PID.addI
  // class Modelica.Blocks.Math.Add3
  equation
    flowCV.PID.addI.y = flowCV.PID.addI.k1*flowCV.PID.addI.u1+flowCV.PID.addI.k2
      *flowCV.PID.addI.u2+flowCV.PID.addI.k3*flowCV.PID.addI.u3;

  // Component flowCV.PID.addSat
  // class Modelica.Blocks.Math.Add
  equation
    flowCV.PID.addSat.y = flowCV.PID.addSat.k1*flowCV.PID.addSat.u1+
      flowCV.PID.addSat.k2*flowCV.PID.addSat.u2;

  // Component flowCV.PID.gainTrack
  // class Modelica.Blocks.Math.Gain
  equation
    flowCV.PID.gainTrack.y = flowCV.PID.gainTrack.k*flowCV.PID.gainTrack.u;

  // Component flowCV.PID.Dzero
  // class Modelica.Blocks.Sources.Constant
  equation
    flowCV.PID.Dzero.y = flowCV.PID.Dzero.k;

  // Component flowCV.PID
  // class NHES.Controls.LimOffsetPID
  equation
    assert(flowCV.PID.yMax >= flowCV.PID.yMin, "LimPID: Limits must be consistent. However, yMax (="
      +       String(flowCV.PID.yMax, true, 0)+") < yMin (="+       String(
      flowCV.PID.yMin, true, 0)+")");
    if (flowCV.PID.initType == Modelica.Blocks.Types.Init.InitialOutput and (
      flowCV.PID.y_start < flowCV.PID.yMin or flowCV.PID.y_start > 
      flowCV.PID.yMax)) then 
      ModelicaError("LimPID: Start value y_start (="+       String(
        flowCV.PID.y_start, true, 0)+") is outside of the limits of yMin (="+
               String(flowCV.PID.yMin, true, 0)+") and yMax (="+       String(
        flowCV.PID.yMax, true, 0)+")");
    end if;
    if (flowCV.PID.reset <> TRANSFORM.Types.Reset.Input) then 
      flowCV.PID.y_reset_internal = flowCV.PID.y_reset;
    end if;
    flowCV.PID.addPID.u2 = flowCV.PID.Dzero.y;
    flowCV.PID.addFF.u1 = flowCV.PID.Fzero.y;
    flowCV.PID.addI.y = flowCV.PID.I.u;
    flowCV.PID.addPID.u3 = flowCV.PID.I.y;
    flowCV.PID.addP.y = flowCV.PID.P.u;
    flowCV.PID.addPID.u1 = flowCV.PID.P.y;
    flowCV.PID.gainPID.y = flowCV.PID.addFF.u2;
    flowCV.PID.null_bias.y = flowCV.PID.addFF.u3;
    flowCV.PID.addSat.u2 = flowCV.PID.addFF.y;
    flowCV.PID.limiter.u = flowCV.PID.addFF.y;
    flowCV.PID.addP.u1 = flowCV.PID.addI.u1;
    flowCV.PID.gain_u_s.y = flowCV.PID.addI.u1;
    flowCV.PID.input_switch.u3 = flowCV.PID.addI.u1;
    flowCV.PID.addP.u2 = flowCV.PID.addI.u2;
    flowCV.PID.input_switch.y = flowCV.PID.addI.u2;
    flowCV.PID.gainTrack.y = flowCV.PID.addI.u3;
    flowCV.PID.gainPID.u = flowCV.PID.addPID.y;
    flowCV.PID.add_offset.u1 = flowCV.PID.addSat.u1;
    flowCV.PID.limiter.y = flowCV.PID.addSat.u1;
    flowCV.PID.gainTrack.u = flowCV.PID.addSat.y;
    flowCV.PID.offset_set.y = flowCV.PID.add_offset.u2;
    flowCV.PID.output_switch.u1 = flowCV.PID.add_offset.y;
    flowCV.PID.input_switch.u2 = flowCV.PID.delay_boolean.y;
    flowCV.PID.output_switch.u2 = flowCV.PID.delay_boolean.y;
    flowCV.PID.u_m = flowCV.PID.gain_u_m.u;
    flowCV.PID.input_switch.u1 = flowCV.PID.gain_u_m.y;
    flowCV.PID.u_s = flowCV.PID.gain_u_s.u;
    flowCV.PID.output_switch.u3 = flowCV.PID.init.y;
    flowCV.PID.y = flowCV.PID.output_switch.y;

  // Component flowCV.inputSwitch
  // class Modelica.Blocks.Logical.Switch
  equation
    flowCV.inputSwitch.y = (if flowCV.inputSwitch.u2 then flowCV.inputSwitch.u1
       else flowCV.inputSwitch.u3);

  // Component flowCV.booleanConstant
  // class Modelica.Blocks.Sources.BooleanConstant
  equation
    flowCV.booleanConstant.y = flowCV.booleanConstant.k;

  // Component flowCV
  // class NHES.Fluid.Valves.FlowCV
  equation
    flowCV.sensor_m_flow.m_flow = flowCV.PID.u_m;
    flowCV.inputSwitch.y = flowCV.PID.u_s;
    flowCV.valveLinear.opening = flowCV.PID.y;
    flowCV.inputSwitch.u2 = flowCV.booleanConstant.y;
    flowCV.inputSwitch.u3 = flowCV.flowRate_nom.y;
    flowCV.zero.y = flowCV.inputSwitch.u1;
    flowCV.port_a.m_flow-flowCV.valveLinear.port_a.m_flow = 0.0;
    flowCV.valveLinear.port_a.p = flowCV.port_a.p;
    flowCV.port_b.m_flow-flowCV.sensor_m_flow.port_b.m_flow = 0.0;
    flowCV.sensor_m_flow.port_b.p = flowCV.port_b.p;
    flowCV.sensor_m_flow.port_a.m_flow+flowCV.valveLinear.port_b.m_flow = 0.0;
    flowCV.valveLinear.port_b.p = flowCV.sensor_m_flow.port_a.p;

  // Component bypassdump2.medium
  // class Modelica.Media.Water.WaterIF97_base.BaseProperties
    // extends Modelica.Media.Interfaces.PartialMedium.BaseProperties_D1
    equation
      if (bypassdump2.medium.standardOrderComponents) then 
        bypassdump2.medium.Xi = bypassdump2.medium.X[1:0];
        bypassdump2.medium.X = {1.0};
        for i in (1:1) loop
          assert(bypassdump2.medium.X[i] >= -1E-05 and bypassdump2.medium.X[i]
             <= 1.00001, "Mass fraction X["+       String(i, true, 0)+"] = "+
                   String(bypassdump2.medium.X[i], true, 0)+"of substance "+({
            "water"})[i]+"\nof medium "+"WaterIF97"+" is not in the range 0..1");
        end for;
      end if;
      assert(bypassdump2.medium.p >= 0.0, "Pressure (= "+       String(
        bypassdump2.medium.p, true, 0)+" Pa) of medium \""+"WaterIF97"+
        "\" is negative\n(Temperature = "+       String(bypassdump2.medium.T, 
        true, 0)+" K)");
    // end of extends 
  equation
    bypassdump2.medium.MM = _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    bypassdump2.medium.phase = (if bypassdump2.medium.h < Modelica.Media.Water.WaterIF97_ph.bubbleEnthalpy_Unique25
      (
      bypassdump2.medium.sat) or bypassdump2.medium.h > Modelica.Media.Water.WaterIF97_ph.dewEnthalpy_Unique28
      (
      bypassdump2.medium.sat) or bypassdump2.medium.p > _GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .criticalPressure then 1 else 2);
    bypassdump2.medium.d = Modelica.Media.Water.WaterIF97_ph.density_ph_Unique20
      (bypassdump2.medium.p, bypassdump2.medium.h, bypassdump2.medium.phase, 0);
    bypassdump2.medium.T = Modelica.Media.Water.WaterIF97_ph.temperature_ph_Unique21
      (bypassdump2.medium.p, bypassdump2.medium.h, bypassdump2.medium.phase, 0);
    bypassdump2.medium.sat.Tsat = Modelica.Media.Water.WaterIF97_ph.saturationTemperature_Unique23
      (bypassdump2.medium.p);
    bypassdump2.medium.sat.psat = bypassdump2.medium.p;
    bypassdump2.medium.u = bypassdump2.medium.h-bypassdump2.medium.p/
      bypassdump2.medium.d;
    bypassdump2.medium.R_s = 8.31446261815324/_GlobalScope.Modelica.Media.Water.WaterIF97_ph.fluidConstants[1]
      .molarMass;
    bypassdump2.medium.h = bypassdump2.medium.state.h;
    bypassdump2.medium.p = bypassdump2.medium.state.p;
    bypassdump2.medium.T = bypassdump2.medium.state.T;
    bypassdump2.medium.d = bypassdump2.medium.state.d;
    bypassdump2.medium.phase = bypassdump2.medium.state.phase;

  // Component bypassdump2
  // class TRANSFORM.Fluid.BoundaryConditions.Boundary_pT
    // extends TRANSFORM.Fluid.BoundaryConditions.BaseClasses.PartialSource
    equation
      for i in (1:bypassdump2.nPorts) loop
        assert(cardinality(bypassdump2.ports[i]) <= 1, "
each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place with these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");
        bypassdump2.ports[i].p = bypassdump2.medium.p;
        bypassdump2.ports[i].h_outflow = bypassdump2.medium.h;
        bypassdump2.ports[i].Xi_outflow = bypassdump2.medium.Xi;
      end for;
    // end of extends 
  equation
    Modelica.Fluid.Utilities.checkBoundary("WaterIF97", {"water"}, false, true, 
      bypassdump2.X_in_internal, "Boundary_pT");
    if ( not bypassdump2.use_p_in) then 
      bypassdump2.p_in_internal = bypassdump2.p;
    end if;
    if ( not bypassdump2.use_T_in) then 
      bypassdump2.T_in_internal = bypassdump2.T;
    end if;
    if ( not bypassdump2.use_X_in) then 
      bypassdump2.X_in_internal = bypassdump2.X;
    end if;
    if ( not bypassdump2.use_C_in) then 
      bypassdump2.C_in_internal = bypassdump2.C;
    end if;
    bypassdump2.medium.p = bypassdump2.p_in_internal;
    bypassdump2.medium.h = Modelica.Media.Water.WaterIF97_ph.specificEnthalpy_Unique12
      (
      Modelica.Media.Water.WaterIF97_ph.setState_pTX_Unique13(bypassdump2.p_in_internal,
         bypassdump2.T_in_internal, bypassdump2.X_in_internal, 0, 0));
    bypassdump2.medium.Xi = bypassdump2.X_in_internal[1:0];
    bypassdump2.ports.C_outflow = fill(bypassdump2.C_in_internal, 
      bypassdump2.nPorts);
    bypassdump2.p_in_internal = bypassdump2.p_in;

  // Component sensor_m_flow1
  // class TRANSFORM.Fluid.Sensors.MassFlowRate
    // extends TRANSFORM.Fluid.Sensors.BaseClasses.PartialTwoPortSensor
    equation
      0 = sensor_m_flow1.port_a.m_flow+sensor_m_flow1.port_b.m_flow;
      sensor_m_flow1.port_a.p = sensor_m_flow1.port_b.p;
      sensor_m_flow1.port_a.h_outflow = inStream(sensor_m_flow1.port_b.h_outflow);
      sensor_m_flow1.port_b.h_outflow = inStream(sensor_m_flow1.port_a.h_outflow);
      sensor_m_flow1.port_a.Xi_outflow = inStream(sensor_m_flow1.port_b.Xi_outflow);
      sensor_m_flow1.port_b.Xi_outflow = inStream(sensor_m_flow1.port_a.Xi_outflow);
      sensor_m_flow1.port_a.C_outflow = inStream(sensor_m_flow1.port_b.C_outflow);
      sensor_m_flow1.port_b.C_outflow = inStream(sensor_m_flow1.port_a.C_outflow);
    // end of extends 
  equation
    sensor_m_flow1.m_flow = sensor_m_flow1.port_a.m_flow;

  // This model
  // class NHES.Systems.BalanceOfPlant.RankineCycle.Examples.NSSS_Test_b_SEC3_RealExpression_MoveFWHExtraction
  equation
    breaker = 1/Boo;
    assert(P_ext > bypassdump.medium.p_bar, "Extraction Pressure is below usage pressure");
    Q_util = sensor_m_flow.m_flow*(BOP.LPT1_bypass_valve.port_b.h_outflow-
      bypassdump1.h);
    BOP.port_a_cond.m_flow+bypassdump1.ports[1].m_flow = 0.0;
    bypassdump1.ports[1].p = BOP.port_a_cond.p;
    BOP.port_a_elec.W+sensorW.port_a.W = 0.0;
    sensorW.port_a.f = BOP.port_a_elec.f;
    BOP.port_a_steam.m_flow+flowCV.port_a.m_flow+stateSensor1.port_b.m_flow = 
      0.0;
    flowCV.port_a.p = BOP.port_a_steam.p;
    stateSensor1.port_b.p = BOP.port_a_steam.p;
    BOP.port_b_bypass.m_flow+sensor_m_flow.port_a.m_flow = 0.0;
    sensor_m_flow.port_a.p = BOP.port_b_bypass.p;
    BOP.port_b_feed.m_flow+stateSensor2.port_a.m_flow = 0.0;
    stateSensor2.port_a.p = BOP.port_b_feed.p;
    BOP.prt_b_steamdump.m_flow+steamdump.ports[1].m_flow = 0.0;
    steamdump.ports[1].p = BOP.prt_b_steamdump.p;
    boundary.port.W+sensorW.port_b.W = 0.0;
    sensorW.port_b.f = boundary.port.f;
    boundary1.port.Q_flow+volume.heatPort.Q_flow = 0.0;
    volume.heatPort.T = boundary1.port.T;
    realExpression.y = bypassdump.p_in;
    bypassdump.ports[1].m_flow+sensor_m_flow.port_b.m_flow = 0.0;
    sensor_m_flow.port_b.p = bypassdump.ports[1].p;
    sensor_m_flow1.m_flow = bypassdump1.m_flow_in;
    realExpression1.y = bypassdump2.p_in;
    bypassdump2.ports[1].m_flow+sensor_m_flow1.port_b.m_flow = 0.0;
    sensor_m_flow1.port_b.p = bypassdump2.ports[1].p;
    flowCV.port_b.m_flow+sensor_m_flow1.port_a.m_flow = 0.0;
    sensor_m_flow1.port_a.p = flowCV.port_b.p;
    sensorW.W = integrator.u;
    resistance.port_a.m_flow+stateSensor2.port_b.m_flow = 0.0;
    stateSensor2.port_b.p = resistance.port_a.p;
    resistance.port_b.m_flow+volume.port_a.m_flow = 0.0;
    volume.port_a.p = resistance.port_b.p;
    stateSensor2.statePort.T = stateDisplay1.statePort.T;
    stateSensor2.statePort.h_out = stateDisplay1.statePort.h_out;
    stateSensor2.statePort.m_flow = stateDisplay1.statePort.m_flow;
    stateSensor2.statePort.p = stateDisplay1.statePort.p;
    stateSensor1.statePort.T = stateDisplay2.statePort.T;
    stateSensor1.statePort.h_out = stateDisplay2.statePort.h_out;
    stateSensor1.statePort.m_flow = stateDisplay2.statePort.m_flow;
    stateSensor1.statePort.p = stateDisplay2.statePort.p;
    stateSensor1.port_a.m_flow+volume.port_b.m_flow = 0.0;
    volume.port_b.p = stateSensor1.port_a.p;
            
// Initial equations and algorithms

  // Component BOP.CS.FeedPump_PID.I
  // class TRANSFORM.Blocks.IntegratorWithReset
  initial equation
    if (BOP.CS.FeedPump_PID.I.initType == Modelica.Blocks.Types.Init.SteadyState)
       then 
      der(BOP.CS.FeedPump_PID.I.y) = 0;
    elseif (BOP.CS.FeedPump_PID.I.initType == Modelica.Blocks.Types.Init.
      InitialState or BOP.CS.FeedPump_PID.I.initType == Modelica.Blocks.Types.Init.
      InitialOutput) then 
      BOP.CS.FeedPump_PID.I.y = BOP.CS.FeedPump_PID.I.y_start;
    end if;

  // Component BOP.CS.FeedPump_PID
  // class TRANSFORM.Controls.LimPID
  initial equation
    if (BOP.CS.FeedPump_PID.initType == Modelica.Blocks.Types.Init.InitialOutput)
       then 
      BOP.CS.FeedPump_PID.y = BOP.CS.FeedPump_PID.y_start;
    end if;

  // Component BOP.CS.TCV_PID.I
  // class TRANSFORM.Blocks.IntegratorWithReset
  initial equation
    if (BOP.CS.TCV_PID.I.initType == Modelica.Blocks.Types.Init.SteadyState)
       then 
      der(BOP.CS.TCV_PID.I.y) = 0;
    elseif (BOP.CS.TCV_PID.I.initType == Modelica.Blocks.Types.Init.InitialState
       or BOP.CS.TCV_PID.I.initType == Modelica.Blocks.Types.Init.InitialOutput)
       then 
      BOP.CS.TCV_PID.I.y = BOP.CS.TCV_PID.I.y_start;
    end if;

  // Component BOP.CS.TCV_PID
  // class TRANSFORM.Controls.LimPID
  initial equation
    if (BOP.CS.TCV_PID.initType == Modelica.Blocks.Types.Init.InitialOutput)
       then 
      BOP.CS.TCV_PID.y = BOP.CS.TCV_PID.y_start;
    end if;

  // Component BOP.CS.LPT1_BV_PID.I
  // class TRANSFORM.Blocks.IntegratorWithReset
  initial equation
    if (BOP.CS.LPT1_BV_PID.I.initType == Modelica.Blocks.Types.Init.SteadyState)
       then 
      der(BOP.CS.LPT1_BV_PID.I.y) = 0;
    elseif (BOP.CS.LPT1_BV_PID.I.initType == Modelica.Blocks.Types.Init.
      InitialState or BOP.CS.LPT1_BV_PID.I.initType == Modelica.Blocks.Types.Init.
      InitialOutput) then 
      BOP.CS.LPT1_BV_PID.I.y = BOP.CS.LPT1_BV_PID.I.y_start;
    end if;

  // Component BOP.CS.LPT1_BV_PID
  // class TRANSFORM.Controls.LimPID
  initial equation
    if (BOP.CS.LPT1_BV_PID.initType == Modelica.Blocks.Types.Init.InitialOutput)
       then 
      BOP.CS.LPT1_BV_PID.y = BOP.CS.LPT1_BV_PID.y_start;
    end if;

  // Component BOP.CS.LPT2_BV_PID.I
  // class TRANSFORM.Blocks.IntegratorWithReset
  initial equation
    if (BOP.CS.LPT2_BV_PID.I.initType == Modelica.Blocks.Types.Init.SteadyState)
       then 
      der(BOP.CS.LPT2_BV_PID.I.y) = 0;
    elseif (BOP.CS.LPT2_BV_PID.I.initType == Modelica.Blocks.Types.Init.
      InitialState or BOP.CS.LPT2_BV_PID.I.initType == Modelica.Blocks.Types.Init.
      InitialOutput) then 
      BOP.CS.LPT2_BV_PID.I.y = BOP.CS.LPT2_BV_PID.I.y_start;
    end if;

  // Component BOP.CS.LPT2_BV_PID
  // class TRANSFORM.Controls.LimPID
  initial equation
    if (BOP.CS.LPT2_BV_PID.initType == Modelica.Blocks.Types.Init.InitialOutput)
       then 
      BOP.CS.LPT2_BV_PID.y = BOP.CS.LPT2_BV_PID.y_start;
    end if;

  // Component BOP.CS.hysteresis
  // class Modelica.Blocks.Logical.Hysteresis
  initial equation
    pre(BOP.CS.hysteresis.y) = BOP.CS.hysteresis.pre_y_start;

  // Component BOP.HPT
  // class TRANSFORM.Fluid.Machines.SteamTurbine
    // extends TRANSFORM.Fluid.Machines.BaseClasses.SteamTurbineBase
    initial equation
      if (BOP.HPT.energyDynamics == TRANSFORM.Types.Dynamics.FixedInitial) then 
        BOP.HPT.Q_units = BOP.HPT.Q_units_start;
      elseif (BOP.HPT.energyDynamics == TRANSFORM.Types.Dynamics.
        SteadyStateInitial) then 
        der(BOP.HPT.Q_units) = zeros(BOP.HPT.nUnits);
      end if;
    // end of extends 
  initial equation
    if (BOP.HPT.use_NominalInlet) then 
      if (BOP.HPT.use_T_nominal) then 
        BOP.HPT.Kt = BOP.HPT.m_flow_nominal/(sqrt(BOP.HPT.p_inlet_nominal*
          Modelica.Media.Water.WaterIF97_ph.density_Unique30(
          Modelica.Media.Water.WaterIF97_ph.setState_pTX_Unique13(
            BOP.HPT.p_inlet_nominal, BOP.HPT.T_nominal, {1.0}, 0, 0)))*
          Modelica.Fluid.Utilities.regRoot2(1-(BOP.HPT.p_outlet_nominal/
          BOP.HPT.p_inlet_nominal)^2, 0.01, 1, 1, false, 1));
      else
        BOP.HPT.Kt = BOP.HPT.m_flow_nominal/(sqrt(BOP.HPT.p_inlet_nominal*
          BOP.HPT.d_nominal)*Modelica.Fluid.Utilities.regRoot2(1-(
          BOP.HPT.p_outlet_nominal/BOP.HPT.p_inlet_nominal)^2, 0.01, 1, 1, false,
           1));
      end if;
    else
      BOP.HPT.Kt = BOP.HPT.Kt_constant;
    end if;

  // Component BOP.LPT1
  // class TRANSFORM.Fluid.Machines.SteamTurbine
    // extends TRANSFORM.Fluid.Machines.BaseClasses.SteamTurbineBase
    initial equation
      if (BOP.LPT1.energyDynamics == TRANSFORM.Types.Dynamics.FixedInitial)
         then 
        BOP.LPT1.Q_units = BOP.LPT1.Q_units_start;
      elseif (BOP.LPT1.energyDynamics == TRANSFORM.Types.Dynamics.
        SteadyStateInitial) then 
        der(BOP.LPT1.Q_units) = zeros(BOP.LPT1.nUnits);
      end if;
    // end of extends 
  initial equation
    if (BOP.LPT1.use_NominalInlet) then 
      if (BOP.LPT1.use_T_nominal) then 
        BOP.LPT1.Kt = BOP.LPT1.m_flow_nominal/(sqrt(BOP.LPT1.p_inlet_nominal*
          Modelica.Media.Water.WaterIF97_ph.density_Unique30(
          Modelica.Media.Water.WaterIF97_ph.setState_pTX_Unique13(
            BOP.LPT1.p_inlet_nominal, BOP.LPT1.T_nominal, {1.0}, 0, 0)))*
          Modelica.Fluid.Utilities.regRoot2(1-(BOP.LPT1.p_outlet_nominal/
          BOP.LPT1.p_inlet_nominal)^2, 0.01, 1, 1, false, 1));
      else
        BOP.LPT1.Kt = BOP.LPT1.m_flow_nominal/(sqrt(BOP.LPT1.p_inlet_nominal*
          BOP.LPT1.d_nominal)*Modelica.Fluid.Utilities.regRoot2(1-(
          BOP.LPT1.p_outlet_nominal/BOP.LPT1.p_inlet_nominal)^2, 0.01, 1, 1, 
          false, 1));
      end if;
    else
      BOP.LPT1.Kt = BOP.LPT1.Kt_constant;
    end if;

  // Component BOP.LPT2
  // class TRANSFORM.Fluid.Machines.SteamTurbine
    // extends TRANSFORM.Fluid.Machines.BaseClasses.SteamTurbineBase
    initial equation
      if (BOP.LPT2.energyDynamics == TRANSFORM.Types.Dynamics.FixedInitial)
         then 
        BOP.LPT2.Q_units = BOP.LPT2.Q_units_start;
      elseif (BOP.LPT2.energyDynamics == TRANSFORM.Types.Dynamics.
        SteadyStateInitial) then 
        der(BOP.LPT2.Q_units) = zeros(BOP.LPT2.nUnits);
      end if;
    // end of extends 
  initial equation
    if (BOP.LPT2.use_NominalInlet) then 
      if (BOP.LPT2.use_T_nominal) then 
        BOP.LPT2.Kt = BOP.LPT2.m_flow_nominal/(sqrt(BOP.LPT2.p_inlet_nominal*
          Modelica.Media.Water.WaterIF97_ph.density_Unique30(
          Modelica.Media.Water.WaterIF97_ph.setState_pTX_Unique13(
            BOP.LPT2.p_inlet_nominal, BOP.LPT2.T_nominal, {1.0}, 0, 0)))*
          Modelica.Fluid.Utilities.regRoot2(1-(BOP.LPT2.p_outlet_nominal/
          BOP.LPT2.p_inlet_nominal)^2, 0.01, 1, 1, false, 1));
      else
        BOP.LPT2.Kt = BOP.LPT2.m_flow_nominal/(sqrt(BOP.LPT2.p_inlet_nominal*
          BOP.LPT2.d_nominal)*Modelica.Fluid.Utilities.regRoot2(1-(
          BOP.LPT2.p_outlet_nominal/BOP.LPT2.p_inlet_nominal)^2, 0.01, 1, 1, 
          false, 1));
      end if;
    else
      BOP.LPT2.Kt = BOP.LPT2.Kt_constant;
    end if;

  // Component BOP.moistureSeperator
  // class TRANSFORM.Fluid.Volumes.Separator
    // extends TRANSFORM.Fluid.Volumes.BaseClasses.PartialVolume
    initial equation
      if (BOP.moistureSeperator.massDynamics == Modelica.Fluid.Types.Dynamics.
        FixedInitial) then 
        if (BOP.moistureSeperator.initialize_p) then 
          BOP.moistureSeperator.medium.p = BOP.moistureSeperator.p_start;
        end if;
      elseif (BOP.moistureSeperator.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        if (BOP.moistureSeperator.initialize_p) then 
          der(BOP.moistureSeperator.medium.p) = 0;
        end if;
      end if;
      if (BOP.moistureSeperator.energyDynamics == Modelica.Fluid.Types.Dynamics.
        FixedInitial) then 
        BOP.moistureSeperator.medium.h = BOP.moistureSeperator.h_start;
      elseif (BOP.moistureSeperator.energyDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(BOP.moistureSeperator.medium.h) = 0;
      end if;
      if (BOP.moistureSeperator.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        FixedInitial) then 
        BOP.moistureSeperator.medium.Xi = BOP.moistureSeperator.X_start[1:0];
      elseif (BOP.moistureSeperator.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(BOP.moistureSeperator.medium.Xi) = zeros(0);
      end if;
      if (BOP.moistureSeperator.traceDynamics == Modelica.Fluid.Types.Dynamics.
        FixedInitial) then 
        BOP.moistureSeperator.C = BOP.moistureSeperator.C_start;
      elseif (BOP.moistureSeperator.traceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(BOP.moistureSeperator.mC) = zeros(0);
      end if;
    // end of extends 

  // Component BOP.LPT1_bypass
  // class TRANSFORM.Fluid.FittingsAndResistances.TeeJunctionVolume
    // extends TRANSFORM.Fluid.Volumes.BaseClasses.PartialVolume
    initial equation
      if (BOP.LPT1_bypass.massDynamics == Modelica.Fluid.Types.Dynamics.
        FixedInitial) then 
        if (BOP.LPT1_bypass.initialize_p) then 
          BOP.LPT1_bypass.medium.p = BOP.LPT1_bypass.p_start;
        end if;
      elseif (BOP.LPT1_bypass.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        if (BOP.LPT1_bypass.initialize_p) then 
          der(BOP.LPT1_bypass.medium.p) = 0;
        end if;
      end if;
      if (BOP.LPT1_bypass.energyDynamics == Modelica.Fluid.Types.Dynamics.
        FixedInitial) then 
        BOP.LPT1_bypass.medium.h = BOP.LPT1_bypass.h_start;
      elseif (BOP.LPT1_bypass.energyDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(BOP.LPT1_bypass.medium.h) = 0;
      end if;
      if (BOP.LPT1_bypass.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        FixedInitial) then 
        BOP.LPT1_bypass.medium.Xi = BOP.LPT1_bypass.X_start[1:0];
      elseif (BOP.LPT1_bypass.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(BOP.LPT1_bypass.medium.Xi) = zeros(0);
      end if;
      if (BOP.LPT1_bypass.traceDynamics == Modelica.Fluid.Types.Dynamics.
        FixedInitial) then 
        BOP.LPT1_bypass.C = BOP.LPT1_bypass.C_start;
      elseif (BOP.LPT1_bypass.traceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(BOP.LPT1_bypass.mC) = zeros(0);
      end if;
    // end of extends 

  // Component BOP.condenser
  // class TRANSFORM.Fluid.Volumes.IdealCondenser
  initial equation
    if (BOP.condenser.massDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)
       then 
      BOP.condenser.V_liquid = BOP.condenser.V_liquid_start;
    elseif (BOP.condenser.massDynamics == Modelica.Fluid.Types.Dynamics.
      SteadyStateInitial) then 
      BOP.condenser.V_liquid = BOP.condenser.V_liquid_start;
    end if;

  // Component BOP.generator
  // class TRANSFORM.Electrical.PowerConverters.Generator
  initial equation
    if (BOP.generator.momentumDynamics == Modelica.Fluid.Types.Dynamics.
      SteadyStateInitial) then 
      der(BOP.generator.omega_m) = 0;
    end if;

  // Component BOP.OFWH_1
  // class TRANSFORM.Fluid.Volumes.SimpleVolume
    // extends TRANSFORM.Fluid.Volumes.BaseClasses.PartialVolume
    initial equation
      if (BOP.OFWH_1.massDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)
         then 
        if (BOP.OFWH_1.initialize_p) then 
          BOP.OFWH_1.medium.p = BOP.OFWH_1.p_start;
        end if;
      elseif (BOP.OFWH_1.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        if (BOP.OFWH_1.initialize_p) then 
          der(BOP.OFWH_1.medium.p) = 0;
        end if;
      end if;
      if (BOP.OFWH_1.energyDynamics == Modelica.Fluid.Types.Dynamics.
        FixedInitial) then 
        BOP.OFWH_1.medium.h = BOP.OFWH_1.h_start;
      elseif (BOP.OFWH_1.energyDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(BOP.OFWH_1.medium.h) = 0;
      end if;
      if (BOP.OFWH_1.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        FixedInitial) then 
        BOP.OFWH_1.medium.Xi = BOP.OFWH_1.X_start[1:0];
      elseif (BOP.OFWH_1.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(BOP.OFWH_1.medium.Xi) = zeros(0);
      end if;
      if (BOP.OFWH_1.traceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)
         then 
        BOP.OFWH_1.C = BOP.OFWH_1.C_start;
      elseif (BOP.OFWH_1.traceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(BOP.OFWH_1.mC) = zeros(0);
      end if;
    // end of extends 

  // Component BOP.OFWH_2
  // class TRANSFORM.Fluid.Volumes.SimpleVolume
    // extends TRANSFORM.Fluid.Volumes.BaseClasses.PartialVolume
    initial equation
      if (BOP.OFWH_2.massDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)
         then 
        if (BOP.OFWH_2.initialize_p) then 
          BOP.OFWH_2.medium.p = BOP.OFWH_2.p_start;
        end if;
      elseif (BOP.OFWH_2.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        if (BOP.OFWH_2.initialize_p) then 
          der(BOP.OFWH_2.medium.p) = 0;
        end if;
      end if;
      if (BOP.OFWH_2.energyDynamics == Modelica.Fluid.Types.Dynamics.
        FixedInitial) then 
        BOP.OFWH_2.medium.h = BOP.OFWH_2.h_start;
      elseif (BOP.OFWH_2.energyDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(BOP.OFWH_2.medium.h) = 0;
      end if;
      if (BOP.OFWH_2.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        FixedInitial) then 
        BOP.OFWH_2.medium.Xi = BOP.OFWH_2.X_start[1:0];
      elseif (BOP.OFWH_2.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(BOP.OFWH_2.medium.Xi) = zeros(0);
      end if;
      if (BOP.OFWH_2.traceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)
         then 
        BOP.OFWH_2.C = BOP.OFWH_2.C_start;
      elseif (BOP.OFWH_2.traceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(BOP.OFWH_2.mC) = zeros(0);
      end if;
    // end of extends 

  // Component integrator
  // class Modelica.Blocks.Continuous.Integrator
  initial equation
    if (integrator.initType == Modelica.Blocks.Types.Init.SteadyState) then 
      der(integrator.y) = 0;
    elseif (integrator.initType == Modelica.Blocks.Types.Init.InitialState or 
      integrator.initType == Modelica.Blocks.Types.Init.InitialOutput) then 
      integrator.y = integrator.y_start;
    end if;

  // Component volume
  // class TRANSFORM.Fluid.Volumes.SimpleVolume
    // extends TRANSFORM.Fluid.Volumes.BaseClasses.PartialVolume
    initial equation
      if (volume.massDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)
         then 
        if (volume.initialize_p) then 
          volume.medium.p = volume.p_start;
        end if;
      elseif (volume.massDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        if (volume.initialize_p) then 
          der(volume.medium.p) = 0;
        end if;
      end if;
      if (volume.energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)
         then 
        volume.medium.h = volume.h_start;
      elseif (volume.energyDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(volume.medium.h) = 0;
      end if;
      if (volume.substanceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)
         then 
        volume.medium.Xi = volume.X_start[1:0];
      elseif (volume.substanceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(volume.medium.Xi) = zeros(0);
      end if;
      if (volume.traceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)
         then 
        volume.C = volume.C_start;
      elseif (volume.traceDynamics == Modelica.Fluid.Types.Dynamics.
        SteadyStateInitial) then 
        der(volume.mC) = zeros(0);
      end if;
    // end of extends 

  // Component flowCV.PID.I
  // class TRANSFORM.Blocks.IntegratorWithReset
  initial equation
    if (flowCV.PID.I.initType == Modelica.Blocks.Types.Init.SteadyState) then 
      der(flowCV.PID.I.y) = 0;
    elseif (flowCV.PID.I.initType == Modelica.Blocks.Types.Init.InitialState or 
      flowCV.PID.I.initType == Modelica.Blocks.Types.Init.InitialOutput) then 
      flowCV.PID.I.y = flowCV.PID.I.y_start;
    end if;

  // Component flowCV.PID
  // class NHES.Controls.LimOffsetPID
  initial equation
    if (flowCV.PID.initType == Modelica.Blocks.Types.Init.InitialOutput) then 
      flowCV.PID.y = flowCV.PID.y_start;
    end if;

end NSSS_Test_b_SEC3_RealExpression_MoveFWHExtraction;
